{"ast":null,"code":"export function createPromiseBuffer(options) {\n  const {\n    size,\n    concurrency\n  } = options;\n  const buffer = []; // pending, not-yet-started tasks\n  let inProgress = 0; // counter for tasks currently in progress\n  const work = () => {\n    // if there's space for a task and buffer is not empty,\n    // take one task from buffer and run it\n    if (inProgress < concurrency && buffer.length) {\n      const {\n        producer,\n        resolve,\n        reject\n      } = buffer.shift();\n      inProgress++;\n      producer().then(result => {\n        inProgress--;\n        work();\n        resolve(result);\n      }, reason => {\n        inProgress--;\n        work();\n        reject(reason);\n      });\n    }\n  };\n  const add = promiseProducer => {\n    if (buffer.length + inProgress >= size) {\n      throw new Error('Task buffer full');\n    }\n    return new Promise((resolve, reject) => {\n      buffer.push({\n        producer: promiseProducer,\n        resolve,\n        reject\n      });\n      work();\n    });\n  };\n  return {\n    add\n  };\n}","map":{"version":3,"names":["createPromiseBuffer","options","size","concurrency","buffer","inProgress","work","length","producer","resolve","reject","shift","then","result","reason","add","promiseProducer","Error","Promise","push"],"sources":["/home/egor/node_modules/@grafana/faro-core/src/utils/promiseBuffer.ts"],"sourcesContent":["export interface PromiseBufferOptions {\n  // total number of concurrent tasks\n  concurrency: number;\n  // total number of uncompleted tasks to accept\n  size: number;\n}\n\nexport type PromiseProducer<T> = () => PromiseLike<T>;\n\nexport interface PromiseBuffer<T> {\n  add(promiseProducer: PromiseProducer<T>): PromiseLike<T>;\n}\n\nexport interface BufferItem<T> {\n  producer: PromiseProducer<T>;\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n}\n\nexport function createPromiseBuffer<T>(options: PromiseBufferOptions): PromiseBuffer<T> {\n  const { size, concurrency } = options;\n\n  const buffer: Array<BufferItem<T>> = []; // pending, not-yet-started tasks\n  let inProgress = 0; // counter for tasks currently in progress\n\n  const work = () => {\n    // if there's space for a task and buffer is not empty,\n    // take one task from buffer and run it\n    if (inProgress < concurrency && buffer.length) {\n      const { producer, resolve, reject } = buffer.shift()!;\n\n      inProgress++;\n\n      producer().then(\n        (result) => {\n          inProgress--;\n\n          work();\n\n          resolve(result);\n        },\n        (reason) => {\n          inProgress--;\n\n          work();\n\n          reject(reason);\n        }\n      );\n    }\n  };\n\n  const add: PromiseBuffer<T>['add'] = (promiseProducer) => {\n    if (buffer.length + inProgress >= size) {\n      throw new Error('Task buffer full');\n    }\n\n    return new Promise<T>((resolve, reject) => {\n      buffer.push({\n        producer: promiseProducer,\n        resolve,\n        reject,\n      });\n      work();\n    });\n  };\n\n  return {\n    add,\n  };\n}\n"],"mappings":"AAmBA,OAAM,SAAUA,mBAAmBA,CAAIC,OAA6B;EAClE,MAAM;IAAEC,IAAI;IAAEC;EAAW,CAAE,GAAGF,OAAO;EAErC,MAAMG,MAAM,GAAyB,EAAE,CAAC,CAAC;EACzC,IAAIC,UAAU,GAAG,CAAC,CAAC,CAAC;EAEpB,MAAMC,IAAI,GAAGA,CAAA,KAAK;IAChB;IACA;IACA,IAAID,UAAU,GAAGF,WAAW,IAAIC,MAAM,CAACG,MAAM,EAAE;MAC7C,MAAM;QAAEC,QAAQ;QAAEC,OAAO;QAAEC;MAAM,CAAE,GAAGN,MAAM,CAACO,KAAK,EAAG;MAErDN,UAAU,EAAE;MAEZG,QAAQ,EAAE,CAACI,IAAI,CACZC,MAAM,IAAI;QACTR,UAAU,EAAE;QAEZC,IAAI,EAAE;QAENG,OAAO,CAACI,MAAM,CAAC;MACjB,CAAC,EACAC,MAAM,IAAI;QACTT,UAAU,EAAE;QAEZC,IAAI,EAAE;QAENI,MAAM,CAACI,MAAM,CAAC;MAChB,CAAC,CACF;;EAEL,CAAC;EAED,MAAMC,GAAG,GAA6BC,eAAe,IAAI;IACvD,IAAIZ,MAAM,CAACG,MAAM,GAAGF,UAAU,IAAIH,IAAI,EAAE;MACtC,MAAM,IAAIe,KAAK,CAAC,kBAAkB,CAAC;;IAGrC,OAAO,IAAIC,OAAO,CAAI,CAACT,OAAO,EAAEC,MAAM,KAAI;MACxCN,MAAM,CAACe,IAAI,CAAC;QACVX,QAAQ,EAAEQ,eAAe;QACzBP,OAAO;QACPC;OACD,CAAC;MACFJ,IAAI,EAAE;IACR,CAAC,CAAC;EACJ,CAAC;EAED,OAAO;IACLS;GACD;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}