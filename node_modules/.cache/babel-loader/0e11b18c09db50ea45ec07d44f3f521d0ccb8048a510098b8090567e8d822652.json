{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { diag } from '@opentelemetry/api';\n/** Combines multiple propagators into a single propagator. */\nvar CompositePropagator = /** @class */function () {\n  /**\n   * Construct a composite propagator from a list of propagators.\n   *\n   * @param [config] Configuration object for composite propagator\n   */\n  function CompositePropagator(config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var _a;\n    this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];\n    this._fields = Array.from(new Set(this._propagators\n    // older propagators may not have fields function, null check to be sure\n    .map(function (p) {\n      return typeof p.fields === 'function' ? p.fields() : [];\n    }).reduce(function (x, y) {\n      return x.concat(y);\n    }, [])));\n  }\n  /**\n   * Run each of the configured propagators with the given context and carrier.\n   * Propagators are run in the order they are configured, so if multiple\n   * propagators write the same carrier key, the propagator later in the list\n   * will \"win\".\n   *\n   * @param context Context to inject\n   * @param carrier Carrier into which context will be injected\n   */\n  CompositePropagator.prototype.inject = function (context, carrier, setter) {\n    var e_1, _a;\n    try {\n      for (var _b = __values(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var propagator = _c.value;\n        try {\n          propagator.inject(context, carrier, setter);\n        } catch (err) {\n          diag.warn(\"Failed to inject with \" + propagator.constructor.name + \". Err: \" + err.message);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  /**\n   * Run each of the configured propagators with the given context and carrier.\n   * Propagators are run in the order they are configured, so if multiple\n   * propagators write the same context key, the propagator later in the list\n   * will \"win\".\n   *\n   * @param context Context to add values to\n   * @param carrier Carrier from which to extract context\n   */\n  CompositePropagator.prototype.extract = function (context, carrier, getter) {\n    return this._propagators.reduce(function (ctx, propagator) {\n      try {\n        return propagator.extract(ctx, carrier, getter);\n      } catch (err) {\n        diag.warn(\"Failed to inject with \" + propagator.constructor.name + \". Err: \" + err.message);\n      }\n      return ctx;\n    }, context);\n  };\n  CompositePropagator.prototype.fields = function () {\n    // return a new array so our fields cannot be modified\n    return this._fields.slice();\n  };\n  return CompositePropagator;\n}();\nexport { CompositePropagator };","map":{"version":3,"names":["diag","CompositePropagator","config","_propagators","_a","propagators","_fields","Array","from","Set","map","p","fields","reduce","x","y","concat","prototype","inject","context","carrier","setter","_b","__values","_c","next","done","propagator","value","err","warn","constructor","name","message","extract","getter","ctx","slice"],"sources":["/home/egor/node_modules/@opentelemetry/core/src/propagation/composite.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  TextMapGetter,\n  TextMapPropagator,\n  diag,\n  TextMapSetter,\n} from '@opentelemetry/api';\n\n/** Configuration object for composite propagator */\nexport interface CompositePropagatorConfig {\n  /**\n   * List of propagators to run. Propagators run in the\n   * list order. If a propagator later in the list writes the same context\n   * key as a propagator earlier in the list, the later on will \"win\".\n   */\n  propagators?: TextMapPropagator[];\n}\n\n/** Combines multiple propagators into a single propagator. */\nexport class CompositePropagator implements TextMapPropagator {\n  private readonly _propagators: TextMapPropagator[];\n  private readonly _fields: string[];\n\n  /**\n   * Construct a composite propagator from a list of propagators.\n   *\n   * @param [config] Configuration object for composite propagator\n   */\n  constructor(config: CompositePropagatorConfig = {}) {\n    this._propagators = config.propagators ?? [];\n\n    this._fields = Array.from(\n      new Set(\n        this._propagators\n          // older propagators may not have fields function, null check to be sure\n          .map(p => (typeof p.fields === 'function' ? p.fields() : []))\n          .reduce((x, y) => x.concat(y), [])\n      )\n    );\n  }\n\n  /**\n   * Run each of the configured propagators with the given context and carrier.\n   * Propagators are run in the order they are configured, so if multiple\n   * propagators write the same carrier key, the propagator later in the list\n   * will \"win\".\n   *\n   * @param context Context to inject\n   * @param carrier Carrier into which context will be injected\n   */\n  inject(context: Context, carrier: unknown, setter: TextMapSetter): void {\n    for (const propagator of this._propagators) {\n      try {\n        propagator.inject(context, carrier, setter);\n      } catch (err) {\n        diag.warn(\n          `Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Run each of the configured propagators with the given context and carrier.\n   * Propagators are run in the order they are configured, so if multiple\n   * propagators write the same context key, the propagator later in the list\n   * will \"win\".\n   *\n   * @param context Context to add values to\n   * @param carrier Carrier from which to extract context\n   */\n  extract(context: Context, carrier: unknown, getter: TextMapGetter): Context {\n    return this._propagators.reduce((ctx, propagator) => {\n      try {\n        return propagator.extract(ctx, carrier, getter);\n      } catch (err) {\n        diag.warn(\n          `Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`\n        );\n      }\n      return ctx;\n    }, context);\n  }\n\n  fields(): string[] {\n    // return a new array so our fields cannot be modified\n    return this._fields.slice();\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,SAIEA,IAAI,QAEC,oBAAoB;AAY3B;AACA,IAAAC,mBAAA;EAIE;;;;;EAKA,SAAAA,oBAAYC,MAAsC;IAAtC,IAAAA,MAAA;MAAAA,MAAA,KAAsC;IAAA;;IAChD,IAAI,CAACC,YAAY,GAAG,CAAAC,EAAA,GAAAF,MAAM,CAACG,WAAW,cAAAD,EAAA,cAAAA,EAAA,GAAI,EAAE;IAE5C,IAAI,CAACE,OAAO,GAAGC,KAAK,CAACC,IAAI,CACvB,IAAIC,GAAG,CACL,IAAI,CAACN;IACH;IAAA,CACCO,GAAG,CAAC,UAAAC,CAAC;MAAI,OAAC,OAAOA,CAAC,CAACC,MAAM,KAAK,UAAU,GAAGD,CAAC,CAACC,MAAM,EAAE,GAAG,EAAE;IAAjD,CAAkD,CAAC,CAC5DC,MAAM,CAAC,UAACC,CAAC,EAAEC,CAAC;MAAK,OAAAD,CAAC,CAACE,MAAM,CAACD,CAAC,CAAC;IAAX,CAAW,EAAE,EAAE,CAAC,CACrC,CACF;EACH;EAEA;;;;;;;;;EASAd,mBAAA,CAAAgB,SAAA,CAAAC,MAAM,GAAN,UAAOC,OAAgB,EAAEC,OAAgB,EAAEC,MAAqB;;;MAC9D,KAAyB,IAAAC,EAAA,GAAAC,QAAA,KAAI,CAACpB,YAAY,GAAAqB,EAAA,GAAAF,EAAA,CAAAG,IAAA,KAAAD,EAAA,CAAAE,IAAA,EAAAF,EAAA,GAAAF,EAAA,CAAAG,IAAA,IAAE;QAAvC,IAAME,UAAU,GAAAH,EAAA,CAAAI,KAAA;QACnB,IAAI;UACFD,UAAU,CAACT,MAAM,CAACC,OAAO,EAAEC,OAAO,EAAEC,MAAM,CAAC;SAC5C,CAAC,OAAOQ,GAAG,EAAE;UACZ7B,IAAI,CAAC8B,IAAI,CACP,2BAAyBH,UAAU,CAACI,WAAW,CAACC,IAAI,eAAUH,GAAG,CAACI,OAAS,CAC5E;;;;;;;;;;;;;;EAGP,CAAC;EAED;;;;;;;;;EASAhC,mBAAA,CAAAgB,SAAA,CAAAiB,OAAO,GAAP,UAAQf,OAAgB,EAAEC,OAAgB,EAAEe,MAAqB;IAC/D,OAAO,IAAI,CAAChC,YAAY,CAACU,MAAM,CAAC,UAACuB,GAAG,EAAET,UAAU;MAC9C,IAAI;QACF,OAAOA,UAAU,CAACO,OAAO,CAACE,GAAG,EAAEhB,OAAO,EAAEe,MAAM,CAAC;OAChD,CAAC,OAAON,GAAG,EAAE;QACZ7B,IAAI,CAAC8B,IAAI,CACP,2BAAyBH,UAAU,CAACI,WAAW,CAACC,IAAI,eAAUH,GAAG,CAACI,OAAS,CAC5E;;MAEH,OAAOG,GAAG;IACZ,CAAC,EAAEjB,OAAO,CAAC;EACb,CAAC;EAEDlB,mBAAA,CAAAgB,SAAA,CAAAL,MAAM,GAAN;IACE;IACA,OAAO,IAAI,CAACN,OAAO,CAAC+B,KAAK,EAAE;EAC7B,CAAC;EACH,OAAApC,mBAAC;AAAD,CAAC,CArED"},"metadata":{},"sourceType":"module","externalDependencies":[]}