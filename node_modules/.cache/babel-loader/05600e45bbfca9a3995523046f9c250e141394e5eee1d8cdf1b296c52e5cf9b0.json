{"ast":null,"code":"export function performanceObserverSupported() {\n  return 'PerformanceObserver' in window;\n}\nexport function entryUrlIsIgnored() {\n  let ignoredUrls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let entryName = arguments.length > 1 ? arguments[1] : undefined;\n  return ignoredUrls.some(url => entryName.match(url) != null);\n}\nexport function onDocumentReady(handleReady) {\n  if (document.readyState === 'complete') {\n    handleReady();\n  } else {\n    const readyStateCompleteHandler = () => {\n      if (document.readyState === 'complete') {\n        handleReady();\n        document.removeEventListener('readystatechange', readyStateCompleteHandler);\n      }\n    };\n    document.addEventListener('readystatechange', readyStateCompleteHandler);\n  }\n}\nexport function calculateFaroResourceTiming(resourceEntryRaw) {\n  const {\n    connectEnd,\n    connectStart,\n    decodedBodySize,\n    domainLookupEnd,\n    domainLookupStart,\n    duration,\n    encodedBodySize,\n    fetchStart,\n    initiatorType,\n    name,\n    nextHopProtocol,\n    redirectEnd,\n    redirectStart,\n    // @ts-expect-error the renderBlockingStatus property is not available in all browsers\n    renderBlockingStatus: rbs,\n    requestStart,\n    responseEnd,\n    responseStart,\n    // @ts-expect-error the renderBlockingStatus property is not available in all browsers\n    responseStatus,\n    secureConnectionStart,\n    transferSize,\n    workerStart\n  } = resourceEntryRaw;\n  return {\n    name: name,\n    duration: toFaroPerformanceTimingString(duration),\n    tcpHandshakeTime: toFaroPerformanceTimingString(connectEnd - connectStart),\n    dnsLookupTime: toFaroPerformanceTimingString(domainLookupEnd - domainLookupStart),\n    tlsNegotiationTime: toFaroPerformanceTimingString(requestStart - secureConnectionStart),\n    redirectTime: toFaroPerformanceTimingString(redirectEnd - redirectStart),\n    requestTime: toFaroPerformanceTimingString(responseStart - requestStart),\n    responseTime: toFaroPerformanceTimingString(responseEnd - responseStart),\n    fetchTime: toFaroPerformanceTimingString(responseEnd - fetchStart),\n    serviceWorkerTime: toFaroPerformanceTimingString(fetchStart - workerStart),\n    decodedBodySize: toFaroPerformanceTimingString(decodedBodySize),\n    encodedBodySize: toFaroPerformanceTimingString(encodedBodySize),\n    cacheHitStatus: getCacheType(),\n    renderBlockingStatus: toFaroPerformanceTimingString(rbs),\n    protocol: nextHopProtocol,\n    initiatorType: initiatorType\n    // TODO: add in future iteration, ideally after nested objects are supported by the collector.\n    // serverTiming: resourceEntryRaw.serverTiming,\n  };\n\n  function getCacheType() {\n    let cacheType = 'fullLoad';\n    if (transferSize === 0) {\n      if (decodedBodySize > 0) {\n        cacheType = 'cache';\n      }\n    } else {\n      if (responseStatus != null) {\n        if (responseStatus === 304) {\n          cacheType = 'conditionalFetch';\n        }\n      } else if (encodedBodySize > 0 && transferSize < encodedBodySize) {\n        cacheType = 'conditionalFetch';\n      }\n    }\n    return cacheType;\n  }\n}\nexport function calculateFaroNavigationTiming(navigationEntryRaw) {\n  const {\n    activationStart,\n    domComplete,\n    domContentLoadedEventEnd,\n    domContentLoadedEventStart,\n    domInteractive,\n    fetchStart,\n    loadEventEnd,\n    loadEventStart,\n    responseStart,\n    type\n  } = navigationEntryRaw;\n  return Object.assign({\n    visibilityState: document.visibilityState,\n    pageLoadTime: toFaroPerformanceTimingString(domComplete - fetchStart),\n    domProcessingTime: toFaroPerformanceTimingString(domComplete - domInteractive),\n    domContentLoadHandlerTime: toFaroPerformanceTimingString(domContentLoadedEventEnd - domContentLoadedEventStart),\n    onLoadTime: toFaroPerformanceTimingString(loadEventEnd - loadEventStart),\n    // For more accuracy on prerendered pages page we calculate relative top the activationStart instead of the start of the navigation.\n    // clamp to 0 if activationStart occurs after first byte is received.\n    ttfb: toFaroPerformanceTimingString(Math.max(responseStart - (activationStart !== null && activationStart !== void 0 ? activationStart : 0), 0)),\n    type: type\n  }, calculateFaroResourceTiming(navigationEntryRaw));\n}\nfunction toFaroPerformanceTimingString(v) {\n  if (v == null) {\n    return 'unknown';\n  }\n  if (typeof v === 'number') {\n    return Math.round(v).toString();\n  }\n  return v.toString();\n}","map":{"version":3,"names":["performanceObserverSupported","window","entryUrlIsIgnored","ignoredUrls","arguments","length","undefined","entryName","some","url","match","onDocumentReady","handleReady","document","readyState","readyStateCompleteHandler","removeEventListener","addEventListener","calculateFaroResourceTiming","resourceEntryRaw","connectEnd","connectStart","decodedBodySize","domainLookupEnd","domainLookupStart","duration","encodedBodySize","fetchStart","initiatorType","name","nextHopProtocol","redirectEnd","redirectStart","renderBlockingStatus","rbs","requestStart","responseEnd","responseStart","responseStatus","secureConnectionStart","transferSize","workerStart","toFaroPerformanceTimingString","tcpHandshakeTime","dnsLookupTime","tlsNegotiationTime","redirectTime","requestTime","responseTime","fetchTime","serviceWorkerTime","cacheHitStatus","getCacheType","protocol","cacheType","calculateFaroNavigationTiming","navigationEntryRaw","activationStart","domComplete","domContentLoadedEventEnd","domContentLoadedEventStart","domInteractive","loadEventEnd","loadEventStart","type","Object","assign","visibilityState","pageLoadTime","domProcessingTime","domContentLoadHandlerTime","onLoadTime","ttfb","Math","max","v","round","toString"],"sources":["/home/egor/node_modules/@grafana/faro-web-sdk/src/instrumentations/performance/performanceUtils.ts"],"sourcesContent":["import type { CacheType, FaroNavigationTiming, FaroResourceTiming } from './types';\n\nexport function performanceObserverSupported(): boolean {\n  return 'PerformanceObserver' in window;\n}\n\nexport function entryUrlIsIgnored(ignoredUrls: Array<string | RegExp> = [], entryName: string): boolean {\n  return ignoredUrls.some((url) => entryName.match(url) != null);\n}\n\nexport function onDocumentReady(handleReady: () => void) {\n  if (document.readyState === 'complete') {\n    handleReady();\n  } else {\n    const readyStateCompleteHandler = () => {\n      if (document.readyState === 'complete') {\n        handleReady();\n        document.removeEventListener('readystatechange', readyStateCompleteHandler);\n      }\n    };\n\n    document.addEventListener('readystatechange', readyStateCompleteHandler);\n  }\n}\n\nexport function calculateFaroResourceTiming(resourceEntryRaw: PerformanceResourceTiming): FaroResourceTiming {\n  const {\n    connectEnd,\n    connectStart,\n    decodedBodySize,\n    domainLookupEnd,\n    domainLookupStart,\n    duration,\n    encodedBodySize,\n    fetchStart,\n    initiatorType,\n    name,\n    nextHopProtocol,\n    redirectEnd,\n    redirectStart,\n    // @ts-expect-error the renderBlockingStatus property is not available in all browsers\n    renderBlockingStatus: rbs,\n    requestStart,\n    responseEnd,\n    responseStart,\n    // @ts-expect-error the renderBlockingStatus property is not available in all browsers\n    responseStatus,\n    secureConnectionStart,\n    transferSize,\n    workerStart,\n  } = resourceEntryRaw;\n\n  return {\n    name: name,\n    duration: toFaroPerformanceTimingString(duration),\n    tcpHandshakeTime: toFaroPerformanceTimingString(connectEnd - connectStart),\n    dnsLookupTime: toFaroPerformanceTimingString(domainLookupEnd - domainLookupStart),\n    tlsNegotiationTime: toFaroPerformanceTimingString(requestStart - secureConnectionStart),\n    redirectTime: toFaroPerformanceTimingString(redirectEnd - redirectStart),\n    requestTime: toFaroPerformanceTimingString(responseStart - requestStart),\n    responseTime: toFaroPerformanceTimingString(responseEnd - responseStart),\n    fetchTime: toFaroPerformanceTimingString(responseEnd - fetchStart),\n    serviceWorkerTime: toFaroPerformanceTimingString(fetchStart - workerStart),\n    decodedBodySize: toFaroPerformanceTimingString(decodedBodySize),\n    encodedBodySize: toFaroPerformanceTimingString(encodedBodySize),\n    cacheHitStatus: getCacheType(),\n    renderBlockingStatus: toFaroPerformanceTimingString(rbs) as FaroResourceTiming['renderBlockingStatus'],\n    protocol: nextHopProtocol,\n    initiatorType: initiatorType,\n\n    // TODO: add in future iteration, ideally after nested objects are supported by the collector.\n    // serverTiming: resourceEntryRaw.serverTiming,\n  };\n\n  function getCacheType(): CacheType {\n    let cacheType: CacheType = 'fullLoad';\n    if (transferSize === 0) {\n      if (decodedBodySize > 0) {\n        cacheType = 'cache';\n      }\n    } else {\n      if (responseStatus != null) {\n        if (responseStatus === 304) {\n          cacheType = 'conditionalFetch';\n        }\n      } else if (encodedBodySize > 0 && transferSize < encodedBodySize) {\n        cacheType = 'conditionalFetch';\n      }\n    }\n    return cacheType;\n  }\n}\n\nexport function calculateFaroNavigationTiming(navigationEntryRaw: PerformanceNavigationTiming): FaroNavigationTiming {\n  const {\n    activationStart,\n    domComplete,\n    domContentLoadedEventEnd,\n    domContentLoadedEventStart,\n    domInteractive,\n    fetchStart,\n    loadEventEnd,\n    loadEventStart,\n    responseStart,\n    type,\n  } = navigationEntryRaw;\n\n  return {\n    visibilityState: document.visibilityState,\n    pageLoadTime: toFaroPerformanceTimingString(domComplete - fetchStart),\n    domProcessingTime: toFaroPerformanceTimingString(domComplete - domInteractive),\n    domContentLoadHandlerTime: toFaroPerformanceTimingString(domContentLoadedEventEnd - domContentLoadedEventStart),\n    onLoadTime: toFaroPerformanceTimingString(loadEventEnd - loadEventStart),\n\n    // For more accuracy on prerendered pages page we calculate relative top the activationStart instead of the start of the navigation.\n    // clamp to 0 if activationStart occurs after first byte is received.\n    ttfb: toFaroPerformanceTimingString(Math.max(responseStart - (activationStart ?? 0), 0)),\n\n    type: type,\n\n    ...calculateFaroResourceTiming(navigationEntryRaw),\n  };\n}\n\nfunction toFaroPerformanceTimingString(v: unknown): string {\n  if (v == null) {\n    return 'unknown';\n  }\n\n  if (typeof v === 'number') {\n    return Math.round(v).toString();\n  }\n\n  return v.toString();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}