{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ValueType, diag } from '@opentelemetry/api';\nimport { equalsCaseInsensitive } from './utils';\n/**\n * Supported types of metric instruments.\n */\nexport var InstrumentType;\n(function (InstrumentType) {\n  InstrumentType[\"COUNTER\"] = \"COUNTER\";\n  InstrumentType[\"HISTOGRAM\"] = \"HISTOGRAM\";\n  InstrumentType[\"UP_DOWN_COUNTER\"] = \"UP_DOWN_COUNTER\";\n  InstrumentType[\"OBSERVABLE_COUNTER\"] = \"OBSERVABLE_COUNTER\";\n  InstrumentType[\"OBSERVABLE_GAUGE\"] = \"OBSERVABLE_GAUGE\";\n  InstrumentType[\"OBSERVABLE_UP_DOWN_COUNTER\"] = \"OBSERVABLE_UP_DOWN_COUNTER\";\n})(InstrumentType || (InstrumentType = {}));\nexport function createInstrumentDescriptor(name, type, options) {\n  var _a, _b, _c, _d;\n  if (!isValidName(name)) {\n    diag.warn(\"Invalid metric name: \\\"\" + name + \"\\\". The metric name should be a ASCII string with a length no greater than 255 characters.\");\n  }\n  return {\n    name: name,\n    type: type,\n    description: (_a = options === null || options === void 0 ? void 0 : options.description) !== null && _a !== void 0 ? _a : '',\n    unit: (_b = options === null || options === void 0 ? void 0 : options.unit) !== null && _b !== void 0 ? _b : '',\n    valueType: (_c = options === null || options === void 0 ? void 0 : options.valueType) !== null && _c !== void 0 ? _c : ValueType.DOUBLE,\n    advice: (_d = options === null || options === void 0 ? void 0 : options.advice) !== null && _d !== void 0 ? _d : {}\n  };\n}\nexport function createInstrumentDescriptorWithView(view, instrument) {\n  var _a, _b;\n  return {\n    name: (_a = view.name) !== null && _a !== void 0 ? _a : instrument.name,\n    description: (_b = view.description) !== null && _b !== void 0 ? _b : instrument.description,\n    type: instrument.type,\n    unit: instrument.unit,\n    valueType: instrument.valueType,\n    advice: instrument.advice\n  };\n}\nexport function isDescriptorCompatibleWith(descriptor, otherDescriptor) {\n  // Names are case-insensitive strings.\n  return equalsCaseInsensitive(descriptor.name, otherDescriptor.name) && descriptor.unit === otherDescriptor.unit && descriptor.type === otherDescriptor.type && descriptor.valueType === otherDescriptor.valueType;\n}\n// ASCII string with a length no greater than 255 characters.\n// NB: the first character counted separately from the rest.\nvar NAME_REGEXP = /^[a-z][a-z0-9_.\\-/]{0,254}$/i;\nexport function isValidName(name) {\n  return name.match(NAME_REGEXP) != null;\n}","map":{"version":3,"names":["ValueType","diag","equalsCaseInsensitive","InstrumentType","createInstrumentDescriptor","name","type","options","isValidName","warn","description","_a","unit","_b","valueType","_c","DOUBLE","advice","_d","createInstrumentDescriptorWithView","view","instrument","isDescriptorCompatibleWith","descriptor","otherDescriptor","NAME_REGEXP","match"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/InstrumentDescriptor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MetricOptions, ValueType, diag } from '@opentelemetry/api';\nimport { View } from './view/View';\nimport { equalsCaseInsensitive } from './utils';\n\n/**\n * Supported types of metric instruments.\n */\nexport enum InstrumentType {\n  COUNTER = 'COUNTER',\n  HISTOGRAM = 'HISTOGRAM',\n  UP_DOWN_COUNTER = 'UP_DOWN_COUNTER',\n  OBSERVABLE_COUNTER = 'OBSERVABLE_COUNTER',\n  OBSERVABLE_GAUGE = 'OBSERVABLE_GAUGE',\n  OBSERVABLE_UP_DOWN_COUNTER = 'OBSERVABLE_UP_DOWN_COUNTER',\n}\n\n/**\n * An internal interface describing the instrument.\n *\n * This is intentionally distinguished from the public MetricDescriptor (a.k.a. InstrumentDescriptor)\n * which may not contains internal fields like metric advice.\n */\nexport interface InstrumentDescriptor {\n  readonly name: string;\n  readonly description: string;\n  readonly unit: string;\n  readonly type: InstrumentType;\n  readonly valueType: ValueType;\n  /**\n   * @experimental\n   *\n   * This is intentionally not using the API's type as it's only available from @opentelemetry/api 1.7.0 and up.\n   * In SDK 2.0 we'll be able to bump the minimum API version and remove this workaround.\n   */\n  readonly advice: {\n    /**\n     * Hint the explicit bucket boundaries for SDK if the metric has been\n     * aggregated with a HistogramAggregator.\n     */\n    explicitBucketBoundaries?: number[];\n  };\n}\n\nexport function createInstrumentDescriptor(\n  name: string,\n  type: InstrumentType,\n  options?: MetricOptions\n): InstrumentDescriptor {\n  if (!isValidName(name)) {\n    diag.warn(\n      `Invalid metric name: \"${name}\". The metric name should be a ASCII string with a length no greater than 255 characters.`\n    );\n  }\n  return {\n    name,\n    type,\n    description: options?.description ?? '',\n    unit: options?.unit ?? '',\n    valueType: options?.valueType ?? ValueType.DOUBLE,\n    advice: options?.advice ?? {},\n  };\n}\n\nexport function createInstrumentDescriptorWithView(\n  view: View,\n  instrument: InstrumentDescriptor\n): InstrumentDescriptor {\n  return {\n    name: view.name ?? instrument.name,\n    description: view.description ?? instrument.description,\n    type: instrument.type,\n    unit: instrument.unit,\n    valueType: instrument.valueType,\n    advice: instrument.advice,\n  };\n}\n\nexport function isDescriptorCompatibleWith(\n  descriptor: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n) {\n  // Names are case-insensitive strings.\n  return (\n    equalsCaseInsensitive(descriptor.name, otherDescriptor.name) &&\n    descriptor.unit === otherDescriptor.unit &&\n    descriptor.type === otherDescriptor.type &&\n    descriptor.valueType === otherDescriptor.valueType\n  );\n}\n\n// ASCII string with a length no greater than 255 characters.\n// NB: the first character counted separately from the rest.\nconst NAME_REGEXP = /^[a-z][a-z0-9_.\\-/]{0,254}$/i;\nexport function isValidName(name: string): boolean {\n  return name.match(NAME_REGEXP) != null;\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAAwBA,SAAS,EAAEC,IAAI,QAAQ,oBAAoB;AAEnE,SAASC,qBAAqB,QAAQ,SAAS;AAE/C;;;AAGA,WAAYC,cAOX;AAPD,WAAYA,cAAc;EACxBA,cAAA,uBAAmB;EACnBA,cAAA,2BAAuB;EACvBA,cAAA,uCAAmC;EACnCA,cAAA,6CAAyC;EACzCA,cAAA,yCAAqC;EACrCA,cAAA,6DAAyD;AAC3D,CAAC,EAPWA,cAAc,KAAdA,cAAc;AAoC1B,OAAM,SAAUC,0BAA0BA,CACxCC,IAAY,EACZC,IAAoB,EACpBC,OAAuB;;EAEvB,IAAI,CAACC,WAAW,CAACH,IAAI,CAAC,EAAE;IACtBJ,IAAI,CAACQ,IAAI,CACP,4BAAyBJ,IAAI,+FAA2F,CACzH;;EAEH,OAAO;IACLA,IAAI,EAAAA,IAAA;IACJC,IAAI,EAAAA,IAAA;IACJI,WAAW,EAAE,CAAAC,EAAA,GAAAJ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEG,WAAW,cAAAC,EAAA,cAAAA,EAAA,GAAI,EAAE;IACvCC,IAAI,EAAE,CAAAC,EAAA,GAAAN,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEK,IAAI,cAAAC,EAAA,cAAAA,EAAA,GAAI,EAAE;IACzBC,SAAS,EAAE,CAAAC,EAAA,GAAAR,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEO,SAAS,cAAAC,EAAA,cAAAA,EAAA,GAAIf,SAAS,CAACgB,MAAM;IACjDC,MAAM,EAAE,CAAAC,EAAA,GAAAX,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEU,MAAM,cAAAC,EAAA,cAAAA,EAAA,GAAI;GAC5B;AACH;AAEA,OAAM,SAAUC,kCAAkCA,CAChDC,IAAU,EACVC,UAAgC;;EAEhC,OAAO;IACLhB,IAAI,EAAE,CAAAM,EAAA,GAAAS,IAAI,CAACf,IAAI,cAAAM,EAAA,cAAAA,EAAA,GAAIU,UAAU,CAAChB,IAAI;IAClCK,WAAW,EAAE,CAAAG,EAAA,GAAAO,IAAI,CAACV,WAAW,cAAAG,EAAA,cAAAA,EAAA,GAAIQ,UAAU,CAACX,WAAW;IACvDJ,IAAI,EAAEe,UAAU,CAACf,IAAI;IACrBM,IAAI,EAAES,UAAU,CAACT,IAAI;IACrBE,SAAS,EAAEO,UAAU,CAACP,SAAS;IAC/BG,MAAM,EAAEI,UAAU,CAACJ;GACpB;AACH;AAEA,OAAM,SAAUK,0BAA0BA,CACxCC,UAAgC,EAChCC,eAAqC;EAErC;EACA,OACEtB,qBAAqB,CAACqB,UAAU,CAAClB,IAAI,EAAEmB,eAAe,CAACnB,IAAI,CAAC,IAC5DkB,UAAU,CAACX,IAAI,KAAKY,eAAe,CAACZ,IAAI,IACxCW,UAAU,CAACjB,IAAI,KAAKkB,eAAe,CAAClB,IAAI,IACxCiB,UAAU,CAACT,SAAS,KAAKU,eAAe,CAACV,SAAS;AAEtD;AAEA;AACA;AACA,IAAMW,WAAW,GAAG,8BAA8B;AAClD,OAAM,SAAUjB,WAAWA,CAACH,IAAY;EACtC,OAAOA,IAAI,CAACqB,KAAK,CAACD,WAAW,CAAC,IAAI,IAAI;AACxC"},"metadata":{},"sourceType":"module","externalDependencies":[]}