{"ast":null,"code":"import { TransportItemType } from '../../transports';\nimport { deepEqual, getCurrentTimestamp, isNull } from '../../utils';\nimport { defaultExceptionType } from './const';\nlet stacktraceParser;\nexport function initializeExceptionsAPI(_unpatchedConsole, internalLogger, config, metas, transports, tracesApi) {\n  var _a;\n  internalLogger.debug('Initializing exceptions API');\n  let lastPayload = null;\n  stacktraceParser = (_a = config.parseStacktrace) !== null && _a !== void 0 ? _a : stacktraceParser;\n  const changeStacktraceParser = newStacktraceParser => {\n    internalLogger.debug('Changing stacktrace parser');\n    stacktraceParser = newStacktraceParser !== null && newStacktraceParser !== void 0 ? newStacktraceParser : stacktraceParser;\n  };\n  const getStacktraceParser = () => stacktraceParser;\n  const pushError = (error, {\n    skipDedupe,\n    stackFrames,\n    type,\n    context\n  } = {}) => {\n    type = type || error.name || defaultExceptionType;\n    const item = {\n      meta: metas.value,\n      payload: {\n        type,\n        value: error.message,\n        timestamp: getCurrentTimestamp(),\n        trace: tracesApi.getTraceContext(),\n        context: context !== null && context !== void 0 ? context : {}\n      },\n      type: TransportItemType.EXCEPTION\n    };\n    stackFrames = stackFrames !== null && stackFrames !== void 0 ? stackFrames : error.stack ? stacktraceParser === null || stacktraceParser === void 0 ? void 0 : stacktraceParser(error).frames : undefined;\n    if (stackFrames === null || stackFrames === void 0 ? void 0 : stackFrames.length) {\n      item.payload.stacktrace = {\n        frames: stackFrames\n      };\n    }\n    const testingPayload = {\n      type: item.payload.type,\n      value: item.payload.value,\n      stackTrace: item.payload.stacktrace,\n      context: item.payload.context\n    };\n    if (!skipDedupe && config.dedupe && !isNull(lastPayload) && deepEqual(testingPayload, lastPayload)) {\n      internalLogger.debug('Skipping error push because it is the same as the last one\\n', item.payload);\n      return;\n    }\n    lastPayload = testingPayload;\n    internalLogger.debug('Pushing exception\\n', item);\n    transports.execute(item);\n  };\n  changeStacktraceParser(config.parseStacktrace);\n  return {\n    changeStacktraceParser,\n    getStacktraceParser,\n    pushError\n  };\n}","map":{"version":3,"names":["TransportItemType","deepEqual","getCurrentTimestamp","isNull","defaultExceptionType","stacktraceParser","initializeExceptionsAPI","_unpatchedConsole","internalLogger","config","metas","transports","tracesApi","debug","lastPayload","_a","parseStacktrace","changeStacktraceParser","newStacktraceParser","getStacktraceParser","pushError","error","skipDedupe","stackFrames","type","context","name","item","meta","value","payload","message","timestamp","trace","getTraceContext","EXCEPTION","stack","frames","undefined","length","stacktrace","testingPayload","stackTrace","dedupe","execute"],"sources":["/home/egor/node_modules/@grafana/faro-core/src/api/exceptions/initialize.ts"],"sourcesContent":["import type { Config } from '../../config';\nimport type { InternalLogger } from '../../internalLogger';\nimport type { Metas } from '../../metas';\nimport { TransportItemType } from '../../transports';\nimport type { TransportItem, Transports } from '../../transports';\nimport type { UnpatchedConsole } from '../../unpatchedConsole';\nimport { deepEqual, getCurrentTimestamp, isNull } from '../../utils';\nimport type { TracesAPI } from '../traces';\n\nimport { defaultExceptionType } from './const';\nimport type { ExceptionEvent, ExceptionsAPI, StacktraceParser } from './types';\n\nlet stacktraceParser: StacktraceParser | undefined;\n\nexport function initializeExceptionsAPI(\n  _unpatchedConsole: UnpatchedConsole,\n  internalLogger: InternalLogger,\n  config: Config,\n  metas: Metas,\n  transports: Transports,\n  tracesApi: TracesAPI\n): ExceptionsAPI {\n  internalLogger.debug('Initializing exceptions API');\n\n  let lastPayload: Pick<ExceptionEvent, 'type' | 'value' | 'stacktrace' | 'context'> | null = null;\n\n  stacktraceParser = config.parseStacktrace ?? stacktraceParser;\n\n  const changeStacktraceParser: ExceptionsAPI['changeStacktraceParser'] = (newStacktraceParser) => {\n    internalLogger.debug('Changing stacktrace parser');\n\n    stacktraceParser = newStacktraceParser ?? stacktraceParser;\n  };\n\n  const getStacktraceParser: ExceptionsAPI['getStacktraceParser'] = () => stacktraceParser;\n\n  const pushError: ExceptionsAPI['pushError'] = (error, { skipDedupe, stackFrames, type, context } = {}) => {\n    type = type || error.name || defaultExceptionType;\n\n    const item: TransportItem<ExceptionEvent> = {\n      meta: metas.value,\n      payload: {\n        type,\n        value: error.message,\n        timestamp: getCurrentTimestamp(),\n        trace: tracesApi.getTraceContext(),\n        context: context ?? {},\n      },\n      type: TransportItemType.EXCEPTION,\n    };\n\n    stackFrames = stackFrames ?? (error.stack ? stacktraceParser?.(error).frames : undefined);\n\n    if (stackFrames?.length) {\n      item.payload.stacktrace = {\n        frames: stackFrames,\n      };\n    }\n\n    const testingPayload = {\n      type: item.payload.type,\n      value: item.payload.value,\n      stackTrace: item.payload.stacktrace,\n      context: item.payload.context,\n    };\n\n    if (!skipDedupe && config.dedupe && !isNull(lastPayload) && deepEqual(testingPayload, lastPayload)) {\n      internalLogger.debug('Skipping error push because it is the same as the last one\\n', item.payload);\n\n      return;\n    }\n\n    lastPayload = testingPayload;\n\n    internalLogger.debug('Pushing exception\\n', item);\n\n    transports.execute(item);\n  };\n\n  changeStacktraceParser(config.parseStacktrace);\n\n  return {\n    changeStacktraceParser,\n    getStacktraceParser,\n    pushError,\n  };\n}\n"],"mappings":"AAGA,SAASA,iBAAiB,QAAQ,kBAAkB;AAGpD,SAASC,SAAS,EAAEC,mBAAmB,EAAEC,MAAM,QAAQ,aAAa;AAGpE,SAASC,oBAAoB,QAAQ,SAAS;AAG9C,IAAIC,gBAA8C;AAElD,OAAM,SAAUC,uBAAuBA,CACrCC,iBAAmC,EACnCC,cAA8B,EAC9BC,MAAc,EACdC,KAAY,EACZC,UAAsB,EACtBC,SAAoB;;EAEpBJ,cAAc,CAACK,KAAK,CAAC,6BAA6B,CAAC;EAEnD,IAAIC,WAAW,GAA6E,IAAI;EAEhGT,gBAAgB,GAAG,CAAAU,EAAA,GAAAN,MAAM,CAACO,eAAe,cAAAD,EAAA,cAAAA,EAAA,GAAIV,gBAAgB;EAE7D,MAAMY,sBAAsB,GAA6CC,mBAAmB,IAAI;IAC9FV,cAAc,CAACK,KAAK,CAAC,4BAA4B,CAAC;IAElDR,gBAAgB,GAAGa,mBAAmB,aAAnBA,mBAAmB,cAAnBA,mBAAmB,GAAIb,gBAAgB;EAC5D,CAAC;EAED,MAAMc,mBAAmB,GAAyCA,CAAA,KAAMd,gBAAgB;EAExF,MAAMe,SAAS,GAA+BA,CAACC,KAAK,EAAE;IAAEC,UAAU;IAAEC,WAAW;IAAEC,IAAI;IAAEC;EAAO,CAAE,GAAG,EAAE,KAAI;IACvGD,IAAI,GAAGA,IAAI,IAAIH,KAAK,CAACK,IAAI,IAAItB,oBAAoB;IAEjD,MAAMuB,IAAI,GAAkC;MAC1CC,IAAI,EAAElB,KAAK,CAACmB,KAAK;MACjBC,OAAO,EAAE;QACPN,IAAI;QACJK,KAAK,EAAER,KAAK,CAACU,OAAO;QACpBC,SAAS,EAAE9B,mBAAmB,EAAE;QAChC+B,KAAK,EAAErB,SAAS,CAACsB,eAAe,EAAE;QAClCT,OAAO,EAAEA,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI;OACrB;MACDD,IAAI,EAAExB,iBAAiB,CAACmC;KACzB;IAEDZ,WAAW,GAAGA,WAAW,aAAXA,WAAW,cAAXA,WAAW,GAAKF,KAAK,CAACe,KAAK,GAAG/B,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAGgB,KAAK,EAAEgB,MAAM,GAAGC,SAAU;IAEzF,IAAIf,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEgB,MAAM,EAAE;MACvBZ,IAAI,CAACG,OAAO,CAACU,UAAU,GAAG;QACxBH,MAAM,EAAEd;OACT;;IAGH,MAAMkB,cAAc,GAAG;MACrBjB,IAAI,EAAEG,IAAI,CAACG,OAAO,CAACN,IAAI;MACvBK,KAAK,EAAEF,IAAI,CAACG,OAAO,CAACD,KAAK;MACzBa,UAAU,EAAEf,IAAI,CAACG,OAAO,CAACU,UAAU;MACnCf,OAAO,EAAEE,IAAI,CAACG,OAAO,CAACL;KACvB;IAED,IAAI,CAACH,UAAU,IAAIb,MAAM,CAACkC,MAAM,IAAI,CAACxC,MAAM,CAACW,WAAW,CAAC,IAAIb,SAAS,CAACwC,cAAc,EAAE3B,WAAW,CAAC,EAAE;MAClGN,cAAc,CAACK,KAAK,CAAC,8DAA8D,EAAEc,IAAI,CAACG,OAAO,CAAC;MAElG;;IAGFhB,WAAW,GAAG2B,cAAc;IAE5BjC,cAAc,CAACK,KAAK,CAAC,qBAAqB,EAAEc,IAAI,CAAC;IAEjDhB,UAAU,CAACiC,OAAO,CAACjB,IAAI,CAAC;EAC1B,CAAC;EAEDV,sBAAsB,CAACR,MAAM,CAACO,eAAe,CAAC;EAE9C,OAAO;IACLC,sBAAsB;IACtBE,mBAAmB;IACnBC;GACD;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}