{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { globalErrorHandler } from '@opentelemetry/core';\n/**\n * Implementation of the {@link SpanProcessor} that simply forwards all\n * received events to a list of {@link SpanProcessor}s.\n */\nvar MultiSpanProcessor = /** @class */function () {\n  function MultiSpanProcessor(_spanProcessors) {\n    this._spanProcessors = _spanProcessors;\n  }\n  MultiSpanProcessor.prototype.forceFlush = function () {\n    var e_1, _a;\n    var promises = [];\n    try {\n      for (var _b = __values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var spanProcessor = _c.value;\n        promises.push(spanProcessor.forceFlush());\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return new Promise(function (resolve) {\n      Promise.all(promises).then(function () {\n        resolve();\n      }).catch(function (error) {\n        globalErrorHandler(error || new Error('MultiSpanProcessor: forceFlush failed'));\n        resolve();\n      });\n    });\n  };\n  MultiSpanProcessor.prototype.onStart = function (span, context) {\n    var e_2, _a;\n    try {\n      for (var _b = __values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var spanProcessor = _c.value;\n        spanProcessor.onStart(span, context);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n  MultiSpanProcessor.prototype.onEnd = function (span) {\n    var e_3, _a;\n    try {\n      for (var _b = __values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var spanProcessor = _c.value;\n        spanProcessor.onEnd(span);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n  MultiSpanProcessor.prototype.shutdown = function () {\n    var e_4, _a;\n    var promises = [];\n    try {\n      for (var _b = __values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var spanProcessor = _c.value;\n        promises.push(spanProcessor.shutdown());\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n    return new Promise(function (resolve, reject) {\n      Promise.all(promises).then(function () {\n        resolve();\n      }, reject);\n    });\n  };\n  return MultiSpanProcessor;\n}();\nexport { MultiSpanProcessor };","map":{"version":3,"names":["globalErrorHandler","MultiSpanProcessor","_spanProcessors","prototype","forceFlush","promises","_b","__values","_c","next","done","spanProcessor","value","push","Promise","resolve","all","then","catch","error","Error","onStart","span","context","onEnd","shutdown","reject"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-trace-base/src/MultiSpanProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { Span } from './Span';\nimport { SpanProcessor } from './SpanProcessor';\n\n/**\n * Implementation of the {@link SpanProcessor} that simply forwards all\n * received events to a list of {@link SpanProcessor}s.\n */\nexport class MultiSpanProcessor implements SpanProcessor {\n  constructor(private readonly _spanProcessors: SpanProcessor[]) {}\n\n  forceFlush(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.forceFlush());\n    }\n    return new Promise(resolve => {\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(error => {\n          globalErrorHandler(\n            error || new Error('MultiSpanProcessor: forceFlush failed')\n          );\n          resolve();\n        });\n    });\n  }\n\n  onStart(span: Span, context: Context): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onStart(span, context);\n    }\n  }\n\n  onEnd(span: ReadableSpan): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onEnd(span);\n    }\n  }\n\n  shutdown(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.shutdown());\n    }\n    return new Promise((resolve, reject) => {\n      Promise.all(promises).then(() => {\n        resolve();\n      }, reject);\n    });\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA,SAASA,kBAAkB,QAAQ,qBAAqB;AAKxD;;;;AAIA,IAAAC,kBAAA;EACE,SAAAA,mBAA6BC,eAAgC;IAAhC,KAAAA,eAAe,GAAfA,eAAe;EAAoB;EAEhED,kBAAA,CAAAE,SAAA,CAAAC,UAAU,GAAV;;IACE,IAAMC,QAAQ,GAAoB,EAAE;;MAEpC,KAA4B,IAAAC,EAAA,GAAAC,QAAA,KAAI,CAACL,eAAe,GAAAM,EAAA,GAAAF,EAAA,CAAAG,IAAA,KAAAD,EAAA,CAAAE,IAAA,EAAAF,EAAA,GAAAF,EAAA,CAAAG,IAAA,IAAE;QAA7C,IAAME,aAAa,GAAAH,EAAA,CAAAI,KAAA;QACtBP,QAAQ,CAACQ,IAAI,CAACF,aAAa,CAACP,UAAU,EAAE,CAAC;;;;;;;;;;;;;IAE3C,OAAO,IAAIU,OAAO,CAAC,UAAAC,OAAO;MACxBD,OAAO,CAACE,GAAG,CAACX,QAAQ,CAAC,CAClBY,IAAI,CAAC;QACJF,OAAO,EAAE;MACX,CAAC,CAAC,CACDG,KAAK,CAAC,UAAAC,KAAK;QACVnB,kBAAkB,CAChBmB,KAAK,IAAI,IAAIC,KAAK,CAAC,uCAAuC,CAAC,CAC5D;QACDL,OAAO,EAAE;MACX,CAAC,CAAC;IACN,CAAC,CAAC;EACJ,CAAC;EAEDd,kBAAA,CAAAE,SAAA,CAAAkB,OAAO,GAAP,UAAQC,IAAU,EAAEC,OAAgB;;;MAClC,KAA4B,IAAAjB,EAAA,GAAAC,QAAA,KAAI,CAACL,eAAe,GAAAM,EAAA,GAAAF,EAAA,CAAAG,IAAA,KAAAD,EAAA,CAAAE,IAAA,EAAAF,EAAA,GAAAF,EAAA,CAAAG,IAAA,IAAE;QAA7C,IAAME,aAAa,GAAAH,EAAA,CAAAI,KAAA;QACtBD,aAAa,CAACU,OAAO,CAACC,IAAI,EAAEC,OAAO,CAAC;;;;;;;;;;;;;EAExC,CAAC;EAEDtB,kBAAA,CAAAE,SAAA,CAAAqB,KAAK,GAAL,UAAMF,IAAkB;;;MACtB,KAA4B,IAAAhB,EAAA,GAAAC,QAAA,KAAI,CAACL,eAAe,GAAAM,EAAA,GAAAF,EAAA,CAAAG,IAAA,KAAAD,EAAA,CAAAE,IAAA,EAAAF,EAAA,GAAAF,EAAA,CAAAG,IAAA,IAAE;QAA7C,IAAME,aAAa,GAAAH,EAAA,CAAAI,KAAA;QACtBD,aAAa,CAACa,KAAK,CAACF,IAAI,CAAC;;;;;;;;;;;;;EAE7B,CAAC;EAEDrB,kBAAA,CAAAE,SAAA,CAAAsB,QAAQ,GAAR;;IACE,IAAMpB,QAAQ,GAAoB,EAAE;;MAEpC,KAA4B,IAAAC,EAAA,GAAAC,QAAA,KAAI,CAACL,eAAe,GAAAM,EAAA,GAAAF,EAAA,CAAAG,IAAA,KAAAD,EAAA,CAAAE,IAAA,EAAAF,EAAA,GAAAF,EAAA,CAAAG,IAAA,IAAE;QAA7C,IAAME,aAAa,GAAAH,EAAA,CAAAI,KAAA;QACtBP,QAAQ,CAACQ,IAAI,CAACF,aAAa,CAACc,QAAQ,EAAE,CAAC;;;;;;;;;;;;;IAEzC,OAAO,IAAIX,OAAO,CAAC,UAACC,OAAO,EAAEW,MAAM;MACjCZ,OAAO,CAACE,GAAG,CAACX,QAAQ,CAAC,CAACY,IAAI,CAAC;QACzBF,OAAO,EAAE;MACX,CAAC,EAAEW,MAAM,CAAC;IACZ,CAAC,CAAC;EACJ,CAAC;EACH,OAAAzB,kBAAC;AAAD,CAAC,CA/CD"},"metadata":{},"sourceType":"module","externalDependencies":[]}