{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nimport { TraceFlags } from '@opentelemetry/api';\nimport { internal, ExportResultCode, globalErrorHandler, BindOnceFuture } from '@opentelemetry/core';\n/**\n * An implementation of the {@link SpanProcessor} that converts the {@link Span}\n * to {@link ReadableSpan} and passes it to the configured exporter.\n *\n * Only spans that are sampled are converted.\n */\nvar SimpleSpanProcessor = /** @class */function () {\n  function SimpleSpanProcessor(_exporter) {\n    this._exporter = _exporter;\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n    this._unresolvedExports = new Set();\n  }\n  SimpleSpanProcessor.prototype.forceFlush = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // await unresolved resources before resolving\n            return [4 /*yield*/, Promise.all(Array.from(this._unresolvedExports))];\n          case 1:\n            // await unresolved resources before resolving\n            _a.sent();\n            if (!this._exporter.forceFlush) return [3 /*break*/, 3];\n            return [4 /*yield*/, this._exporter.forceFlush()];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  SimpleSpanProcessor.prototype.onStart = function (_span, _parentContext) {};\n  SimpleSpanProcessor.prototype.onEnd = function (span) {\n    var _this = this;\n    var _a, _b;\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n    var doExport = function () {\n      return internal._export(_this._exporter, [span]).then(function (result) {\n        var _a;\n        if (result.code !== ExportResultCode.SUCCESS) {\n          globalErrorHandler((_a = result.error) !== null && _a !== void 0 ? _a : new Error(\"SimpleSpanProcessor: span export failed (status \" + result + \")\"));\n        }\n      }).catch(function (error) {\n        globalErrorHandler(error);\n      });\n    };\n    // Avoid scheduling a promise to make the behavior more predictable and easier to test\n    if (span.resource.asyncAttributesPending) {\n      var exportPromise_1 = (_b = (_a = span.resource).waitForAsyncAttributes) === null || _b === void 0 ? void 0 : _b.call(_a).then(function () {\n        if (exportPromise_1 != null) {\n          _this._unresolvedExports.delete(exportPromise_1);\n        }\n        return doExport();\n      }, function (err) {\n        return globalErrorHandler(err);\n      });\n      // store the unresolved exports\n      if (exportPromise_1 != null) {\n        this._unresolvedExports.add(exportPromise_1);\n      }\n    } else {\n      void doExport();\n    }\n  };\n  SimpleSpanProcessor.prototype.shutdown = function () {\n    return this._shutdownOnce.call();\n  };\n  SimpleSpanProcessor.prototype._shutdown = function () {\n    return this._exporter.shutdown();\n  };\n  return SimpleSpanProcessor;\n}();\nexport { SimpleSpanProcessor };","map":{"version":3,"names":["TraceFlags","internal","ExportResultCode","globalErrorHandler","BindOnceFuture","SimpleSpanProcessor","_exporter","_shutdownOnce","_shutdown","_unresolvedExports","Set","prototype","forceFlush","Promise","all","Array","from","_a","sent","onStart","_span","_parentContext","onEnd","span","_this","isCalled","spanContext","traceFlags","SAMPLED","doExport","_export","then","result","code","SUCCESS","error","Error","catch","resource","asyncAttributesPending","exportPromise_1","_b","waitForAsyncAttributes","call","delete","err","add","shutdown"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-trace-base/src/export/SimpleSpanProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, TraceFlags } from '@opentelemetry/api';\nimport {\n  internal,\n  ExportResultCode,\n  globalErrorHandler,\n  BindOnceFuture,\n  ExportResult,\n} from '@opentelemetry/core';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\nimport { ReadableSpan } from './ReadableSpan';\nimport { SpanExporter } from './SpanExporter';\nimport { Resource } from '@opentelemetry/resources';\n\n/**\n * An implementation of the {@link SpanProcessor} that converts the {@link Span}\n * to {@link ReadableSpan} and passes it to the configured exporter.\n *\n * Only spans that are sampled are converted.\n */\nexport class SimpleSpanProcessor implements SpanProcessor {\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _unresolvedExports: Set<Promise<void>>;\n\n  constructor(private readonly _exporter: SpanExporter) {\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n    this._unresolvedExports = new Set<Promise<void>>();\n  }\n\n  async forceFlush(): Promise<void> {\n    // await unresolved resources before resolving\n    await Promise.all(Array.from(this._unresolvedExports));\n    if (this._exporter.forceFlush) {\n      await this._exporter.forceFlush();\n    }\n  }\n\n  onStart(_span: Span, _parentContext: Context): void {}\n\n  onEnd(span: ReadableSpan): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    const doExport = () =>\n      internal\n        ._export(this._exporter, [span])\n        .then((result: ExportResult) => {\n          if (result.code !== ExportResultCode.SUCCESS) {\n            globalErrorHandler(\n              result.error ??\n                new Error(\n                  `SimpleSpanProcessor: span export failed (status ${result})`\n                )\n            );\n          }\n        })\n        .catch(error => {\n          globalErrorHandler(error);\n        });\n\n    // Avoid scheduling a promise to make the behavior more predictable and easier to test\n    if (span.resource.asyncAttributesPending) {\n      const exportPromise = (span.resource as Resource)\n        .waitForAsyncAttributes?.()\n        .then(\n          () => {\n            if (exportPromise != null) {\n              this._unresolvedExports.delete(exportPromise);\n            }\n            return doExport();\n          },\n          err => globalErrorHandler(err)\n        );\n\n      // store the unresolved exports\n      if (exportPromise != null) {\n        this._unresolvedExports.add(exportPromise);\n      }\n    } else {\n      void doExport();\n    }\n  }\n\n  shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown(): Promise<void> {\n    return this._exporter.shutdown();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}