{"ast":null,"code":"import { ValueType } from '@opentelemetry/api';\nimport { AggregationTemporality, DataPointType } from '@opentelemetry/sdk-metrics';\nimport { toAttributes } from '../common/internal';\nimport { getOtlpEncoder } from '../common';\nexport function toResourceMetrics(resourceMetrics, options) {\n  var encoder = getOtlpEncoder(options);\n  return {\n    resource: {\n      attributes: toAttributes(resourceMetrics.resource.attributes),\n      droppedAttributesCount: 0\n    },\n    schemaUrl: undefined,\n    scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics, encoder)\n  };\n}\nexport function toScopeMetrics(scopeMetrics, encoder) {\n  return Array.from(scopeMetrics.map(function (metrics) {\n    return {\n      scope: {\n        name: metrics.scope.name,\n        version: metrics.scope.version\n      },\n      metrics: metrics.metrics.map(function (metricData) {\n        return toMetric(metricData, encoder);\n      }),\n      schemaUrl: metrics.scope.schemaUrl\n    };\n  }));\n}\nexport function toMetric(metricData, encoder) {\n  var out = {\n    name: metricData.descriptor.name,\n    description: metricData.descriptor.description,\n    unit: metricData.descriptor.unit\n  };\n  var aggregationTemporality = toAggregationTemporality(metricData.aggregationTemporality);\n  switch (metricData.dataPointType) {\n    case DataPointType.SUM:\n      out.sum = {\n        aggregationTemporality: aggregationTemporality,\n        isMonotonic: metricData.isMonotonic,\n        dataPoints: toSingularDataPoints(metricData, encoder)\n      };\n      break;\n    case DataPointType.GAUGE:\n      out.gauge = {\n        dataPoints: toSingularDataPoints(metricData, encoder)\n      };\n      break;\n    case DataPointType.HISTOGRAM:\n      out.histogram = {\n        aggregationTemporality: aggregationTemporality,\n        dataPoints: toHistogramDataPoints(metricData, encoder)\n      };\n      break;\n    case DataPointType.EXPONENTIAL_HISTOGRAM:\n      out.exponentialHistogram = {\n        aggregationTemporality: aggregationTemporality,\n        dataPoints: toExponentialHistogramDataPoints(metricData, encoder)\n      };\n      break;\n  }\n  return out;\n}\nfunction toSingularDataPoint(dataPoint, valueType, encoder) {\n  var out = {\n    attributes: toAttributes(dataPoint.attributes),\n    startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n    timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)\n  };\n  switch (valueType) {\n    case ValueType.INT:\n      out.asInt = dataPoint.value;\n      break;\n    case ValueType.DOUBLE:\n      out.asDouble = dataPoint.value;\n      break;\n  }\n  return out;\n}\nfunction toSingularDataPoints(metricData, encoder) {\n  return metricData.dataPoints.map(function (dataPoint) {\n    return toSingularDataPoint(dataPoint, metricData.descriptor.valueType, encoder);\n  });\n}\nfunction toHistogramDataPoints(metricData, encoder) {\n  return metricData.dataPoints.map(function (dataPoint) {\n    var histogram = dataPoint.value;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      bucketCounts: histogram.buckets.counts,\n      explicitBounds: histogram.buckets.boundaries,\n      count: histogram.count,\n      sum: histogram.sum,\n      min: histogram.min,\n      max: histogram.max,\n      startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n      timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)\n    };\n  });\n}\nfunction toExponentialHistogramDataPoints(metricData, encoder) {\n  return metricData.dataPoints.map(function (dataPoint) {\n    var histogram = dataPoint.value;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      count: histogram.count,\n      min: histogram.min,\n      max: histogram.max,\n      sum: histogram.sum,\n      positive: {\n        offset: histogram.positive.offset,\n        bucketCounts: histogram.positive.bucketCounts\n      },\n      negative: {\n        offset: histogram.negative.offset,\n        bucketCounts: histogram.negative.bucketCounts\n      },\n      scale: histogram.scale,\n      zeroCount: histogram.zeroCount,\n      startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n      timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)\n    };\n  });\n}\nfunction toAggregationTemporality(temporality) {\n  switch (temporality) {\n    case AggregationTemporality.DELTA:\n      return 1 /* AGGREGATION_TEMPORALITY_DELTA */;\n    case AggregationTemporality.CUMULATIVE:\n      return 2 /* AGGREGATION_TEMPORALITY_CUMULATIVE */;\n  }\n}","map":{"version":3,"names":["ValueType","AggregationTemporality","DataPointType","toAttributes","getOtlpEncoder","toResourceMetrics","resourceMetrics","options","encoder","resource","attributes","droppedAttributesCount","schemaUrl","undefined","scopeMetrics","toScopeMetrics","Array","from","map","metrics","scope","name","version","metricData","toMetric","out","descriptor","description","unit","aggregationTemporality","toAggregationTemporality","dataPointType","SUM","sum","isMonotonic","dataPoints","toSingularDataPoints","GAUGE","gauge","HISTOGRAM","histogram","toHistogramDataPoints","EXPONENTIAL_HISTOGRAM","exponentialHistogram","toExponentialHistogramDataPoints","toSingularDataPoint","dataPoint","valueType","startTimeUnixNano","encodeHrTime","startTime","timeUnixNano","endTime","INT","asInt","value","DOUBLE","asDouble","bucketCounts","buckets","counts","explicitBounds","boundaries","count","min","max","positive","offset","negative","scale","zeroCount","temporality","DELTA","CUMULATIVE"],"sources":["/home/egor/node_modules/@opentelemetry/otlp-transformer/src/metrics/internal.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { OtlpEncodingOptions } from '../common/types';\nimport { ValueType } from '@opentelemetry/api';\nimport {\n  AggregationTemporality,\n  DataPoint,\n  DataPointType,\n  ExponentialHistogram,\n  Histogram,\n  MetricData,\n  ResourceMetrics,\n  ScopeMetrics,\n} from '@opentelemetry/sdk-metrics';\nimport { toAttributes } from '../common/internal';\nimport {\n  EAggregationTemporality,\n  IExponentialHistogramDataPoint,\n  IHistogramDataPoint,\n  IMetric,\n  INumberDataPoint,\n  IResourceMetrics,\n  IScopeMetrics,\n} from './types';\nimport { Encoder, getOtlpEncoder } from '../common';\n\nexport function toResourceMetrics(\n  resourceMetrics: ResourceMetrics,\n  options?: OtlpEncodingOptions\n): IResourceMetrics {\n  const encoder = getOtlpEncoder(options);\n  return {\n    resource: {\n      attributes: toAttributes(resourceMetrics.resource.attributes),\n      droppedAttributesCount: 0,\n    },\n    schemaUrl: undefined,\n    scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics, encoder),\n  };\n}\n\nexport function toScopeMetrics(\n  scopeMetrics: ScopeMetrics[],\n  encoder: Encoder\n): IScopeMetrics[] {\n  return Array.from(\n    scopeMetrics.map(metrics => ({\n      scope: {\n        name: metrics.scope.name,\n        version: metrics.scope.version,\n      },\n      metrics: metrics.metrics.map(metricData => toMetric(metricData, encoder)),\n      schemaUrl: metrics.scope.schemaUrl,\n    }))\n  );\n}\n\nexport function toMetric(metricData: MetricData, encoder: Encoder): IMetric {\n  const out: IMetric = {\n    name: metricData.descriptor.name,\n    description: metricData.descriptor.description,\n    unit: metricData.descriptor.unit,\n  };\n\n  const aggregationTemporality = toAggregationTemporality(\n    metricData.aggregationTemporality\n  );\n\n  switch (metricData.dataPointType) {\n    case DataPointType.SUM:\n      out.sum = {\n        aggregationTemporality,\n        isMonotonic: metricData.isMonotonic,\n        dataPoints: toSingularDataPoints(metricData, encoder),\n      };\n      break;\n    case DataPointType.GAUGE:\n      out.gauge = {\n        dataPoints: toSingularDataPoints(metricData, encoder),\n      };\n      break;\n    case DataPointType.HISTOGRAM:\n      out.histogram = {\n        aggregationTemporality,\n        dataPoints: toHistogramDataPoints(metricData, encoder),\n      };\n      break;\n    case DataPointType.EXPONENTIAL_HISTOGRAM:\n      out.exponentialHistogram = {\n        aggregationTemporality,\n        dataPoints: toExponentialHistogramDataPoints(metricData, encoder),\n      };\n      break;\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoint(\n  dataPoint:\n    | DataPoint<number>\n    | DataPoint<Histogram>\n    | DataPoint<ExponentialHistogram>,\n  valueType: ValueType,\n  encoder: Encoder\n) {\n  const out: INumberDataPoint = {\n    attributes: toAttributes(dataPoint.attributes),\n    startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n    timeUnixNano: encoder.encodeHrTime(dataPoint.endTime),\n  };\n\n  switch (valueType) {\n    case ValueType.INT:\n      out.asInt = dataPoint.value as number;\n      break;\n    case ValueType.DOUBLE:\n      out.asDouble = dataPoint.value as number;\n      break;\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoints(\n  metricData: MetricData,\n  encoder: Encoder\n): INumberDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    return toSingularDataPoint(\n      dataPoint,\n      metricData.descriptor.valueType,\n      encoder\n    );\n  });\n}\n\nfunction toHistogramDataPoints(\n  metricData: MetricData,\n  encoder: Encoder\n): IHistogramDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    const histogram = dataPoint.value as Histogram;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      bucketCounts: histogram.buckets.counts,\n      explicitBounds: histogram.buckets.boundaries,\n      count: histogram.count,\n      sum: histogram.sum,\n      min: histogram.min,\n      max: histogram.max,\n      startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n      timeUnixNano: encoder.encodeHrTime(dataPoint.endTime),\n    };\n  });\n}\n\nfunction toExponentialHistogramDataPoints(\n  metricData: MetricData,\n  encoder: Encoder\n): IExponentialHistogramDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    const histogram = dataPoint.value as ExponentialHistogram;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      count: histogram.count,\n      min: histogram.min,\n      max: histogram.max,\n      sum: histogram.sum,\n      positive: {\n        offset: histogram.positive.offset,\n        bucketCounts: histogram.positive.bucketCounts,\n      },\n      negative: {\n        offset: histogram.negative.offset,\n        bucketCounts: histogram.negative.bucketCounts,\n      },\n      scale: histogram.scale,\n      zeroCount: histogram.zeroCount,\n      startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n      timeUnixNano: encoder.encodeHrTime(dataPoint.endTime),\n    };\n  });\n}\n\nfunction toAggregationTemporality(\n  temporality: AggregationTemporality\n): EAggregationTemporality {\n  switch (temporality) {\n    case AggregationTemporality.DELTA:\n      return EAggregationTemporality.AGGREGATION_TEMPORALITY_DELTA;\n    case AggregationTemporality.CUMULATIVE:\n      return EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}