{"ast":null,"code":"import { TransportItemType, transportItemTypeToBodyKey } from './const';\nexport function mergeResourceSpans(traces, resourceSpans) {\n  var _a, _b;\n  if (resourceSpans === undefined) {\n    return traces;\n  }\n  if (traces === undefined) {\n    return {\n      resourceSpans\n    };\n  }\n  const currentResource = (_a = traces.resourceSpans) === null || _a === void 0 ? void 0 : _a[0];\n  if (currentResource === undefined) {\n    return traces;\n  }\n  const currentSpans = (currentResource === null || currentResource === void 0 ? void 0 : currentResource.scopeSpans) || [];\n  const newSpans = ((_b = resourceSpans === null || resourceSpans === void 0 ? void 0 : resourceSpans[0]) === null || _b === void 0 ? void 0 : _b.scopeSpans) || [];\n  return Object.assign(Object.assign({}, traces), {\n    resourceSpans: [Object.assign(Object.assign({}, currentResource), {\n      scopeSpans: [...currentSpans, ...newSpans]\n    })]\n  });\n}\nexport function getTransportBody(item) {\n  let body = {\n    meta: {}\n  };\n  if (item[0] !== undefined) {\n    body.meta = item[0].meta;\n  }\n  item.forEach(currentItem => {\n    switch (currentItem.type) {\n      case TransportItemType.LOG:\n      case TransportItemType.EVENT:\n      case TransportItemType.EXCEPTION:\n      case TransportItemType.MEASUREMENT:\n        const bk = transportItemTypeToBodyKey[currentItem.type];\n        const signals = body[bk];\n        body = Object.assign(Object.assign({}, body), {\n          [bk]: signals === undefined ? [currentItem.payload] : [...signals, currentItem.payload]\n        });\n        break;\n      case TransportItemType.TRACE:\n        body = Object.assign(Object.assign({}, body), {\n          traces: mergeResourceSpans(body.traces, currentItem.payload.resourceSpans)\n        });\n        break;\n    }\n  });\n  return body;\n}","map":{"version":3,"names":["TransportItemType","transportItemTypeToBodyKey","mergeResourceSpans","traces","resourceSpans","undefined","currentResource","_a","currentSpans","scopeSpans","newSpans","_b","Object","assign","getTransportBody","item","body","meta","forEach","currentItem","type","LOG","EVENT","EXCEPTION","MEASUREMENT","bk","signals","payload","TRACE"],"sources":["/home/egor/node_modules/@grafana/faro-core/src/transports/utils.ts"],"sourcesContent":["import type { IResourceSpans } from '@opentelemetry/otlp-transformer';\n\nimport type { EventEvent, ExceptionEvent, LogEvent, MeasurementEvent, TraceEvent } from '..';\n\nimport { TransportItemType, transportItemTypeToBodyKey } from './const';\nimport type { TransportBody, TransportItem } from './types';\n\nexport function mergeResourceSpans(traces?: TraceEvent, resourceSpans?: IResourceSpans[]): TraceEvent | undefined {\n  if (resourceSpans === undefined) {\n    return traces;\n  }\n\n  if (traces === undefined) {\n    return {\n      resourceSpans,\n    };\n  }\n\n  const currentResource = traces.resourceSpans?.[0];\n  if (currentResource === undefined) {\n    return traces;\n  }\n\n  const currentSpans = currentResource?.scopeSpans || [];\n  const newSpans = resourceSpans?.[0]?.scopeSpans || [];\n\n  return {\n    ...traces,\n    resourceSpans: [\n      {\n        ...currentResource,\n        scopeSpans: [...currentSpans, ...newSpans],\n      },\n    ],\n  };\n}\n\nexport function getTransportBody(item: TransportItem[]): TransportBody {\n  let body: TransportBody = {\n    meta: {},\n  };\n\n  if (item[0] !== undefined) {\n    body.meta = item[0].meta;\n  }\n\n  item.forEach((currentItem: TransportItem) => {\n    switch (currentItem.type) {\n      case TransportItemType.LOG:\n      case TransportItemType.EVENT:\n      case TransportItemType.EXCEPTION:\n      case TransportItemType.MEASUREMENT:\n        const bk = transportItemTypeToBodyKey[currentItem.type];\n        const signals = body[bk] as LogEvent[] | EventEvent[] | ExceptionEvent[] | MeasurementEvent[];\n\n        body = {\n          ...body,\n          [bk]: signals === undefined ? [currentItem.payload] : [...signals, currentItem.payload],\n        };\n        break;\n      case TransportItemType.TRACE:\n        body = {\n          ...body,\n          traces: mergeResourceSpans(body.traces, (currentItem.payload as TraceEvent).resourceSpans),\n        };\n        break;\n    }\n  });\n\n  return body;\n}\n"],"mappings":"AAIA,SAASA,iBAAiB,EAAEC,0BAA0B,QAAQ,SAAS;AAGvE,OAAM,SAAUC,kBAAkBA,CAACC,MAAmB,EAAEC,aAAgC;;EACtF,IAAIA,aAAa,KAAKC,SAAS,EAAE;IAC/B,OAAOF,MAAM;;EAGf,IAAIA,MAAM,KAAKE,SAAS,EAAE;IACxB,OAAO;MACLD;KACD;;EAGH,MAAME,eAAe,GAAG,CAAAC,EAAA,GAAAJ,MAAM,CAACC,aAAa,cAAAG,EAAA,uBAAAA,EAAA,CAAG,CAAC,CAAC;EACjD,IAAID,eAAe,KAAKD,SAAS,EAAE;IACjC,OAAOF,MAAM;;EAGf,MAAMK,YAAY,GAAG,CAAAF,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEG,UAAU,KAAI,EAAE;EACtD,MAAMC,QAAQ,GAAG,EAAAC,EAAA,GAAAP,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAG,CAAC,CAAC,cAAAO,EAAA,uBAAAA,EAAA,CAAEF,UAAU,KAAI,EAAE;EAErD,OAAAG,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKV,MAAM;IACTC,aAAa,EAAE,C,gCAERE,eAAe;MAClBG,UAAU,EAAE,CAAC,GAAGD,YAAY,EAAE,GAAGE,QAAQ;IAAC;EAE7C;AAEL;AAEA,OAAM,SAAUI,gBAAgBA,CAACC,IAAqB;EACpD,IAAIC,IAAI,GAAkB;IACxBC,IAAI,EAAE;GACP;EAED,IAAIF,IAAI,CAAC,CAAC,CAAC,KAAKV,SAAS,EAAE;IACzBW,IAAI,CAACC,IAAI,GAAGF,IAAI,CAAC,CAAC,CAAC,CAACE,IAAI;;EAG1BF,IAAI,CAACG,OAAO,CAAEC,WAA0B,IAAI;IAC1C,QAAQA,WAAW,CAACC,IAAI;MACtB,KAAKpB,iBAAiB,CAACqB,GAAG;MAC1B,KAAKrB,iBAAiB,CAACsB,KAAK;MAC5B,KAAKtB,iBAAiB,CAACuB,SAAS;MAChC,KAAKvB,iBAAiB,CAACwB,WAAW;QAChC,MAAMC,EAAE,GAAGxB,0BAA0B,CAACkB,WAAW,CAACC,IAAI,CAAC;QACvD,MAAMM,OAAO,GAAGV,IAAI,CAACS,EAAE,CAAsE;QAE7FT,IAAI,GAAAJ,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACCG,IAAI;UACP,CAACS,EAAE,GAAGC,OAAO,KAAKrB,SAAS,GAAG,CAACc,WAAW,CAACQ,OAAO,CAAC,GAAG,CAAC,GAAGD,OAAO,EAAEP,WAAW,CAACQ,OAAO;QAAC,EACxF;QACD;MACF,KAAK3B,iBAAiB,CAAC4B,KAAK;QAC1BZ,IAAI,GAAAJ,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACCG,IAAI;UACPb,MAAM,EAAED,kBAAkB,CAACc,IAAI,CAACb,MAAM,EAAGgB,WAAW,CAACQ,OAAsB,CAACvB,aAAa;QAAC,EAC3F;QACD;;EAEN,CAAC,CAAC;EAEF,OAAOY,IAAI;AACb"},"metadata":{},"sourceType":"module","externalDependencies":[]}