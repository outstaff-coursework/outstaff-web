{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { context, diag, TraceFlags } from '@opentelemetry/api';\nimport { BindOnceFuture, ExportResultCode, getEnv, globalErrorHandler, suppressTracing, unrefTimer } from '@opentelemetry/core';\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\nvar BatchSpanProcessorBase = /** @class */function () {\n  function BatchSpanProcessorBase(_exporter, config) {\n    this._exporter = _exporter;\n    this._isExporting = false;\n    this._finishedSpans = [];\n    this._droppedSpansCount = 0;\n    var env = getEnv();\n    this._maxExportBatchSize = typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === 'number' ? config.maxExportBatchSize : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;\n    this._maxQueueSize = typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === 'number' ? config.maxQueueSize : env.OTEL_BSP_MAX_QUEUE_SIZE;\n    this._scheduledDelayMillis = typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === 'number' ? config.scheduledDelayMillis : env.OTEL_BSP_SCHEDULE_DELAY;\n    this._exportTimeoutMillis = typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === 'number' ? config.exportTimeoutMillis : env.OTEL_BSP_EXPORT_TIMEOUT;\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn('BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize');\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n  BatchSpanProcessorBase.prototype.forceFlush = function () {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  };\n  // does nothing.\n  BatchSpanProcessorBase.prototype.onStart = function (_span, _parentContext) {};\n  BatchSpanProcessorBase.prototype.onEnd = function (span) {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n    this._addToBuffer(span);\n  };\n  BatchSpanProcessorBase.prototype.shutdown = function () {\n    return this._shutdownOnce.call();\n  };\n  BatchSpanProcessorBase.prototype._shutdown = function () {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      return _this.onShutdown();\n    }).then(function () {\n      return _this._flushAll();\n    }).then(function () {\n      return _this._exporter.shutdown();\n    });\n  };\n  /** Add a span in the buffer. */\n  BatchSpanProcessorBase.prototype._addToBuffer = function (span) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      // limit reached, drop span\n      if (this._droppedSpansCount === 0) {\n        diag.debug('maxQueueSize reached, dropping spans');\n      }\n      this._droppedSpansCount++;\n      return;\n    }\n    if (this._droppedSpansCount > 0) {\n      // some spans were dropped, log once with count of spans dropped\n      diag.warn(\"Dropped \" + this._droppedSpansCount + \" spans because maxQueueSize reached\");\n      this._droppedSpansCount = 0;\n    }\n    this._finishedSpans.push(span);\n    this._maybeStartTimer();\n  };\n  /**\n   * Send all spans to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n  BatchSpanProcessorBase.prototype._flushAll = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      var promises = [];\n      // calculate number of batches\n      var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);\n      for (var i = 0, j = count; i < j; i++) {\n        promises.push(_this._flushOneBatch());\n      }\n      Promise.all(promises).then(function () {\n        resolve();\n      }).catch(reject);\n    });\n  };\n  BatchSpanProcessorBase.prototype._flushOneBatch = function () {\n    var _this = this;\n    this._clearTimer();\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise(function (resolve, reject) {\n      var timer = setTimeout(function () {\n        // don't wait anymore for export, this way the next batch can start\n        reject(new Error('Timeout'));\n      }, _this._exportTimeoutMillis);\n      // prevent downstream exporter calls from generating spans\n      context.with(suppressTracing(context.active()), function () {\n        // Reset the finished spans buffer here because the next invocations of the _flush method\n        // could pass the same finished spans to the exporter if the buffer is cleared\n        // outside the execution of this callback.\n        var spans = _this._finishedSpans.splice(0, _this._maxExportBatchSize);\n        var doExport = function () {\n          return _this._exporter.export(spans, function (result) {\n            var _a;\n            clearTimeout(timer);\n            if (result.code === ExportResultCode.SUCCESS) {\n              resolve();\n            } else {\n              reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error('BatchSpanProcessor: span export failed'));\n            }\n          });\n        };\n        var pendingResources = spans.map(function (span) {\n          return span.resource;\n        }).filter(function (resource) {\n          return resource.asyncAttributesPending;\n        });\n        // Avoid scheduling a promise to make the behavior more predictable and easier to test\n        if (pendingResources.length === 0) {\n          doExport();\n        } else {\n          Promise.all(pendingResources.map(function (resource) {\n            var _a;\n            return (_a = resource.waitForAsyncAttributes) === null || _a === void 0 ? void 0 : _a.call(resource);\n          })).then(doExport, function (err) {\n            globalErrorHandler(err);\n            reject(err);\n          });\n        }\n      });\n    });\n  };\n  BatchSpanProcessorBase.prototype._maybeStartTimer = function () {\n    var _this = this;\n    if (this._isExporting) return;\n    var flush = function () {\n      _this._isExporting = true;\n      _this._flushOneBatch().finally(function () {\n        _this._isExporting = false;\n        if (_this._finishedSpans.length > 0) {\n          _this._clearTimer();\n          _this._maybeStartTimer();\n        }\n      }).catch(function (e) {\n        _this._isExporting = false;\n        globalErrorHandler(e);\n      });\n    };\n    // we only wait if the queue doesn't have enough elements yet\n    if (this._finishedSpans.length >= this._maxExportBatchSize) {\n      return flush();\n    }\n    if (this._timer !== undefined) return;\n    this._timer = setTimeout(function () {\n      return flush();\n    }, this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  };\n  BatchSpanProcessorBase.prototype._clearTimer = function () {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  };\n  return BatchSpanProcessorBase;\n}();\nexport { BatchSpanProcessorBase };","map":{"version":3,"names":["context","diag","TraceFlags","BindOnceFuture","ExportResultCode","getEnv","globalErrorHandler","suppressTracing","unrefTimer","BatchSpanProcessorBase","_exporter","config","_isExporting","_finishedSpans","_droppedSpansCount","env","_maxExportBatchSize","maxExportBatchSize","OTEL_BSP_MAX_EXPORT_BATCH_SIZE","_maxQueueSize","maxQueueSize","OTEL_BSP_MAX_QUEUE_SIZE","_scheduledDelayMillis","scheduledDelayMillis","OTEL_BSP_SCHEDULE_DELAY","_exportTimeoutMillis","exportTimeoutMillis","OTEL_BSP_EXPORT_TIMEOUT","_shutdownOnce","_shutdown","warn","prototype","forceFlush","isCalled","promise","_flushAll","onStart","_span","_parentContext","onEnd","span","spanContext","traceFlags","SAMPLED","_addToBuffer","shutdown","call","_this","Promise","resolve","then","onShutdown","length","debug","push","_maybeStartTimer","reject","promises","count","Math","ceil","i","j","_flushOneBatch","all","catch","_clearTimer","timer","setTimeout","Error","with","active","spans","splice","doExport","export","result","clearTimeout","code","SUCCESS","_a","error","pendingResources","map","resource","filter","asyncAttributesPending","waitForAsyncAttributes","err","flush","finally","e","_timer","undefined"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-trace-base/src/export/BatchSpanProcessorBase.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { context, Context, diag, TraceFlags } from '@opentelemetry/api';\nimport {\n  BindOnceFuture,\n  ExportResultCode,\n  getEnv,\n  globalErrorHandler,\n  suppressTracing,\n  unrefTimer,\n} from '@opentelemetry/core';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\nimport { BufferConfig } from '../types';\nimport { ReadableSpan } from './ReadableSpan';\nimport { SpanExporter } from './SpanExporter';\n\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\nexport abstract class BatchSpanProcessorBase<T extends BufferConfig>\n  implements SpanProcessor\n{\n  private readonly _maxExportBatchSize: number;\n  private readonly _maxQueueSize: number;\n  private readonly _scheduledDelayMillis: number;\n  private readonly _exportTimeoutMillis: number;\n\n  private _isExporting = false;\n  private _finishedSpans: ReadableSpan[] = [];\n  private _timer: NodeJS.Timeout | undefined;\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _droppedSpansCount: number = 0;\n\n  constructor(\n    private readonly _exporter: SpanExporter,\n    config?: T\n  ) {\n    const env = getEnv();\n    this._maxExportBatchSize =\n      typeof config?.maxExportBatchSize === 'number'\n        ? config.maxExportBatchSize\n        : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;\n    this._maxQueueSize =\n      typeof config?.maxQueueSize === 'number'\n        ? config.maxQueueSize\n        : env.OTEL_BSP_MAX_QUEUE_SIZE;\n    this._scheduledDelayMillis =\n      typeof config?.scheduledDelayMillis === 'number'\n        ? config.scheduledDelayMillis\n        : env.OTEL_BSP_SCHEDULE_DELAY;\n    this._exportTimeoutMillis =\n      typeof config?.exportTimeoutMillis === 'number'\n        ? config.exportTimeoutMillis\n        : env.OTEL_BSP_EXPORT_TIMEOUT;\n\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn(\n        'BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize'\n      );\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n\n  forceFlush(): Promise<void> {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  }\n\n  // does nothing.\n  onStart(_span: Span, _parentContext: Context): void {}\n\n  onEnd(span: ReadableSpan): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    this._addToBuffer(span);\n  }\n\n  shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown() {\n    return Promise.resolve()\n      .then(() => {\n        return this.onShutdown();\n      })\n      .then(() => {\n        return this._flushAll();\n      })\n      .then(() => {\n        return this._exporter.shutdown();\n      });\n  }\n\n  /** Add a span in the buffer. */\n  private _addToBuffer(span: ReadableSpan) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      // limit reached, drop span\n\n      if (this._droppedSpansCount === 0) {\n        diag.debug('maxQueueSize reached, dropping spans');\n      }\n      this._droppedSpansCount++;\n\n      return;\n    }\n\n    if (this._droppedSpansCount > 0) {\n      // some spans were dropped, log once with count of spans dropped\n      diag.warn(\n        `Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`\n      );\n      this._droppedSpansCount = 0;\n    }\n\n    this._finishedSpans.push(span);\n    this._maybeStartTimer();\n  }\n\n  /**\n   * Send all spans to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n  private _flushAll(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const promises = [];\n      // calculate number of batches\n      const count = Math.ceil(\n        this._finishedSpans.length / this._maxExportBatchSize\n      );\n      for (let i = 0, j = count; i < j; i++) {\n        promises.push(this._flushOneBatch());\n      }\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n\n  private _flushOneBatch(): Promise<void> {\n    this._clearTimer();\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        // don't wait anymore for export, this way the next batch can start\n        reject(new Error('Timeout'));\n      }, this._exportTimeoutMillis);\n      // prevent downstream exporter calls from generating spans\n      context.with(suppressTracing(context.active()), () => {\n        // Reset the finished spans buffer here because the next invocations of the _flush method\n        // could pass the same finished spans to the exporter if the buffer is cleared\n        // outside the execution of this callback.\n        const spans = this._finishedSpans.splice(0, this._maxExportBatchSize);\n\n        const doExport = () =>\n          this._exporter.export(spans, result => {\n            clearTimeout(timer);\n            if (result.code === ExportResultCode.SUCCESS) {\n              resolve();\n            } else {\n              reject(\n                result.error ??\n                  new Error('BatchSpanProcessor: span export failed')\n              );\n            }\n          });\n        const pendingResources = spans\n          .map(span => span.resource)\n          .filter(resource => resource.asyncAttributesPending);\n\n        // Avoid scheduling a promise to make the behavior more predictable and easier to test\n        if (pendingResources.length === 0) {\n          doExport();\n        } else {\n          Promise.all(\n            pendingResources.map(\n              resource => resource.waitForAsyncAttributes?.()\n            )\n          ).then(doExport, err => {\n            globalErrorHandler(err);\n            reject(err);\n          });\n        }\n      });\n    });\n  }\n\n  private _maybeStartTimer() {\n    if (this._isExporting) return;\n    const flush = () => {\n      this._isExporting = true;\n      this._flushOneBatch()\n        .finally(() => {\n          this._isExporting = false;\n          if (this._finishedSpans.length > 0) {\n            this._clearTimer();\n            this._maybeStartTimer();\n          }\n        })\n        .catch(e => {\n          this._isExporting = false;\n          globalErrorHandler(e);\n        });\n    };\n    // we only wait if the queue doesn't have enough elements yet\n    if (this._finishedSpans.length >= this._maxExportBatchSize) {\n      return flush();\n    }\n    if (this._timer !== undefined) return;\n    this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  }\n\n  private _clearTimer() {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  }\n\n  protected abstract onShutdown(): void;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}