{"ast":null,"code":"export function initializeInstrumentations(unpatchedConsole, internalLogger, config, metas, transports, api) {\n  internalLogger.debug('Initializing instrumentations');\n  const instrumentations = [];\n  const add = (...newInstrumentations) => {\n    internalLogger.debug('Adding instrumentations');\n    newInstrumentations.forEach(newInstrumentation => {\n      internalLogger.debug(`Adding \"${newInstrumentation.name}\" instrumentation`);\n      const exists = instrumentations.some(existingInstrumentation => existingInstrumentation.name === newInstrumentation.name);\n      if (exists) {\n        internalLogger.warn(`Instrumentation ${newInstrumentation.name} is already added`);\n        return;\n      }\n      newInstrumentation.unpatchedConsole = unpatchedConsole;\n      newInstrumentation.internalLogger = internalLogger;\n      newInstrumentation.config = config;\n      newInstrumentation.metas = metas;\n      newInstrumentation.transports = transports;\n      newInstrumentation.api = api;\n      instrumentations.push(newInstrumentation);\n      newInstrumentation.initialize();\n    });\n  };\n  const remove = (...instrumentationsToRemove) => {\n    internalLogger.debug('Removing instrumentations');\n    instrumentationsToRemove.forEach(instrumentationToRemove => {\n      var _a, _b;\n      internalLogger.debug(`Removing \"${instrumentationToRemove.name}\" instrumentation`);\n      const existingInstrumentationIndex = instrumentations.reduce((acc, existingInstrumentation, existingTransportIndex) => {\n        if (acc === null && existingInstrumentation.name === instrumentationToRemove.name) {\n          return existingTransportIndex;\n        }\n        return null;\n      }, null);\n      if (!existingInstrumentationIndex) {\n        internalLogger.warn(`Instrumentation \"${instrumentationToRemove.name}\" is not added`);\n        return;\n      }\n      (_b = (_a = instrumentations[existingInstrumentationIndex]).destroy) === null || _b === void 0 ? void 0 : _b.call(_a);\n      instrumentations.splice(existingInstrumentationIndex, 1);\n    });\n  };\n  return {\n    add,\n    get instrumentations() {\n      return [...instrumentations];\n    },\n    remove\n  };\n}","map":{"version":3,"names":["initializeInstrumentations","unpatchedConsole","internalLogger","config","metas","transports","api","debug","instrumentations","add","newInstrumentations","forEach","newInstrumentation","name","exists","some","existingInstrumentation","warn","push","initialize","remove","instrumentationsToRemove","instrumentationToRemove","existingInstrumentationIndex","reduce","acc","existingTransportIndex","_b","_a","destroy","call","splice"],"sources":["/home/egor/node_modules/@grafana/faro-core/src/instrumentations/initialize.ts"],"sourcesContent":["import type { API } from '../api';\nimport type { Config } from '../config';\nimport type { InternalLogger } from '../internalLogger';\nimport type { Metas } from '../metas';\nimport type { Transports } from '../transports';\nimport type { UnpatchedConsole } from '../unpatchedConsole';\n\nimport type { Instrumentation, Instrumentations } from './types';\n\nexport function initializeInstrumentations(\n  unpatchedConsole: UnpatchedConsole,\n  internalLogger: InternalLogger,\n  config: Config,\n  metas: Metas,\n  transports: Transports,\n  api: API\n): Instrumentations {\n  internalLogger.debug('Initializing instrumentations');\n\n  const instrumentations: Instrumentation[] = [];\n\n  const add: Instrumentations['add'] = (...newInstrumentations) => {\n    internalLogger.debug('Adding instrumentations');\n\n    newInstrumentations.forEach((newInstrumentation) => {\n      internalLogger.debug(`Adding \"${newInstrumentation.name}\" instrumentation`);\n\n      const exists = instrumentations.some(\n        (existingInstrumentation) => existingInstrumentation.name === newInstrumentation.name\n      );\n\n      if (exists) {\n        internalLogger.warn(`Instrumentation ${newInstrumentation.name} is already added`);\n\n        return;\n      }\n\n      newInstrumentation.unpatchedConsole = unpatchedConsole;\n      newInstrumentation.internalLogger = internalLogger;\n      newInstrumentation.config = config;\n      newInstrumentation.metas = metas;\n      newInstrumentation.transports = transports;\n      newInstrumentation.api = api;\n\n      instrumentations.push(newInstrumentation);\n\n      newInstrumentation.initialize();\n    });\n  };\n\n  const remove: Instrumentations['remove'] = (...instrumentationsToRemove) => {\n    internalLogger.debug('Removing instrumentations');\n\n    instrumentationsToRemove.forEach((instrumentationToRemove) => {\n      internalLogger.debug(`Removing \"${instrumentationToRemove.name}\" instrumentation`);\n\n      const existingInstrumentationIndex = instrumentations.reduce<number | null>(\n        (acc, existingInstrumentation, existingTransportIndex) => {\n          if (acc === null && existingInstrumentation.name === instrumentationToRemove.name) {\n            return existingTransportIndex;\n          }\n\n          return null;\n        },\n        null\n      );\n\n      if (!existingInstrumentationIndex) {\n        internalLogger.warn(`Instrumentation \"${instrumentationToRemove.name}\" is not added`);\n\n        return;\n      }\n\n      instrumentations[existingInstrumentationIndex]!.destroy?.();\n\n      instrumentations.splice(existingInstrumentationIndex, 1);\n    });\n  };\n\n  return {\n    add,\n    get instrumentations() {\n      return [...instrumentations];\n    },\n    remove,\n  };\n}\n"],"mappings":"AASA,OAAM,SAAUA,0BAA0BA,CACxCC,gBAAkC,EAClCC,cAA8B,EAC9BC,MAAc,EACdC,KAAY,EACZC,UAAsB,EACtBC,GAAQ;EAERJ,cAAc,CAACK,KAAK,CAAC,+BAA+B,CAAC;EAErD,MAAMC,gBAAgB,GAAsB,EAAE;EAE9C,MAAMC,GAAG,GAA4BA,CAAC,GAAGC,mBAAmB,KAAI;IAC9DR,cAAc,CAACK,KAAK,CAAC,yBAAyB,CAAC;IAE/CG,mBAAmB,CAACC,OAAO,CAAEC,kBAAkB,IAAI;MACjDV,cAAc,CAACK,KAAK,CAAC,WAAWK,kBAAkB,CAACC,IAAI,mBAAmB,CAAC;MAE3E,MAAMC,MAAM,GAAGN,gBAAgB,CAACO,IAAI,CACjCC,uBAAuB,IAAKA,uBAAuB,CAACH,IAAI,KAAKD,kBAAkB,CAACC,IAAI,CACtF;MAED,IAAIC,MAAM,EAAE;QACVZ,cAAc,CAACe,IAAI,CAAC,mBAAmBL,kBAAkB,CAACC,IAAI,mBAAmB,CAAC;QAElF;;MAGFD,kBAAkB,CAACX,gBAAgB,GAAGA,gBAAgB;MACtDW,kBAAkB,CAACV,cAAc,GAAGA,cAAc;MAClDU,kBAAkB,CAACT,MAAM,GAAGA,MAAM;MAClCS,kBAAkB,CAACR,KAAK,GAAGA,KAAK;MAChCQ,kBAAkB,CAACP,UAAU,GAAGA,UAAU;MAC1CO,kBAAkB,CAACN,GAAG,GAAGA,GAAG;MAE5BE,gBAAgB,CAACU,IAAI,CAACN,kBAAkB,CAAC;MAEzCA,kBAAkB,CAACO,UAAU,EAAE;IACjC,CAAC,CAAC;EACJ,CAAC;EAED,MAAMC,MAAM,GAA+BA,CAAC,GAAGC,wBAAwB,KAAI;IACzEnB,cAAc,CAACK,KAAK,CAAC,2BAA2B,CAAC;IAEjDc,wBAAwB,CAACV,OAAO,CAAEW,uBAAuB,IAAI;;MAC3DpB,cAAc,CAACK,KAAK,CAAC,aAAae,uBAAuB,CAACT,IAAI,mBAAmB,CAAC;MAElF,MAAMU,4BAA4B,GAAGf,gBAAgB,CAACgB,MAAM,CAC1D,CAACC,GAAG,EAAET,uBAAuB,EAAEU,sBAAsB,KAAI;QACvD,IAAID,GAAG,KAAK,IAAI,IAAIT,uBAAuB,CAACH,IAAI,KAAKS,uBAAuB,CAACT,IAAI,EAAE;UACjF,OAAOa,sBAAsB;;QAG/B,OAAO,IAAI;MACb,CAAC,EACD,IAAI,CACL;MAED,IAAI,CAACH,4BAA4B,EAAE;QACjCrB,cAAc,CAACe,IAAI,CAAC,oBAAoBK,uBAAuB,CAACT,IAAI,gBAAgB,CAAC;QAErF;;MAGF,CAAAc,EAAA,IAAAC,EAAA,GAAApB,gBAAgB,CAACe,4BAA4B,CAAE,EAACM,OAAO,cAAAF,EAAA,uBAAAA,EAAA,CAAAG,IAAA,CAAAF,EAAA,CAAI;MAE3DpB,gBAAgB,CAACuB,MAAM,CAACR,4BAA4B,EAAE,CAAC,CAAC;IAC1D,CAAC,CAAC;EACJ,CAAC;EAED,OAAO;IACLd,GAAG;IACH,IAAID,gBAAgBA,CAAA;MAClB,OAAO,CAAC,GAAGA,gBAAgB,CAAC;IAC9B,CAAC;IACDY;GACD;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}