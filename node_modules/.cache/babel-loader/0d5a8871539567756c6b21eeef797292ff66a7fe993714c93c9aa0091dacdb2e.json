{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { createInstrumentDescriptorWithView } from '../InstrumentDescriptor';\nimport { Meter } from '../Meter';\nimport { isNotNullish } from '../utils';\nimport { AsyncMetricStorage } from './AsyncMetricStorage';\nimport { MetricStorageRegistry } from './MetricStorageRegistry';\nimport { MultiMetricStorage } from './MultiWritableMetricStorage';\nimport { ObservableRegistry } from './ObservableRegistry';\nimport { SyncMetricStorage } from './SyncMetricStorage';\nimport { AttributesProcessor } from '../view/AttributesProcessor';\n/**\n * An internal record for shared meter provider states.\n */\nvar MeterSharedState = /** @class */function () {\n  function MeterSharedState(_meterProviderSharedState, _instrumentationScope) {\n    this._meterProviderSharedState = _meterProviderSharedState;\n    this._instrumentationScope = _instrumentationScope;\n    this.metricStorageRegistry = new MetricStorageRegistry();\n    this.observableRegistry = new ObservableRegistry();\n    this.meter = new Meter(this);\n  }\n  MeterSharedState.prototype.registerMetricStorage = function (descriptor) {\n    var storages = this._registerMetricStorage(descriptor, SyncMetricStorage);\n    if (storages.length === 1) {\n      return storages[0];\n    }\n    return new MultiMetricStorage(storages);\n  };\n  MeterSharedState.prototype.registerAsyncMetricStorage = function (descriptor) {\n    var storages = this._registerMetricStorage(descriptor, AsyncMetricStorage);\n    return storages;\n  };\n  /**\n   * @param collector opaque handle of {@link MetricCollector} which initiated the collection.\n   * @param collectionTime the HrTime at which the collection was initiated.\n   * @param options options for collection.\n   * @returns the list of metric data collected.\n   */\n  MeterSharedState.prototype.collect = function (collector, collectionTime, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var errors, storages, metricDataList;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.observableRegistry.observe(collectionTime, options === null || options === void 0 ? void 0 : options.timeoutMillis)];\n          case 1:\n            errors = _a.sent();\n            storages = this.metricStorageRegistry.getStorages(collector);\n            // prevent more allocations if there are no storages.\n            if (storages.length === 0) {\n              return [2 /*return*/, null];\n            }\n            metricDataList = storages.map(function (metricStorage) {\n              return metricStorage.collect(collector, collectionTime);\n            }).filter(isNotNullish);\n            // skip this scope if no data was collected (storage created, but no data observed)\n            if (metricDataList.length === 0) {\n              return [2 /*return*/, {\n                errors: errors\n              }];\n            }\n            return [2 /*return*/, {\n              scopeMetrics: {\n                scope: this._instrumentationScope,\n                metrics: metricDataList\n              },\n              errors: errors\n            }];\n        }\n      });\n    });\n  };\n  MeterSharedState.prototype._registerMetricStorage = function (descriptor, MetricStorageType) {\n    var _this = this;\n    var views = this._meterProviderSharedState.viewRegistry.findViews(descriptor, this._instrumentationScope);\n    var storages = views.map(function (view) {\n      var viewDescriptor = createInstrumentDescriptorWithView(view, descriptor);\n      var compatibleStorage = _this.metricStorageRegistry.findOrUpdateCompatibleStorage(viewDescriptor);\n      if (compatibleStorage != null) {\n        return compatibleStorage;\n      }\n      var aggregator = view.aggregation.createAggregator(viewDescriptor);\n      var viewStorage = new MetricStorageType(viewDescriptor, aggregator, view.attributesProcessor, _this._meterProviderSharedState.metricCollectors);\n      _this.metricStorageRegistry.register(viewStorage);\n      return viewStorage;\n    });\n    // Fallback to the per-collector aggregations if no view is configured for the instrument.\n    if (storages.length === 0) {\n      var perCollectorAggregations = this._meterProviderSharedState.selectAggregations(descriptor.type);\n      var collectorStorages = perCollectorAggregations.map(function (_a) {\n        var _b = __read(_a, 2),\n          collector = _b[0],\n          aggregation = _b[1];\n        var compatibleStorage = _this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage(collector, descriptor);\n        if (compatibleStorage != null) {\n          return compatibleStorage;\n        }\n        var aggregator = aggregation.createAggregator(descriptor);\n        var storage = new MetricStorageType(descriptor, aggregator, AttributesProcessor.Noop(), [collector]);\n        _this.metricStorageRegistry.registerForCollector(collector, storage);\n        return storage;\n      });\n      storages = storages.concat(collectorStorages);\n    }\n    return storages;\n  };\n  return MeterSharedState;\n}();\nexport { MeterSharedState };","map":{"version":3,"names":["createInstrumentDescriptorWithView","Meter","isNotNullish","AsyncMetricStorage","MetricStorageRegistry","MultiMetricStorage","ObservableRegistry","SyncMetricStorage","AttributesProcessor","MeterSharedState","_meterProviderSharedState","_instrumentationScope","metricStorageRegistry","observableRegistry","meter","prototype","registerMetricStorage","descriptor","storages","_registerMetricStorage","length","registerAsyncMetricStorage","collect","collector","collectionTime","options","observe","timeoutMillis","errors","_a","sent","getStorages","metricDataList","map","metricStorage","filter","scopeMetrics","scope","metrics","MetricStorageType","_this","views","viewRegistry","findViews","view","viewDescriptor","compatibleStorage","findOrUpdateCompatibleStorage","aggregator","aggregation","createAggregator","viewStorage","attributesProcessor","metricCollectors","register","perCollectorAggregations","selectAggregations","type","collectorStorages","_b","__read","findOrUpdateCompatibleCollectorStorage","storage","Noop","registerForCollector","concat"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/state/MeterSharedState.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { MetricCollectOptions } from '../export/MetricProducer';\nimport { ScopeMetrics } from '../export/MetricData';\nimport {\n  createInstrumentDescriptorWithView,\n  InstrumentDescriptor,\n} from '../InstrumentDescriptor';\nimport { Meter } from '../Meter';\nimport { isNotNullish, Maybe } from '../utils';\nimport { AsyncMetricStorage } from './AsyncMetricStorage';\nimport { MeterProviderSharedState } from './MeterProviderSharedState';\nimport { MetricCollectorHandle } from './MetricCollector';\nimport { MetricStorageRegistry } from './MetricStorageRegistry';\nimport { MultiMetricStorage } from './MultiWritableMetricStorage';\nimport { ObservableRegistry } from './ObservableRegistry';\nimport { SyncMetricStorage } from './SyncMetricStorage';\nimport { Accumulation, Aggregator } from '../aggregator/types';\nimport { AttributesProcessor } from '../view/AttributesProcessor';\nimport { MetricStorage } from './MetricStorage';\n\n/**\n * An internal record for shared meter provider states.\n */\nexport class MeterSharedState {\n  metricStorageRegistry = new MetricStorageRegistry();\n  observableRegistry = new ObservableRegistry();\n  meter: Meter;\n\n  constructor(\n    private _meterProviderSharedState: MeterProviderSharedState,\n    private _instrumentationScope: InstrumentationScope\n  ) {\n    this.meter = new Meter(this);\n  }\n\n  registerMetricStorage(descriptor: InstrumentDescriptor) {\n    const storages = this._registerMetricStorage(descriptor, SyncMetricStorage);\n\n    if (storages.length === 1) {\n      return storages[0];\n    }\n    return new MultiMetricStorage(storages);\n  }\n\n  registerAsyncMetricStorage(descriptor: InstrumentDescriptor) {\n    const storages = this._registerMetricStorage(\n      descriptor,\n      AsyncMetricStorage\n    );\n\n    return storages;\n  }\n\n  /**\n   * @param collector opaque handle of {@link MetricCollector} which initiated the collection.\n   * @param collectionTime the HrTime at which the collection was initiated.\n   * @param options options for collection.\n   * @returns the list of metric data collected.\n   */\n  async collect(\n    collector: MetricCollectorHandle,\n    collectionTime: HrTime,\n    options?: MetricCollectOptions\n  ): Promise<ScopeMetricsResult | null> {\n    /**\n     * 1. Call all observable callbacks first.\n     * 2. Collect metric result for the collector.\n     */\n    const errors = await this.observableRegistry.observe(\n      collectionTime,\n      options?.timeoutMillis\n    );\n    const storages = this.metricStorageRegistry.getStorages(collector);\n\n    // prevent more allocations if there are no storages.\n    if (storages.length === 0) {\n      return null;\n    }\n\n    const metricDataList = storages\n      .map(metricStorage => {\n        return metricStorage.collect(collector, collectionTime);\n      })\n      .filter(isNotNullish);\n\n    // skip this scope if no data was collected (storage created, but no data observed)\n    if (metricDataList.length === 0) {\n      return { errors };\n    }\n\n    return {\n      scopeMetrics: {\n        scope: this._instrumentationScope,\n        metrics: metricDataList,\n      },\n      errors,\n    };\n  }\n\n  private _registerMetricStorage<\n    MetricStorageType extends MetricStorageConstructor,\n    R extends InstanceType<MetricStorageType>,\n  >(\n    descriptor: InstrumentDescriptor,\n    MetricStorageType: MetricStorageType\n  ): R[] {\n    const views = this._meterProviderSharedState.viewRegistry.findViews(\n      descriptor,\n      this._instrumentationScope\n    );\n    let storages = views.map(view => {\n      const viewDescriptor = createInstrumentDescriptorWithView(\n        view,\n        descriptor\n      );\n      const compatibleStorage =\n        this.metricStorageRegistry.findOrUpdateCompatibleStorage<R>(\n          viewDescriptor\n        );\n      if (compatibleStorage != null) {\n        return compatibleStorage;\n      }\n      const aggregator = view.aggregation.createAggregator(viewDescriptor);\n      const viewStorage = new MetricStorageType(\n        viewDescriptor,\n        aggregator,\n        view.attributesProcessor,\n        this._meterProviderSharedState.metricCollectors\n      ) as R;\n      this.metricStorageRegistry.register(viewStorage);\n      return viewStorage;\n    });\n\n    // Fallback to the per-collector aggregations if no view is configured for the instrument.\n    if (storages.length === 0) {\n      const perCollectorAggregations =\n        this._meterProviderSharedState.selectAggregations(descriptor.type);\n      const collectorStorages = perCollectorAggregations.map(\n        ([collector, aggregation]) => {\n          const compatibleStorage =\n            this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage<R>(\n              collector,\n              descriptor\n            );\n          if (compatibleStorage != null) {\n            return compatibleStorage;\n          }\n          const aggregator = aggregation.createAggregator(descriptor);\n          const storage = new MetricStorageType(\n            descriptor,\n            aggregator,\n            AttributesProcessor.Noop(),\n            [collector]\n          ) as R;\n          this.metricStorageRegistry.registerForCollector(collector, storage);\n          return storage;\n        }\n      );\n      storages = storages.concat(collectorStorages);\n    }\n\n    return storages;\n  }\n}\n\ninterface ScopeMetricsResult {\n  scopeMetrics?: ScopeMetrics;\n  errors: unknown[];\n}\n\ninterface MetricStorageConstructor {\n  new (\n    instrumentDescriptor: InstrumentDescriptor,\n    aggregator: Aggregator<Maybe<Accumulation>>,\n    attributesProcessor: AttributesProcessor,\n    collectors: MetricCollectorHandle[]\n  ): MetricStorage;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}