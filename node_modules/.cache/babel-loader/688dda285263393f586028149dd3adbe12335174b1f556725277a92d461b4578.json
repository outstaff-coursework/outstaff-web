{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport * as api from '@opentelemetry/api';\nimport { isWrapped, InstrumentationBase, safeExecuteInTheMiddle } from '@opentelemetry/instrumentation';\nimport * as core from '@opentelemetry/core';\nimport * as web from '@opentelemetry/sdk-trace-web';\nimport { AttributeNames } from './enums/AttributeNames';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { VERSION } from './version';\nimport { _globalThis } from '@opentelemetry/core';\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nvar OBSERVER_WAIT_TIME_MS = 300;\n/**\n * This class represents a fetch plugin for auto instrumentation\n */\nvar FetchInstrumentation = /** @class */function (_super) {\n  __extends(FetchInstrumentation, _super);\n  function FetchInstrumentation(config) {\n    var _this = _super.call(this, '@opentelemetry/instrumentation-fetch', VERSION, config) || this;\n    _this.component = 'fetch';\n    _this.version = VERSION;\n    _this.moduleName = _this.component;\n    _this._usedResources = new WeakSet();\n    _this._tasksCount = 0;\n    return _this;\n  }\n  FetchInstrumentation.prototype.init = function () {};\n  FetchInstrumentation.prototype._getConfig = function () {\n    return this._config;\n  };\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   */\n  FetchInstrumentation.prototype._addChildSpan = function (span, corsPreFlightRequest) {\n    var childSpan = this.tracer.startSpan('CORS Preflight', {\n      startTime: corsPreFlightRequest[web.PerformanceTimingNames.FETCH_START]\n    }, api.trace.setSpan(api.context.active(), span));\n    if (!this._getConfig().ignoreNetworkEvents) {\n      web.addSpanNetworkEvents(childSpan, corsPreFlightRequest);\n    }\n    childSpan.end(corsPreFlightRequest[web.PerformanceTimingNames.RESPONSE_END]);\n  };\n  /**\n   * Adds more attributes to span just before ending it\n   * @param span\n   * @param response\n   */\n  FetchInstrumentation.prototype._addFinalSpanAttributes = function (span, response) {\n    var parsedUrl = web.parseUrl(response.url);\n    span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, response.status);\n    if (response.statusText != null) {\n      span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, response.statusText);\n    }\n    span.setAttribute(SemanticAttributes.HTTP_HOST, parsedUrl.host);\n    span.setAttribute(SemanticAttributes.HTTP_SCHEME, parsedUrl.protocol.replace(':', ''));\n    if (typeof navigator !== 'undefined') {\n      span.setAttribute(SemanticAttributes.HTTP_USER_AGENT, navigator.userAgent);\n    }\n  };\n  /**\n   * Add headers\n   * @param options\n   * @param spanUrl\n   */\n  FetchInstrumentation.prototype._addHeaders = function (options, spanUrl) {\n    if (!web.shouldPropagateTraceHeaders(spanUrl, this._getConfig().propagateTraceHeaderCorsUrls)) {\n      var headers = {};\n      api.propagation.inject(api.context.active(), headers);\n      if (Object.keys(headers).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n    if (options instanceof Request) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: function (h, k, v) {\n          return h.set(k, typeof v === 'string' ? v : String(v));\n        }\n      });\n    } else if (options.headers instanceof Headers) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: function (h, k, v) {\n          return h.set(k, typeof v === 'string' ? v : String(v));\n        }\n      });\n    } else if (options.headers instanceof Map) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: function (h, k, v) {\n          return h.set(k, typeof v === 'string' ? v : String(v));\n        }\n      });\n    } else {\n      var headers = {};\n      api.propagation.inject(api.context.active(), headers);\n      options.headers = Object.assign({}, headers, options.headers || {});\n    }\n  };\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link FetchPluginConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  FetchInstrumentation.prototype._clearResources = function () {\n    if (this._tasksCount === 0 && this._getConfig().clearTimingResources) {\n      performance.clearResourceTimings();\n      this._usedResources = new WeakSet();\n    }\n  };\n  /**\n   * Creates a new span\n   * @param url\n   * @param options\n   */\n  FetchInstrumentation.prototype._createSpan = function (url, options) {\n    var _a;\n    if (options === void 0) {\n      options = {};\n    }\n    if (core.isUrlIgnored(url, this._getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n    var method = (options.method || 'GET').toUpperCase();\n    var spanName = \"HTTP \" + method;\n    return this.tracer.startSpan(spanName, {\n      kind: api.SpanKind.CLIENT,\n      attributes: (_a = {}, _a[AttributeNames.COMPONENT] = this.moduleName, _a[SemanticAttributes.HTTP_METHOD] = method, _a[SemanticAttributes.HTTP_URL] = url, _a)\n    });\n  };\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   * @param resourcesObserver\n   * @param endTime\n   */\n  FetchInstrumentation.prototype._findResourceAndAddNetworkEvents = function (span, resourcesObserver, endTime) {\n    var resources = resourcesObserver.entries;\n    if (!resources.length) {\n      if (!performance.getEntriesByType) {\n        return;\n      }\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      resources = performance.getEntriesByType('resource');\n    }\n    var resource = web.getResource(resourcesObserver.spanUrl, resourcesObserver.startTime, endTime, resources, this._usedResources, 'fetch');\n    if (resource.mainRequest) {\n      var mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n      var corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      if (!this._getConfig().ignoreNetworkEvents) {\n        web.addSpanNetworkEvents(span, mainRequest);\n      }\n    }\n  };\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   */\n  FetchInstrumentation.prototype._markResourceAsUsed = function (resource) {\n    this._usedResources.add(resource);\n  };\n  /**\n   * Finish span, add attributes, network events etc.\n   * @param span\n   * @param spanData\n   * @param response\n   */\n  FetchInstrumentation.prototype._endSpan = function (span, spanData, response) {\n    var _this = this;\n    var endTime = core.millisToHrTime(Date.now());\n    var performanceEndTime = core.hrTime();\n    this._addFinalSpanAttributes(span, response);\n    setTimeout(function () {\n      var _a;\n      (_a = spanData.observer) === null || _a === void 0 ? void 0 : _a.disconnect();\n      _this._findResourceAndAddNetworkEvents(span, spanData, performanceEndTime);\n      _this._tasksCount--;\n      _this._clearResources();\n      span.end(endTime);\n    }, OBSERVER_WAIT_TIME_MS);\n  };\n  /**\n   * Patches the constructor of fetch\n   */\n  FetchInstrumentation.prototype._patchConstructor = function () {\n    var _this = this;\n    return function (original) {\n      var plugin = _this;\n      return function patchConstructor() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var self = this;\n        var url = web.parseUrl(args[0] instanceof Request ? args[0].url : String(args[0])).href;\n        var options = args[0] instanceof Request ? args[0] : args[1] || {};\n        var createdSpan = plugin._createSpan(url, options);\n        if (!createdSpan) {\n          return original.apply(this, args);\n        }\n        var spanData = plugin._prepareSpanData(url);\n        function endSpanOnError(span, error) {\n          plugin._applyAttributesAfterFetch(span, options, error);\n          plugin._endSpan(span, spanData, {\n            status: error.status || 0,\n            statusText: error.message,\n            url: url\n          });\n        }\n        function endSpanOnSuccess(span, response) {\n          plugin._applyAttributesAfterFetch(span, options, response);\n          if (response.status >= 200 && response.status < 400) {\n            plugin._endSpan(span, spanData, response);\n          } else {\n            plugin._endSpan(span, spanData, {\n              status: response.status,\n              statusText: response.statusText,\n              url: url\n            });\n          }\n        }\n        function onSuccess(span, resolve, response) {\n          try {\n            var resClone = response.clone();\n            var resClone4Hook_1 = response.clone();\n            var body = resClone.body;\n            if (body) {\n              var reader_1 = body.getReader();\n              var read_1 = function () {\n                reader_1.read().then(function (_a) {\n                  var done = _a.done;\n                  if (done) {\n                    endSpanOnSuccess(span, resClone4Hook_1);\n                  } else {\n                    read_1();\n                  }\n                }, function (error) {\n                  endSpanOnError(span, error);\n                });\n              };\n              read_1();\n            } else {\n              // some older browsers don't have .body implemented\n              endSpanOnSuccess(span, response);\n            }\n          } finally {\n            resolve(response);\n          }\n        }\n        function onError(span, reject, error) {\n          try {\n            endSpanOnError(span, error);\n          } finally {\n            reject(error);\n          }\n        }\n        return new Promise(function (resolve, reject) {\n          return api.context.with(api.trace.setSpan(api.context.active(), createdSpan), function () {\n            plugin._addHeaders(options, url);\n            plugin._tasksCount++;\n            // TypeScript complains about arrow function captured a this typed as globalThis\n            // ts(7041)\n            return original.apply(self, options instanceof Request ? [options] : [url, options]).then(onSuccess.bind(self, createdSpan, resolve), onError.bind(self, createdSpan, reject));\n          });\n        });\n      };\n    };\n  };\n  FetchInstrumentation.prototype._applyAttributesAfterFetch = function (span, request, result) {\n    var _this = this;\n    var applyCustomAttributesOnSpan = this._getConfig().applyCustomAttributesOnSpan;\n    if (applyCustomAttributesOnSpan) {\n      safeExecuteInTheMiddle(function () {\n        return applyCustomAttributesOnSpan(span, request, result);\n      }, function (error) {\n        if (!error) {\n          return;\n        }\n        _this._diag.error('applyCustomAttributesOnSpan', error);\n      }, true);\n    }\n  };\n  /**\n   * Prepares a span data - needed later for matching appropriate network\n   *     resources\n   * @param spanUrl\n   */\n  FetchInstrumentation.prototype._prepareSpanData = function (spanUrl) {\n    var startTime = core.hrTime();\n    var entries = [];\n    if (typeof PerformanceObserver !== 'function') {\n      return {\n        entries: entries,\n        startTime: startTime,\n        spanUrl: spanUrl\n      };\n    }\n    var observer = new PerformanceObserver(function (list) {\n      var perfObsEntries = list.getEntries();\n      perfObsEntries.forEach(function (entry) {\n        if (entry.initiatorType === 'fetch' && entry.name === spanUrl) {\n          entries.push(entry);\n        }\n      });\n    });\n    observer.observe({\n      entryTypes: ['resource']\n    });\n    return {\n      entries: entries,\n      observer: observer,\n      startTime: startTime,\n      spanUrl: spanUrl\n    };\n  };\n  /**\n   * implements enable function\n   */\n  FetchInstrumentation.prototype.enable = function () {\n    if (isWrapped(fetch)) {\n      this._unwrap(_globalThis, 'fetch');\n      this._diag.debug('removing previous patch for constructor');\n    }\n    this._wrap(_globalThis, 'fetch', this._patchConstructor());\n  };\n  /**\n   * implements unpatch function\n   */\n  FetchInstrumentation.prototype.disable = function () {\n    this._unwrap(_globalThis, 'fetch');\n    this._usedResources = new WeakSet();\n  };\n  return FetchInstrumentation;\n}(InstrumentationBase);\nexport { FetchInstrumentation };","map":{"version":3,"names":["api","isWrapped","InstrumentationBase","safeExecuteInTheMiddle","core","web","AttributeNames","SemanticAttributes","VERSION","_globalThis","OBSERVER_WAIT_TIME_MS","FetchInstrumentation","_super","__extends","config","_this","call","component","version","moduleName","_usedResources","WeakSet","_tasksCount","prototype","init","_getConfig","_config","_addChildSpan","span","corsPreFlightRequest","childSpan","tracer","startSpan","startTime","PerformanceTimingNames","FETCH_START","trace","setSpan","context","active","ignoreNetworkEvents","addSpanNetworkEvents","end","RESPONSE_END","_addFinalSpanAttributes","response","parsedUrl","parseUrl","url","setAttribute","HTTP_STATUS_CODE","status","statusText","HTTP_STATUS_TEXT","HTTP_HOST","host","HTTP_SCHEME","protocol","replace","navigator","HTTP_USER_AGENT","userAgent","_addHeaders","options","spanUrl","shouldPropagateTraceHeaders","propagateTraceHeaderCorsUrls","headers","propagation","inject","Object","keys","length","_diag","debug","Request","set","h","k","v","String","Headers","Map","assign","_clearResources","clearTimingResources","performance","clearResourceTimings","_createSpan","isUrlIgnored","ignoreUrls","method","toUpperCase","spanName","kind","SpanKind","CLIENT","attributes","_a","COMPONENT","HTTP_METHOD","HTTP_URL","_findResourceAndAddNetworkEvents","resourcesObserver","endTime","resources","entries","getEntriesByType","resource","getResource","mainRequest","_markResourceAsUsed","add","_endSpan","spanData","millisToHrTime","Date","now","performanceEndTime","hrTime","setTimeout","observer","disconnect","_patchConstructor","original","plugin","patchConstructor","args","_i","arguments","self","href","createdSpan","apply","_prepareSpanData","endSpanOnError","error","_applyAttributesAfterFetch","message","endSpanOnSuccess","onSuccess","resolve","resClone","clone","resClone4Hook_1","body","reader_1","getReader","read_1","read","then","done","onError","reject","Promise","with","bind","request","result","applyCustomAttributesOnSpan","PerformanceObserver","list","perfObsEntries","getEntries","forEach","entry","initiatorType","name","push","observe","entryTypes","enable","fetch","_unwrap","_wrap","disable"],"sources":["/home/egor/node_modules/@opentelemetry/instrumentation-fetch/src/fetch.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  isWrapped,\n  InstrumentationBase,\n  InstrumentationConfig,\n  safeExecuteInTheMiddle,\n} from '@opentelemetry/instrumentation';\nimport * as core from '@opentelemetry/core';\nimport * as web from '@opentelemetry/sdk-trace-web';\nimport { AttributeNames } from './enums/AttributeNames';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { FetchError, FetchResponse, SpanData } from './types';\nimport { VERSION } from './version';\nimport { _globalThis } from '@opentelemetry/core';\n\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nconst OBSERVER_WAIT_TIME_MS = 300;\n\nexport interface FetchCustomAttributeFunction {\n  (\n    span: api.Span,\n    request: Request | RequestInit,\n    result: Response | FetchError\n  ): void;\n}\n\n/**\n * FetchPlugin Config\n */\nexport interface FetchInstrumentationConfig extends InstrumentationConfig {\n  // the number of timing resources is limited, after the limit\n  // (chrome 250, safari 150) the information is not collected anymore\n  // the only way to prevent that is to regularly clean the resources\n  // whenever it is possible, this is needed only when PerformanceObserver\n  // is not available\n  clearTimingResources?: boolean;\n  // urls which should include trace headers when origin doesn't match\n  propagateTraceHeaderCorsUrls?: web.PropagateTraceHeaderCorsUrls;\n  /**\n   * URLs that partially match any regex in ignoreUrls will not be traced.\n   * In addition, URLs that are _exact matches_ of strings in ignoreUrls will\n   * also not be traced.\n   */\n  ignoreUrls?: Array<string | RegExp>;\n  /** Function for adding custom attributes on the span */\n  applyCustomAttributesOnSpan?: FetchCustomAttributeFunction;\n  // Ignore adding network events as span events\n  ignoreNetworkEvents?: boolean;\n}\n\n/**\n * This class represents a fetch plugin for auto instrumentation\n */\nexport class FetchInstrumentation extends InstrumentationBase<\n  Promise<Response>\n> {\n  readonly component: string = 'fetch';\n  readonly version: string = VERSION;\n  moduleName = this.component;\n  private _usedResources = new WeakSet<PerformanceResourceTiming>();\n  private _tasksCount = 0;\n\n  constructor(config?: FetchInstrumentationConfig) {\n    super('@opentelemetry/instrumentation-fetch', VERSION, config);\n  }\n\n  init(): void {}\n\n  private _getConfig(): FetchInstrumentationConfig {\n    return this._config;\n  }\n\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   */\n  private _addChildSpan(\n    span: api.Span,\n    corsPreFlightRequest: PerformanceResourceTiming\n  ): void {\n    const childSpan = this.tracer.startSpan(\n      'CORS Preflight',\n      {\n        startTime: corsPreFlightRequest[web.PerformanceTimingNames.FETCH_START],\n      },\n      api.trace.setSpan(api.context.active(), span)\n    );\n    if (!this._getConfig().ignoreNetworkEvents) {\n      web.addSpanNetworkEvents(childSpan, corsPreFlightRequest);\n    }\n    childSpan.end(\n      corsPreFlightRequest[web.PerformanceTimingNames.RESPONSE_END]\n    );\n  }\n\n  /**\n   * Adds more attributes to span just before ending it\n   * @param span\n   * @param response\n   */\n  private _addFinalSpanAttributes(\n    span: api.Span,\n    response: FetchResponse\n  ): void {\n    const parsedUrl = web.parseUrl(response.url);\n    span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, response.status);\n    if (response.statusText != null) {\n      span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, response.statusText);\n    }\n    span.setAttribute(SemanticAttributes.HTTP_HOST, parsedUrl.host);\n    span.setAttribute(\n      SemanticAttributes.HTTP_SCHEME,\n      parsedUrl.protocol.replace(':', '')\n    );\n    if (typeof navigator !== 'undefined') {\n      span.setAttribute(\n        SemanticAttributes.HTTP_USER_AGENT,\n        navigator.userAgent\n      );\n    }\n  }\n\n  /**\n   * Add headers\n   * @param options\n   * @param spanUrl\n   */\n  private _addHeaders(options: Request | RequestInit, spanUrl: string): void {\n    if (\n      !web.shouldPropagateTraceHeaders(\n        spanUrl,\n        this._getConfig().propagateTraceHeaderCorsUrls\n      )\n    ) {\n      const headers: Partial<Record<string, unknown>> = {};\n      api.propagation.inject(api.context.active(), headers);\n      if (Object.keys(headers).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n\n    if (options instanceof Request) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n      });\n    } else if (options.headers instanceof Headers) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n      });\n    } else if (options.headers instanceof Map) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n      });\n    } else {\n      const headers: Partial<Record<string, unknown>> = {};\n      api.propagation.inject(api.context.active(), headers);\n      options.headers = Object.assign({}, headers, options.headers || {});\n    }\n  }\n\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link FetchPluginConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  private _clearResources() {\n    if (this._tasksCount === 0 && this._getConfig().clearTimingResources) {\n      performance.clearResourceTimings();\n      this._usedResources = new WeakSet<PerformanceResourceTiming>();\n    }\n  }\n\n  /**\n   * Creates a new span\n   * @param url\n   * @param options\n   */\n  private _createSpan(\n    url: string,\n    options: Partial<Request | RequestInit> = {}\n  ): api.Span | undefined {\n    if (core.isUrlIgnored(url, this._getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n    const method = (options.method || 'GET').toUpperCase();\n    const spanName = `HTTP ${method}`;\n    return this.tracer.startSpan(spanName, {\n      kind: api.SpanKind.CLIENT,\n      attributes: {\n        [AttributeNames.COMPONENT]: this.moduleName,\n        [SemanticAttributes.HTTP_METHOD]: method,\n        [SemanticAttributes.HTTP_URL]: url,\n      },\n    });\n  }\n\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   * @param resourcesObserver\n   * @param endTime\n   */\n  private _findResourceAndAddNetworkEvents(\n    span: api.Span,\n    resourcesObserver: SpanData,\n    endTime: api.HrTime\n  ): void {\n    let resources: PerformanceResourceTiming[] = resourcesObserver.entries;\n    if (!resources.length) {\n      if (!performance.getEntriesByType) {\n        return;\n      }\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      resources = performance.getEntriesByType(\n        'resource'\n      ) as PerformanceResourceTiming[];\n    }\n    const resource = web.getResource(\n      resourcesObserver.spanUrl,\n      resourcesObserver.startTime,\n      endTime,\n      resources,\n      this._usedResources,\n      'fetch'\n    );\n\n    if (resource.mainRequest) {\n      const mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n\n      const corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      if (!this._getConfig().ignoreNetworkEvents) {\n        web.addSpanNetworkEvents(span, mainRequest);\n      }\n    }\n  }\n\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   */\n  private _markResourceAsUsed(resource: PerformanceResourceTiming): void {\n    this._usedResources.add(resource);\n  }\n\n  /**\n   * Finish span, add attributes, network events etc.\n   * @param span\n   * @param spanData\n   * @param response\n   */\n  private _endSpan(\n    span: api.Span,\n    spanData: SpanData,\n    response: FetchResponse\n  ) {\n    const endTime = core.millisToHrTime(Date.now());\n    const performanceEndTime = core.hrTime();\n    this._addFinalSpanAttributes(span, response);\n\n    setTimeout(() => {\n      spanData.observer?.disconnect();\n      this._findResourceAndAddNetworkEvents(span, spanData, performanceEndTime);\n      this._tasksCount--;\n      this._clearResources();\n      span.end(endTime);\n    }, OBSERVER_WAIT_TIME_MS);\n  }\n\n  /**\n   * Patches the constructor of fetch\n   */\n  private _patchConstructor(): (original: typeof fetch) => typeof fetch {\n    return original => {\n      const plugin = this;\n      return function patchConstructor(\n        this: typeof globalThis,\n        ...args: Parameters<typeof fetch>\n      ): Promise<Response> {\n        const self = this;\n        const url = web.parseUrl(\n          args[0] instanceof Request ? args[0].url : String(args[0])\n        ).href;\n\n        const options = args[0] instanceof Request ? args[0] : args[1] || {};\n        const createdSpan = plugin._createSpan(url, options);\n        if (!createdSpan) {\n          return original.apply(this, args);\n        }\n        const spanData = plugin._prepareSpanData(url);\n\n        function endSpanOnError(span: api.Span, error: FetchError) {\n          plugin._applyAttributesAfterFetch(span, options, error);\n          plugin._endSpan(span, spanData, {\n            status: error.status || 0,\n            statusText: error.message,\n            url,\n          });\n        }\n\n        function endSpanOnSuccess(span: api.Span, response: Response) {\n          plugin._applyAttributesAfterFetch(span, options, response);\n          if (response.status >= 200 && response.status < 400) {\n            plugin._endSpan(span, spanData, response);\n          } else {\n            plugin._endSpan(span, spanData, {\n              status: response.status,\n              statusText: response.statusText,\n              url,\n            });\n          }\n        }\n\n        function onSuccess(\n          span: api.Span,\n          resolve: (value: Response | PromiseLike<Response>) => void,\n          response: Response\n        ): void {\n          try {\n            const resClone = response.clone();\n            const resClone4Hook = response.clone();\n            const body = resClone.body;\n            if (body) {\n              const reader = body.getReader();\n              const read = (): void => {\n                reader.read().then(\n                  ({ done }) => {\n                    if (done) {\n                      endSpanOnSuccess(span, resClone4Hook);\n                    } else {\n                      read();\n                    }\n                  },\n                  error => {\n                    endSpanOnError(span, error);\n                  }\n                );\n              };\n              read();\n            } else {\n              // some older browsers don't have .body implemented\n              endSpanOnSuccess(span, response);\n            }\n          } finally {\n            resolve(response);\n          }\n        }\n\n        function onError(\n          span: api.Span,\n          reject: (reason?: unknown) => void,\n          error: FetchError\n        ) {\n          try {\n            endSpanOnError(span, error);\n          } finally {\n            reject(error);\n          }\n        }\n\n        return new Promise((resolve, reject) => {\n          return api.context.with(\n            api.trace.setSpan(api.context.active(), createdSpan),\n            () => {\n              plugin._addHeaders(options, url);\n              plugin._tasksCount++;\n              // TypeScript complains about arrow function captured a this typed as globalThis\n              // ts(7041)\n              return original\n                .apply(\n                  self,\n                  options instanceof Request ? [options] : [url, options]\n                )\n                .then(\n                  onSuccess.bind(self, createdSpan, resolve),\n                  onError.bind(self, createdSpan, reject)\n                );\n            }\n          );\n        });\n      };\n    };\n  }\n\n  private _applyAttributesAfterFetch(\n    span: api.Span,\n    request: Request | RequestInit,\n    result: Response | FetchError\n  ) {\n    const applyCustomAttributesOnSpan =\n      this._getConfig().applyCustomAttributesOnSpan;\n    if (applyCustomAttributesOnSpan) {\n      safeExecuteInTheMiddle(\n        () => applyCustomAttributesOnSpan(span, request, result),\n        error => {\n          if (!error) {\n            return;\n          }\n\n          this._diag.error('applyCustomAttributesOnSpan', error);\n        },\n        true\n      );\n    }\n  }\n\n  /**\n   * Prepares a span data - needed later for matching appropriate network\n   *     resources\n   * @param spanUrl\n   */\n  private _prepareSpanData(spanUrl: string): SpanData {\n    const startTime = core.hrTime();\n    const entries: PerformanceResourceTiming[] = [];\n    if (typeof PerformanceObserver !== 'function') {\n      return { entries, startTime, spanUrl };\n    }\n\n    const observer = new PerformanceObserver(list => {\n      const perfObsEntries = list.getEntries() as PerformanceResourceTiming[];\n      perfObsEntries.forEach(entry => {\n        if (entry.initiatorType === 'fetch' && entry.name === spanUrl) {\n          entries.push(entry);\n        }\n      });\n    });\n    observer.observe({\n      entryTypes: ['resource'],\n    });\n    return { entries, observer, startTime, spanUrl };\n  }\n\n  /**\n   * implements enable function\n   */\n  override enable(): void {\n    if (isWrapped(fetch)) {\n      this._unwrap(_globalThis, 'fetch');\n      this._diag.debug('removing previous patch for constructor');\n    }\n    this._wrap(_globalThis, 'fetch', this._patchConstructor());\n  }\n\n  /**\n   * implements unpatch function\n   */\n  override disable(): void {\n    this._unwrap(_globalThis, 'fetch');\n    this._usedResources = new WeakSet<PerformanceResourceTiming>();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}