{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AggregatorKind } from './types';\nimport { DataPointType } from '../export/MetricData';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { binarySearchLB } from '../utils';\nfunction createNewEmptyCheckpoint(boundaries) {\n  var counts = boundaries.map(function () {\n    return 0;\n  });\n  counts.push(0);\n  return {\n    buckets: {\n      boundaries: boundaries,\n      counts: counts\n    },\n    sum: 0,\n    count: 0,\n    hasMinMax: false,\n    min: Infinity,\n    max: -Infinity\n  };\n}\nvar HistogramAccumulation = /** @class */function () {\n  function HistogramAccumulation(startTime, _boundaries, _recordMinMax, _current) {\n    if (_recordMinMax === void 0) {\n      _recordMinMax = true;\n    }\n    if (_current === void 0) {\n      _current = createNewEmptyCheckpoint(_boundaries);\n    }\n    this.startTime = startTime;\n    this._boundaries = _boundaries;\n    this._recordMinMax = _recordMinMax;\n    this._current = _current;\n  }\n  HistogramAccumulation.prototype.record = function (value) {\n    this._current.count += 1;\n    this._current.sum += value;\n    if (this._recordMinMax) {\n      this._current.min = Math.min(value, this._current.min);\n      this._current.max = Math.max(value, this._current.max);\n      this._current.hasMinMax = true;\n    }\n    var idx = binarySearchLB(this._boundaries, value);\n    this._current.buckets.counts[idx + 1] += 1;\n  };\n  HistogramAccumulation.prototype.setStartTime = function (startTime) {\n    this.startTime = startTime;\n  };\n  HistogramAccumulation.prototype.toPointValue = function () {\n    return this._current;\n  };\n  return HistogramAccumulation;\n}();\nexport { HistogramAccumulation };\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nvar HistogramAggregator = /** @class */function () {\n  /**\n   * @param _boundaries sorted upper bounds of recorded values.\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  function HistogramAggregator(_boundaries, _recordMinMax) {\n    this._boundaries = _boundaries;\n    this._recordMinMax = _recordMinMax;\n    this.kind = AggregatorKind.HISTOGRAM;\n  }\n  HistogramAggregator.prototype.createAccumulation = function (startTime) {\n    return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);\n  };\n  /**\n   * Return the result of the merge of two histogram accumulations. As long as one Aggregator\n   * instance produces all Accumulations with constant boundaries we don't need to worry about\n   * merging accumulations with different boundaries.\n   */\n  HistogramAggregator.prototype.merge = function (previous, delta) {\n    var previousValue = previous.toPointValue();\n    var deltaValue = delta.toPointValue();\n    var previousCounts = previousValue.buckets.counts;\n    var deltaCounts = deltaValue.buckets.counts;\n    var mergedCounts = new Array(previousCounts.length);\n    for (var idx = 0; idx < previousCounts.length; idx++) {\n      mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];\n    }\n    var min = Infinity;\n    var max = -Infinity;\n    if (this._recordMinMax) {\n      if (previousValue.hasMinMax && deltaValue.hasMinMax) {\n        min = Math.min(previousValue.min, deltaValue.min);\n        max = Math.max(previousValue.max, deltaValue.max);\n      } else if (previousValue.hasMinMax) {\n        min = previousValue.min;\n        max = previousValue.max;\n      } else if (deltaValue.hasMinMax) {\n        min = deltaValue.min;\n        max = deltaValue.max;\n      }\n    }\n    return new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {\n      buckets: {\n        boundaries: previousValue.buckets.boundaries,\n        counts: mergedCounts\n      },\n      count: previousValue.count + deltaValue.count,\n      sum: previousValue.sum + deltaValue.sum,\n      hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),\n      min: min,\n      max: max\n    });\n  };\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  HistogramAggregator.prototype.diff = function (previous, current) {\n    var previousValue = previous.toPointValue();\n    var currentValue = current.toPointValue();\n    var previousCounts = previousValue.buckets.counts;\n    var currentCounts = currentValue.buckets.counts;\n    var diffedCounts = new Array(previousCounts.length);\n    for (var idx = 0; idx < previousCounts.length; idx++) {\n      diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];\n    }\n    return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {\n      buckets: {\n        boundaries: previousValue.buckets.boundaries,\n        counts: diffedCounts\n      },\n      count: currentValue.count - previousValue.count,\n      sum: currentValue.sum - previousValue.sum,\n      hasMinMax: false,\n      min: Infinity,\n      max: -Infinity\n    });\n  };\n  HistogramAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor: descriptor,\n      aggregationTemporality: aggregationTemporality,\n      dataPointType: DataPointType.HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(function (_a) {\n        var _b = __read(_a, 2),\n          attributes = _b[0],\n          accumulation = _b[1];\n        var pointValue = accumulation.toPointValue();\n        // determine if instrument allows negative values.\n        var allowsNegativeValues = descriptor.type === InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n        return {\n          attributes: attributes,\n          startTime: accumulation.startTime,\n          endTime: endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            buckets: pointValue.buckets,\n            count: pointValue.count\n          }\n        };\n      })\n    };\n  };\n  return HistogramAggregator;\n}();\nexport { HistogramAggregator };","map":{"version":3,"names":["AggregatorKind","DataPointType","InstrumentType","binarySearchLB","createNewEmptyCheckpoint","boundaries","counts","map","push","buckets","sum","count","hasMinMax","min","Infinity","max","HistogramAccumulation","startTime","_boundaries","_recordMinMax","_current","prototype","record","value","Math","idx","setStartTime","toPointValue","HistogramAggregator","kind","HISTOGRAM","createAccumulation","merge","previous","delta","previousValue","deltaValue","previousCounts","deltaCounts","mergedCounts","Array","length","diff","current","currentValue","currentCounts","diffedCounts","toMetricData","descriptor","aggregationTemporality","accumulationByAttributes","endTime","dataPointType","dataPoints","_a","_b","__read","attributes","accumulation","pointValue","allowsNegativeValues","type","UP_DOWN_COUNTER","OBSERVABLE_GAUGE","OBSERVABLE_UP_DOWN_COUNTER","undefined"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/aggregator/Histogram.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n} from './types';\nimport {\n  DataPointType,\n  HistogramMetricData,\n  MetricDescriptor,\n} from '../export/MetricData';\nimport { HrTime } from '@opentelemetry/api';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { binarySearchLB, Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\n\n/**\n * Internal value type for HistogramAggregation.\n * Differs from the exported type as undefined sum/min/max complicate arithmetic\n * performed by this aggregation, but are required to be undefined in the exported types.\n */\ninterface InternalHistogram {\n  buckets: {\n    boundaries: number[];\n    counts: number[];\n  };\n  sum: number;\n  count: number;\n  hasMinMax: boolean;\n  min: number;\n  max: number;\n}\n\nfunction createNewEmptyCheckpoint(boundaries: number[]): InternalHistogram {\n  const counts = boundaries.map(() => 0);\n  counts.push(0);\n  return {\n    buckets: {\n      boundaries,\n      counts,\n    },\n    sum: 0,\n    count: 0,\n    hasMinMax: false,\n    min: Infinity,\n    max: -Infinity,\n  };\n}\n\nexport class HistogramAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    private readonly _boundaries: number[],\n    private _recordMinMax = true,\n    private _current: InternalHistogram = createNewEmptyCheckpoint(_boundaries)\n  ) {}\n\n  record(value: number): void {\n    this._current.count += 1;\n    this._current.sum += value;\n\n    if (this._recordMinMax) {\n      this._current.min = Math.min(value, this._current.min);\n      this._current.max = Math.max(value, this._current.max);\n      this._current.hasMinMax = true;\n    }\n\n    const idx = binarySearchLB(this._boundaries, value);\n    this._current.buckets.counts[idx + 1] += 1;\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): InternalHistogram {\n    return this._current;\n  }\n}\n\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nexport class HistogramAggregator implements Aggregator<HistogramAccumulation> {\n  public kind: AggregatorKind.HISTOGRAM = AggregatorKind.HISTOGRAM;\n\n  /**\n   * @param _boundaries sorted upper bounds of recorded values.\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    private readonly _boundaries: number[],\n    private readonly _recordMinMax: boolean\n  ) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new HistogramAccumulation(\n      startTime,\n      this._boundaries,\n      this._recordMinMax\n    );\n  }\n\n  /**\n   * Return the result of the merge of two histogram accumulations. As long as one Aggregator\n   * instance produces all Accumulations with constant boundaries we don't need to worry about\n   * merging accumulations with different boundaries.\n   */\n  merge(\n    previous: HistogramAccumulation,\n    delta: HistogramAccumulation\n  ): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const deltaValue = delta.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const deltaCounts = deltaValue.buckets.counts;\n\n    const mergedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];\n    }\n\n    let min = Infinity;\n    let max = -Infinity;\n\n    if (this._recordMinMax) {\n      if (previousValue.hasMinMax && deltaValue.hasMinMax) {\n        min = Math.min(previousValue.min, deltaValue.min);\n        max = Math.max(previousValue.max, deltaValue.max);\n      } else if (previousValue.hasMinMax) {\n        min = previousValue.min;\n        max = previousValue.max;\n      } else if (deltaValue.hasMinMax) {\n        min = deltaValue.min;\n        max = deltaValue.max;\n      }\n    }\n\n    return new HistogramAccumulation(\n      previous.startTime,\n      previousValue.buckets.boundaries,\n      this._recordMinMax,\n      {\n        buckets: {\n          boundaries: previousValue.buckets.boundaries,\n          counts: mergedCounts,\n        },\n        count: previousValue.count + deltaValue.count,\n        sum: previousValue.sum + deltaValue.sum,\n        hasMinMax:\n          this._recordMinMax &&\n          (previousValue.hasMinMax || deltaValue.hasMinMax),\n        min: min,\n        max: max,\n      }\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(\n    previous: HistogramAccumulation,\n    current: HistogramAccumulation\n  ): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const currentValue = current.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const currentCounts = currentValue.buckets.counts;\n\n    const diffedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];\n    }\n\n    return new HistogramAccumulation(\n      current.startTime,\n      previousValue.buckets.boundaries,\n      this._recordMinMax,\n      {\n        buckets: {\n          boundaries: previousValue.buckets.boundaries,\n          counts: diffedCounts,\n        },\n        count: currentValue.count - previousValue.count,\n        sum: currentValue.sum - previousValue.sum,\n        hasMinMax: false,\n        min: Infinity,\n        max: -Infinity,\n      }\n    );\n  }\n\n  toMetricData(\n    descriptor: MetricDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<HistogramAccumulation>[],\n    endTime: HrTime\n  ): Maybe<HistogramMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        const pointValue = accumulation.toPointValue();\n\n        // determine if instrument allows negative values.\n        const allowsNegativeValues =\n          descriptor.type === InstrumentType.UP_DOWN_COUNTER ||\n          descriptor.type === InstrumentType.OBSERVABLE_GAUGE ||\n          descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            buckets: pointValue.buckets,\n            count: pointValue.count,\n          },\n        };\n      }),\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}