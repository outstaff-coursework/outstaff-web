{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Provides unique reporting for each collector. Allows synchronous collection\n * of metrics and reports given temporality values.\n */\nvar TemporalMetricProcessor = /** @class */function () {\n  function TemporalMetricProcessor(_aggregator, collectorHandles) {\n    var _this = this;\n    this._aggregator = _aggregator;\n    this._unreportedAccumulations = new Map();\n    this._reportHistory = new Map();\n    collectorHandles.forEach(function (handle) {\n      _this._unreportedAccumulations.set(handle, []);\n    });\n  }\n  /**\n   * Builds the {@link MetricData} streams to report against a specific MetricCollector.\n   * @param collector The information of the MetricCollector.\n   * @param collectors The registered collectors.\n   * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.\n   * @param currentAccumulations The current accumulation of metric data from instruments.\n   * @param collectionTime The current collection timestamp.\n   * @returns The {@link MetricData} points or `null`.\n   */\n  TemporalMetricProcessor.prototype.buildMetrics = function (collector, instrumentDescriptor, currentAccumulations, collectionTime) {\n    this._stashAccumulations(currentAccumulations);\n    var unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);\n    var result = unreportedAccumulations;\n    var aggregationTemporality;\n    // Check our last report time.\n    if (this._reportHistory.has(collector)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      var last = this._reportHistory.get(collector);\n      var lastCollectionTime = last.collectionTime;\n      aggregationTemporality = last.aggregationTemporality;\n      // Use aggregation temporality + instrument to determine if we do a merge or a diff of\n      // previous. We have the following four scenarios:\n      // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 2. Cumulative Aggregation + Cumulative recording (async instrument).\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 3. Delta Aggregation + Delta recording\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      // 4. Delta Aggregation + Cumulative recording.\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      if (aggregationTemporality === AggregationTemporality.CUMULATIVE) {\n        // We need to make sure the current delta recording gets merged into the previous cumulative\n        // for the next cumulative recording.\n        result = TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator);\n      } else {\n        result = TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);\n      }\n    } else {\n      // Call into user code to select aggregation temporality for the instrument.\n      aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);\n    }\n    // Update last reported (cumulative) accumulation.\n    this._reportHistory.set(collector, {\n      accumulations: result,\n      collectionTime: collectionTime,\n      aggregationTemporality: aggregationTemporality\n    });\n    var accumulationRecords = AttributesMapToAccumulationRecords(result);\n    // do not convert to metric data if there is nothing to convert.\n    if (accumulationRecords.length === 0) {\n      return undefined;\n    }\n    return this._aggregator.toMetricData(instrumentDescriptor, aggregationTemporality, accumulationRecords, /* endTime */collectionTime);\n  };\n  TemporalMetricProcessor.prototype._stashAccumulations = function (currentAccumulation) {\n    var e_1, _a;\n    var registeredCollectors = this._unreportedAccumulations.keys();\n    try {\n      for (var registeredCollectors_1 = __values(registeredCollectors), registeredCollectors_1_1 = registeredCollectors_1.next(); !registeredCollectors_1_1.done; registeredCollectors_1_1 = registeredCollectors_1.next()) {\n        var collector = registeredCollectors_1_1.value;\n        var stash = this._unreportedAccumulations.get(collector);\n        if (stash === undefined) {\n          stash = [];\n          this._unreportedAccumulations.set(collector, stash);\n        }\n        stash.push(currentAccumulation);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (registeredCollectors_1_1 && !registeredCollectors_1_1.done && (_a = registeredCollectors_1.return)) _a.call(registeredCollectors_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  TemporalMetricProcessor.prototype._getMergedUnreportedAccumulations = function (collector) {\n    var e_2, _a;\n    var result = new AttributeHashMap();\n    var unreportedList = this._unreportedAccumulations.get(collector);\n    this._unreportedAccumulations.set(collector, []);\n    if (unreportedList === undefined) {\n      return result;\n    }\n    try {\n      for (var unreportedList_1 = __values(unreportedList), unreportedList_1_1 = unreportedList_1.next(); !unreportedList_1_1.done; unreportedList_1_1 = unreportedList_1.next()) {\n        var it_1 = unreportedList_1_1.value;\n        result = TemporalMetricProcessor.merge(result, it_1, this._aggregator);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (unreportedList_1_1 && !unreportedList_1_1.done && (_a = unreportedList_1.return)) _a.call(unreportedList_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return result;\n  };\n  TemporalMetricProcessor.merge = function (last, current, aggregator) {\n    var result = last;\n    var iterator = current.entries();\n    var next = iterator.next();\n    while (next.done !== true) {\n      var _a = __read(next.value, 3),\n        key = _a[0],\n        record = _a[1],\n        hash = _a[2];\n      if (last.has(key, hash)) {\n        var lastAccumulation = last.get(key, hash);\n        // last.has() returned true, lastAccumulation is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        var accumulation = aggregator.merge(lastAccumulation, record);\n        result.set(key, accumulation, hash);\n      } else {\n        result.set(key, record, hash);\n      }\n      next = iterator.next();\n    }\n    return result;\n  };\n  /**\n   * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves\n   * the new stream to be the initial observation time unchanged.\n   */\n  TemporalMetricProcessor.calibrateStartTime = function (last, current, lastCollectionTime) {\n    var e_3, _a;\n    try {\n      for (var _b = __values(last.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          key = _d[0],\n          hash = _d[1];\n        var currentAccumulation = current.get(key, hash);\n        currentAccumulation === null || currentAccumulation === void 0 ? void 0 : currentAccumulation.setStartTime(lastCollectionTime);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    return current;\n  };\n  return TemporalMetricProcessor;\n}();\nexport { TemporalMetricProcessor };\n// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.\nfunction AttributesMapToAccumulationRecords(map) {\n  return Array.from(map.entries());\n}","map":{"version":3,"names":["AggregationTemporality","AttributeHashMap","TemporalMetricProcessor","_aggregator","collectorHandles","_this","_unreportedAccumulations","Map","_reportHistory","forEach","handle","set","prototype","buildMetrics","collector","instrumentDescriptor","currentAccumulations","collectionTime","_stashAccumulations","unreportedAccumulations","_getMergedUnreportedAccumulations","result","aggregationTemporality","has","last","get","lastCollectionTime","CUMULATIVE","merge","accumulations","calibrateStartTime","selectAggregationTemporality","type","accumulationRecords","AttributesMapToAccumulationRecords","length","undefined","toMetricData","currentAccumulation","registeredCollectors","keys","registeredCollectors_1","__values","registeredCollectors_1_1","next","done","value","stash","push","unreportedList","unreportedList_1","unreportedList_1_1","it_1","current","aggregator","iterator","entries","_a","__read","key","record","hash","lastAccumulation","accumulation","_b","_c","_d","setStartTime","map","Array","from"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/state/TemporalMetricProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n} from '../aggregator/types';\nimport { MetricData } from '../export/MetricData';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { Maybe } from '../utils';\nimport { MetricCollectorHandle } from './MetricCollector';\nimport { AttributeHashMap } from './HashMap';\n\n/**\n * Remembers what was presented to a specific exporter.\n */\ninterface LastReportedHistory<T extends Maybe<Accumulation>> {\n  /**\n   * The last accumulation of metric data.\n   */\n  accumulations: AttributeHashMap<T>;\n  /**\n   * The timestamp the data was reported.\n   */\n  collectionTime: HrTime;\n  /**\n   * The AggregationTemporality used to aggregate reports.\n   */\n  aggregationTemporality: AggregationTemporality;\n}\n\n/**\n * Internal interface.\n *\n * Provides unique reporting for each collector. Allows synchronous collection\n * of metrics and reports given temporality values.\n */\nexport class TemporalMetricProcessor<T extends Maybe<Accumulation>> {\n  private _unreportedAccumulations = new Map<\n    MetricCollectorHandle,\n    AttributeHashMap<T>[]\n  >();\n  private _reportHistory = new Map<\n    MetricCollectorHandle,\n    LastReportedHistory<T>\n  >();\n\n  constructor(\n    private _aggregator: Aggregator<T>,\n    collectorHandles: MetricCollectorHandle[]\n  ) {\n    collectorHandles.forEach(handle => {\n      this._unreportedAccumulations.set(handle, []);\n    });\n  }\n\n  /**\n   * Builds the {@link MetricData} streams to report against a specific MetricCollector.\n   * @param collector The information of the MetricCollector.\n   * @param collectors The registered collectors.\n   * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.\n   * @param currentAccumulations The current accumulation of metric data from instruments.\n   * @param collectionTime The current collection timestamp.\n   * @returns The {@link MetricData} points or `null`.\n   */\n  buildMetrics(\n    collector: MetricCollectorHandle,\n    instrumentDescriptor: InstrumentDescriptor,\n    currentAccumulations: AttributeHashMap<T>,\n    collectionTime: HrTime\n  ): Maybe<MetricData> {\n    this._stashAccumulations(currentAccumulations);\n    const unreportedAccumulations =\n      this._getMergedUnreportedAccumulations(collector);\n\n    let result = unreportedAccumulations;\n    let aggregationTemporality: AggregationTemporality;\n    // Check our last report time.\n    if (this._reportHistory.has(collector)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const last = this._reportHistory.get(collector)!;\n      const lastCollectionTime = last.collectionTime;\n      aggregationTemporality = last.aggregationTemporality;\n\n      // Use aggregation temporality + instrument to determine if we do a merge or a diff of\n      // previous. We have the following four scenarios:\n      // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 2. Cumulative Aggregation + Cumulative recording (async instrument).\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 3. Delta Aggregation + Delta recording\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      // 4. Delta Aggregation + Cumulative recording.\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      if (aggregationTemporality === AggregationTemporality.CUMULATIVE) {\n        // We need to make sure the current delta recording gets merged into the previous cumulative\n        // for the next cumulative recording.\n        result = TemporalMetricProcessor.merge(\n          last.accumulations,\n          unreportedAccumulations,\n          this._aggregator\n        );\n      } else {\n        result = TemporalMetricProcessor.calibrateStartTime(\n          last.accumulations,\n          unreportedAccumulations,\n          lastCollectionTime\n        );\n      }\n    } else {\n      // Call into user code to select aggregation temporality for the instrument.\n      aggregationTemporality = collector.selectAggregationTemporality(\n        instrumentDescriptor.type\n      );\n    }\n\n    // Update last reported (cumulative) accumulation.\n    this._reportHistory.set(collector, {\n      accumulations: result,\n      collectionTime,\n      aggregationTemporality,\n    });\n\n    const accumulationRecords = AttributesMapToAccumulationRecords(result);\n\n    // do not convert to metric data if there is nothing to convert.\n    if (accumulationRecords.length === 0) {\n      return undefined;\n    }\n\n    return this._aggregator.toMetricData(\n      instrumentDescriptor,\n      aggregationTemporality,\n      accumulationRecords,\n      /* endTime */ collectionTime\n    );\n  }\n\n  private _stashAccumulations(currentAccumulation: AttributeHashMap<T>) {\n    const registeredCollectors = this._unreportedAccumulations.keys();\n    for (const collector of registeredCollectors) {\n      let stash = this._unreportedAccumulations.get(collector);\n      if (stash === undefined) {\n        stash = [];\n        this._unreportedAccumulations.set(collector, stash);\n      }\n      stash.push(currentAccumulation);\n    }\n  }\n\n  private _getMergedUnreportedAccumulations(collector: MetricCollectorHandle) {\n    let result = new AttributeHashMap<T>();\n    const unreportedList = this._unreportedAccumulations.get(collector);\n    this._unreportedAccumulations.set(collector, []);\n    if (unreportedList === undefined) {\n      return result;\n    }\n    for (const it of unreportedList) {\n      result = TemporalMetricProcessor.merge(result, it, this._aggregator);\n    }\n    return result;\n  }\n\n  static merge<T extends Maybe<Accumulation>>(\n    last: AttributeHashMap<T>,\n    current: AttributeHashMap<T>,\n    aggregator: Aggregator<T>\n  ) {\n    const result = last;\n    const iterator = current.entries();\n    let next = iterator.next();\n    while (next.done !== true) {\n      const [key, record, hash] = next.value;\n      if (last.has(key, hash)) {\n        const lastAccumulation = last.get(key, hash);\n        // last.has() returned true, lastAccumulation is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const accumulation = aggregator.merge(lastAccumulation!, record);\n        result.set(key, accumulation, hash);\n      } else {\n        result.set(key, record, hash);\n      }\n\n      next = iterator.next();\n    }\n    return result;\n  }\n\n  /**\n   * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves\n   * the new stream to be the initial observation time unchanged.\n   */\n  static calibrateStartTime<T extends Maybe<Accumulation>>(\n    last: AttributeHashMap<T>,\n    current: AttributeHashMap<T>,\n    lastCollectionTime: HrTime\n  ) {\n    for (const [key, hash] of last.keys()) {\n      const currentAccumulation = current.get(key, hash);\n      currentAccumulation?.setStartTime(lastCollectionTime);\n    }\n    return current;\n  }\n}\n\n// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.\nfunction AttributesMapToAccumulationRecords<T>(\n  map: AttributeHashMap<T>\n): AccumulationRecord<T>[] {\n  return Array.from(map.entries()) as unknown as AccumulationRecord<T>[];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}