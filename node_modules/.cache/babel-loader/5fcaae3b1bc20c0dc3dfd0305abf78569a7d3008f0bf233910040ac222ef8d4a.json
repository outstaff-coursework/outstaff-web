{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { diag, SpanStatusCode } from '@opentelemetry/api';\nimport { addHrTimes, millisToHrTime, getTimeOrigin, hrTime, hrTimeDuration, isAttributeValue, isTimeInput, isTimeInputHrTime, otperformance, sanitizeAttributes } from '@opentelemetry/core';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { ExceptionEventName } from './enums';\n/**\n * This class represents a span.\n */\nvar Span = /** @class */function () {\n  /**\n   * Constructs a new Span instance.\n   *\n   * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.\n   * */\n  function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime, _deprecatedClock,\n  // keeping this argument even though it is unused to ensure backwards compatibility\n  attributes) {\n    if (links === void 0) {\n      links = [];\n    }\n    this.attributes = {};\n    this.links = [];\n    this.events = [];\n    this._droppedAttributesCount = 0;\n    this._droppedEventsCount = 0;\n    this._droppedLinksCount = 0;\n    this.status = {\n      code: SpanStatusCode.UNSET\n    };\n    this.endTime = [0, 0];\n    this._ended = false;\n    this._duration = [-1, -1];\n    this.name = spanName;\n    this._spanContext = spanContext;\n    this.parentSpanId = parentSpanId;\n    this.kind = kind;\n    this.links = links;\n    var now = Date.now();\n    this._performanceStartTime = otperformance.now();\n    this._performanceOffset = now - (this._performanceStartTime + getTimeOrigin());\n    this._startTimeProvided = startTime != null;\n    this.startTime = this._getTime(startTime !== null && startTime !== void 0 ? startTime : now);\n    this.resource = parentTracer.resource;\n    this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n    this._spanLimits = parentTracer.getSpanLimits();\n    this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;\n    if (attributes != null) {\n      this.setAttributes(attributes);\n    }\n    this._spanProcessor = parentTracer.getActiveSpanProcessor();\n    this._spanProcessor.onStart(this, context);\n  }\n  Span.prototype.spanContext = function () {\n    return this._spanContext;\n  };\n  Span.prototype.setAttribute = function (key, value) {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      diag.warn(\"Invalid attribute key: \" + key);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag.warn(\"Invalid attribute value set for key: \" + key);\n      return this;\n    }\n    if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {\n      this._droppedAttributesCount++;\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  };\n  Span.prototype.setAttributes = function (attributes) {\n    var e_1, _a;\n    try {\n      for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          k = _d[0],\n          v = _d[1];\n        this.setAttribute(k, v);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return this;\n  };\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [timeStamp] Specified time stamp for the event\n   */\n  Span.prototype.addEvent = function (name, attributesOrStartTime, timeStamp) {\n    if (this._isSpanEnded()) return this;\n    if (this._spanLimits.eventCountLimit === 0) {\n      diag.warn('No events allowed.');\n      this._droppedEventsCount++;\n      return this;\n    }\n    if (this.events.length >= this._spanLimits.eventCountLimit) {\n      if (this._droppedEventsCount === 0) {\n        diag.debug('Dropping extra events.');\n      }\n      this.events.shift();\n      this._droppedEventsCount++;\n    }\n    if (isTimeInput(attributesOrStartTime)) {\n      if (!isTimeInput(timeStamp)) {\n        timeStamp = attributesOrStartTime;\n      }\n      attributesOrStartTime = undefined;\n    }\n    var attributes = sanitizeAttributes(attributesOrStartTime);\n    this.events.push({\n      name: name,\n      attributes: attributes,\n      time: this._getTime(timeStamp),\n      droppedAttributesCount: 0\n    });\n    return this;\n  };\n  Span.prototype.setStatus = function (status) {\n    if (this._isSpanEnded()) return this;\n    this.status = status;\n    return this;\n  };\n  Span.prototype.updateName = function (name) {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  };\n  Span.prototype.end = function (endTime) {\n    if (this._isSpanEnded()) {\n      diag.error(this.name + \" \" + this._spanContext.traceId + \"-\" + this._spanContext.spanId + \" - You can only call end() on a span once.\");\n      return;\n    }\n    this._ended = true;\n    this.endTime = this._getTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n    if (this._duration[0] < 0) {\n      diag.warn('Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.', this.startTime, this.endTime);\n      this.endTime = this.startTime.slice();\n      this._duration = [0, 0];\n    }\n    if (this._droppedEventsCount > 0) {\n      diag.warn(\"Dropped \" + this._droppedEventsCount + \" events because eventCountLimit reached\");\n    }\n    this._spanProcessor.onEnd(this);\n  };\n  Span.prototype._getTime = function (inp) {\n    if (typeof inp === 'number' && inp < otperformance.now()) {\n      // must be a performance timestamp\n      // apply correction and convert to hrtime\n      return hrTime(inp + this._performanceOffset);\n    }\n    if (typeof inp === 'number') {\n      return millisToHrTime(inp);\n    }\n    if (inp instanceof Date) {\n      return millisToHrTime(inp.getTime());\n    }\n    if (isTimeInputHrTime(inp)) {\n      return inp;\n    }\n    if (this._startTimeProvided) {\n      // if user provided a time for the start manually\n      // we can't use duration to calculate event/end times\n      return millisToHrTime(Date.now());\n    }\n    var msDuration = otperformance.now() - this._performanceStartTime;\n    return addHrTimes(this.startTime, millisToHrTime(msDuration));\n  };\n  Span.prototype.isRecording = function () {\n    return this._ended === false;\n  };\n  Span.prototype.recordException = function (exception, time) {\n    var attributes = {};\n    if (typeof exception === 'string') {\n      attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n    // these are minimum requirements from spec\n    if (attributes[SemanticAttributes.EXCEPTION_TYPE] || attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag.warn(\"Failed to record an exception \" + exception);\n    }\n  };\n  Object.defineProperty(Span.prototype, \"duration\", {\n    get: function () {\n      return this._duration;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"ended\", {\n    get: function () {\n      return this._ended;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"droppedAttributesCount\", {\n    get: function () {\n      return this._droppedAttributesCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"droppedEventsCount\", {\n    get: function () {\n      return this._droppedEventsCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"droppedLinksCount\", {\n    get: function () {\n      return this._droppedLinksCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Span.prototype._isSpanEnded = function () {\n    if (this._ended) {\n      diag.warn(\"Can not execute the operation on ended Span {traceId: \" + this._spanContext.traceId + \", spanId: \" + this._spanContext.spanId + \"}\");\n    }\n    return this._ended;\n  };\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  Span.prototype._truncateToLimitUtil = function (value, limit) {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substr(0, limit);\n  };\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with trucated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  Span.prototype._truncateToSize = function (value) {\n    var _this = this;\n    var limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      diag.warn(\"Attribute value limit must be positive, got \" + limit);\n      return value;\n    }\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n    // Array of strings\n    if (Array.isArray(value)) {\n      return value.map(function (val) {\n        return typeof val === 'string' ? _this._truncateToLimitUtil(val, limit) : val;\n      });\n    }\n    // Other types, no need to apply value length limit\n    return value;\n  };\n  return Span;\n}();\nexport { Span };","map":{"version":3,"names":["diag","SpanStatusCode","addHrTimes","millisToHrTime","getTimeOrigin","hrTime","hrTimeDuration","isAttributeValue","isTimeInput","isTimeInputHrTime","otperformance","sanitizeAttributes","SemanticAttributes","ExceptionEventName","Span","parentTracer","context","spanName","spanContext","kind","parentSpanId","links","startTime","_deprecatedClock","attributes","events","_droppedAttributesCount","_droppedEventsCount","_droppedLinksCount","status","code","UNSET","endTime","_ended","_duration","name","_spanContext","now","Date","_performanceStartTime","_performanceOffset","_startTimeProvided","_getTime","resource","instrumentationLibrary","_spanLimits","getSpanLimits","_attributeValueLengthLimit","attributeValueLengthLimit","setAttributes","_spanProcessor","getActiveSpanProcessor","onStart","prototype","setAttribute","key","value","_isSpanEnded","length","warn","Object","keys","attributeCountLimit","hasOwnProperty","call","_truncateToSize","_b","__values","entries","_c","next","done","_d","__read","k","v","addEvent","attributesOrStartTime","timeStamp","eventCountLimit","debug","shift","undefined","push","time","droppedAttributesCount","setStatus","updateName","end","error","traceId","spanId","slice","onEnd","inp","getTime","msDuration","isRecording","recordException","exception","EXCEPTION_MESSAGE","EXCEPTION_TYPE","toString","message","stack","EXCEPTION_STACKTRACE","defineProperty","get","_truncateToLimitUtil","limit","substr","_this","Array","isArray","map","val"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-trace-base/src/Span.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  diag,\n  Exception,\n  HrTime,\n  Link,\n  Span as APISpan,\n  SpanAttributes,\n  SpanAttributeValue,\n  SpanContext,\n  SpanKind,\n  SpanStatus,\n  SpanStatusCode,\n  TimeInput,\n} from '@opentelemetry/api';\nimport {\n  addHrTimes,\n  millisToHrTime,\n  getTimeOrigin,\n  hrTime,\n  hrTimeDuration,\n  InstrumentationLibrary,\n  isAttributeValue,\n  isTimeInput,\n  isTimeInputHrTime,\n  otperformance,\n  sanitizeAttributes,\n} from '@opentelemetry/core';\nimport { IResource } from '@opentelemetry/resources';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { ExceptionEventName } from './enums';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { SpanProcessor } from './SpanProcessor';\nimport { TimedEvent } from './TimedEvent';\nimport { Tracer } from './Tracer';\nimport { SpanLimits } from './types';\n\n/**\n * This class represents a span.\n */\nexport class Span implements APISpan, ReadableSpan {\n  // Below properties are included to implement ReadableSpan for export\n  // purposes but are not intended to be written-to directly.\n  private readonly _spanContext: SpanContext;\n  readonly kind: SpanKind;\n  readonly parentSpanId?: string;\n  readonly attributes: SpanAttributes = {};\n  readonly links: Link[] = [];\n  readonly events: TimedEvent[] = [];\n  readonly startTime: HrTime;\n  readonly resource: IResource;\n  readonly instrumentationLibrary: InstrumentationLibrary;\n\n  private _droppedAttributesCount = 0;\n  private _droppedEventsCount: number = 0;\n  private _droppedLinksCount: number = 0;\n\n  name: string;\n  status: SpanStatus = {\n    code: SpanStatusCode.UNSET,\n  };\n  endTime: HrTime = [0, 0];\n  private _ended = false;\n  private _duration: HrTime = [-1, -1];\n  private readonly _spanProcessor: SpanProcessor;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _attributeValueLengthLimit: number;\n\n  private readonly _performanceStartTime: number;\n  private readonly _performanceOffset: number;\n  private readonly _startTimeProvided: boolean;\n\n  /**\n   * Constructs a new Span instance.\n   *\n   * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.\n   * */\n  constructor(\n    parentTracer: Tracer,\n    context: Context,\n    spanName: string,\n    spanContext: SpanContext,\n    kind: SpanKind,\n    parentSpanId?: string,\n    links: Link[] = [],\n    startTime?: TimeInput,\n    _deprecatedClock?: unknown, // keeping this argument even though it is unused to ensure backwards compatibility\n    attributes?: SpanAttributes\n  ) {\n    this.name = spanName;\n    this._spanContext = spanContext;\n    this.parentSpanId = parentSpanId;\n    this.kind = kind;\n    this.links = links;\n\n    const now = Date.now();\n    this._performanceStartTime = otperformance.now();\n    this._performanceOffset =\n      now - (this._performanceStartTime + getTimeOrigin());\n    this._startTimeProvided = startTime != null;\n\n    this.startTime = this._getTime(startTime ?? now);\n\n    this.resource = parentTracer.resource;\n    this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n    this._spanLimits = parentTracer.getSpanLimits();\n    this._attributeValueLengthLimit =\n      this._spanLimits.attributeValueLengthLimit || 0;\n\n    if (attributes != null) {\n      this.setAttributes(attributes);\n    }\n\n    this._spanProcessor = parentTracer.getActiveSpanProcessor();\n    this._spanProcessor.onStart(this, context);\n  }\n\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  setAttribute(key: string, value?: SpanAttributeValue): this;\n  setAttribute(key: string, value: unknown): this {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      diag.warn(`Invalid attribute key: ${key}`);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag.warn(`Invalid attribute value set for key: ${key}`);\n      return this;\n    }\n\n    if (\n      Object.keys(this.attributes).length >=\n        this._spanLimits.attributeCountLimit! &&\n      !Object.prototype.hasOwnProperty.call(this.attributes, key)\n    ) {\n      this._droppedAttributesCount++;\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  }\n\n  setAttributes(attributes: SpanAttributes): this {\n    for (const [k, v] of Object.entries(attributes)) {\n      this.setAttribute(k, v);\n    }\n    return this;\n  }\n\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [timeStamp] Specified time stamp for the event\n   */\n  addEvent(\n    name: string,\n    attributesOrStartTime?: SpanAttributes | TimeInput,\n    timeStamp?: TimeInput\n  ): this {\n    if (this._isSpanEnded()) return this;\n    if (this._spanLimits.eventCountLimit === 0) {\n      diag.warn('No events allowed.');\n      this._droppedEventsCount++;\n      return this;\n    }\n    if (this.events.length >= this._spanLimits.eventCountLimit!) {\n      if (this._droppedEventsCount === 0) {\n        diag.debug('Dropping extra events.');\n      }\n      this.events.shift();\n      this._droppedEventsCount++;\n    }\n\n    if (isTimeInput(attributesOrStartTime)) {\n      if (!isTimeInput(timeStamp)) {\n        timeStamp = attributesOrStartTime;\n      }\n      attributesOrStartTime = undefined;\n    }\n\n    const attributes = sanitizeAttributes(attributesOrStartTime);\n\n    this.events.push({\n      name,\n      attributes,\n      time: this._getTime(timeStamp),\n      droppedAttributesCount: 0,\n    });\n    return this;\n  }\n\n  setStatus(status: SpanStatus): this {\n    if (this._isSpanEnded()) return this;\n    this.status = status;\n    return this;\n  }\n\n  updateName(name: string): this {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  }\n\n  end(endTime?: TimeInput): void {\n    if (this._isSpanEnded()) {\n      diag.error(\n        `${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`\n      );\n      return;\n    }\n    this._ended = true;\n\n    this.endTime = this._getTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n\n    if (this._duration[0] < 0) {\n      diag.warn(\n        'Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.',\n        this.startTime,\n        this.endTime\n      );\n      this.endTime = this.startTime.slice() as HrTime;\n      this._duration = [0, 0];\n    }\n\n    if (this._droppedEventsCount > 0) {\n      diag.warn(\n        `Dropped ${this._droppedEventsCount} events because eventCountLimit reached`\n      );\n    }\n\n    this._spanProcessor.onEnd(this);\n  }\n\n  private _getTime(inp?: TimeInput): HrTime {\n    if (typeof inp === 'number' && inp < otperformance.now()) {\n      // must be a performance timestamp\n      // apply correction and convert to hrtime\n      return hrTime(inp + this._performanceOffset);\n    }\n\n    if (typeof inp === 'number') {\n      return millisToHrTime(inp);\n    }\n\n    if (inp instanceof Date) {\n      return millisToHrTime(inp.getTime());\n    }\n\n    if (isTimeInputHrTime(inp)) {\n      return inp;\n    }\n\n    if (this._startTimeProvided) {\n      // if user provided a time for the start manually\n      // we can't use duration to calculate event/end times\n      return millisToHrTime(Date.now());\n    }\n\n    const msDuration = otperformance.now() - this._performanceStartTime;\n    return addHrTimes(this.startTime, millisToHrTime(msDuration));\n  }\n\n  isRecording(): boolean {\n    return this._ended === false;\n  }\n\n  recordException(exception: Exception, time?: TimeInput): void {\n    const attributes: SpanAttributes = {};\n    if (typeof exception === 'string') {\n      attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] =\n          exception.code.toString();\n      } else if (exception.name) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n\n    // these are minimum requirements from spec\n    if (\n      attributes[SemanticAttributes.EXCEPTION_TYPE] ||\n      attributes[SemanticAttributes.EXCEPTION_MESSAGE]\n    ) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag.warn(`Failed to record an exception ${exception}`);\n    }\n  }\n\n  get duration(): HrTime {\n    return this._duration;\n  }\n\n  get ended(): boolean {\n    return this._ended;\n  }\n\n  get droppedAttributesCount(): number {\n    return this._droppedAttributesCount;\n  }\n\n  get droppedEventsCount(): number {\n    return this._droppedEventsCount;\n  }\n\n  get droppedLinksCount(): number {\n    return this._droppedLinksCount;\n  }\n\n  private _isSpanEnded(): boolean {\n    if (this._ended) {\n      diag.warn(\n        `Can not execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`\n      );\n    }\n    return this._ended;\n  }\n\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  private _truncateToLimitUtil(value: string, limit: number): string {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substr(0, limit);\n  }\n\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with trucated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  private _truncateToSize(value: SpanAttributeValue): SpanAttributeValue {\n    const limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      diag.warn(`Attribute value limit must be positive, got ${limit}`);\n      return value;\n    }\n\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n\n    // Array of strings\n    if (Array.isArray(value)) {\n      return (value as []).map(val =>\n        typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val\n      );\n    }\n\n    // Other types, no need to apply value length limit\n    return value;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}