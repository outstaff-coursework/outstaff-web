{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { MappingError } from './types';\n/**\n * LogarithmMapping implements exponential mapping functions for scale > 0.\n * For scales <= 0 the exponent mapping should be used.\n */\nvar LogarithmMapping = /** @class */function () {\n  function LogarithmMapping(scale) {\n    this._scale = scale;\n    this._scaleFactor = util.ldexp(Math.LOG2E, scale);\n    this._inverseFactor = util.ldexp(Math.LN2, -scale);\n  }\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  LogarithmMapping.prototype.mapToIndex = function (value) {\n    if (value <= ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex() - 1;\n    }\n    // exact power of two special case\n    if (ieee754.getSignificand(value) === 0) {\n      var exp = ieee754.getNormalBase2(value);\n      return (exp << this._scale) - 1;\n    }\n    // non-power of two cases. use Math.floor to round the scaled logarithm\n    var index = Math.floor(Math.log(value) * this._scaleFactor);\n    var maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      return maxIndex;\n    }\n    return index;\n  };\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  LogarithmMapping.prototype.lowerBoundary = function (index) {\n    var maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      if (index === maxIndex) {\n        return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);\n      }\n      throw new MappingError(\"overflow: \" + index + \" is > maximum lower boundary: \" + maxIndex);\n    }\n    var minIndex = this._minNormalLowerBoundaryIndex();\n    if (index <= minIndex) {\n      if (index === minIndex) {\n        return ieee754.MIN_VALUE;\n      } else if (index === minIndex - 1) {\n        return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;\n      }\n      throw new MappingError(\"overflow: \" + index + \" is < minimum lower boundary: \" + minIndex);\n    }\n    return Math.exp(index * this._inverseFactor);\n  };\n  Object.defineProperty(LogarithmMapping.prototype, \"scale\", {\n    /**\n     * The scale used by this mapping\n     * @returns {number}\n     */\n    get: function () {\n      return this._scale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  LogarithmMapping.prototype._minNormalLowerBoundaryIndex = function () {\n    return ieee754.MIN_NORMAL_EXPONENT << this._scale;\n  };\n  LogarithmMapping.prototype._maxNormalLowerBoundaryIndex = function () {\n    return (ieee754.MAX_NORMAL_EXPONENT + 1 << this._scale) - 1;\n  };\n  return LogarithmMapping;\n}();\nexport { LogarithmMapping };","map":{"version":3,"names":["ieee754","util","MappingError","LogarithmMapping","scale","_scale","_scaleFactor","ldexp","Math","LOG2E","_inverseFactor","LN2","prototype","mapToIndex","value","MIN_VALUE","_minNormalLowerBoundaryIndex","getSignificand","exp","getNormalBase2","index","floor","log","maxIndex","_maxNormalLowerBoundaryIndex","lowerBoundary","minIndex","Object","defineProperty","get","MIN_NORMAL_EXPONENT","MAX_NORMAL_EXPONENT"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/LogarithmMapping.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { Mapping, MappingError } from './types';\n\n/**\n * LogarithmMapping implements exponential mapping functions for scale > 0.\n * For scales <= 0 the exponent mapping should be used.\n */\nexport class LogarithmMapping implements Mapping {\n  private readonly _scale: number;\n  private readonly _scaleFactor: number;\n  private readonly _inverseFactor: number;\n\n  constructor(scale: number) {\n    this._scale = scale;\n    this._scaleFactor = util.ldexp(Math.LOG2E, scale);\n    this._inverseFactor = util.ldexp(Math.LN2, -scale);\n  }\n\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  mapToIndex(value: number): number {\n    if (value <= ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex() - 1;\n    }\n\n    // exact power of two special case\n    if (ieee754.getSignificand(value) === 0) {\n      const exp = ieee754.getNormalBase2(value);\n      return (exp << this._scale) - 1;\n    }\n\n    // non-power of two cases. use Math.floor to round the scaled logarithm\n    const index = Math.floor(Math.log(value) * this._scaleFactor);\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      return maxIndex;\n    }\n\n    return index;\n  }\n\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  lowerBoundary(index: number): number {\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      if (index === maxIndex) {\n        return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);\n      }\n      throw new MappingError(\n        `overflow: ${index} is > maximum lower boundary: ${maxIndex}`\n      );\n    }\n\n    const minIndex = this._minNormalLowerBoundaryIndex();\n    if (index <= minIndex) {\n      if (index === minIndex) {\n        return ieee754.MIN_VALUE;\n      } else if (index === minIndex - 1) {\n        return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;\n      }\n      throw new MappingError(\n        `overflow: ${index} is < minimum lower boundary: ${minIndex}`\n      );\n    }\n\n    return Math.exp(index * this._inverseFactor);\n  }\n\n  /**\n   * The scale used by this mapping\n   * @returns {number}\n   */\n  get scale(): number {\n    return this._scale;\n  }\n\n  private _minNormalLowerBoundaryIndex(): number {\n    return ieee754.MIN_NORMAL_EXPONENT << this._scale;\n  }\n\n  private _maxNormalLowerBoundaryIndex(): number {\n    return ((ieee754.MAX_NORMAL_EXPONENT + 1) << this._scale) - 1;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}