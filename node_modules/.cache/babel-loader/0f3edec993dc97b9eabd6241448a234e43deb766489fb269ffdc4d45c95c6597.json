{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { getOtlpEncoder } from '../common';\nimport { toAnyValue, toAttributes, toKeyValue } from '../common/internal';\nexport function createExportLogsServiceRequest(logRecords, options) {\n  var encoder = getOtlpEncoder(options);\n  return {\n    resourceLogs: logRecordsToResourceLogs(logRecords, encoder)\n  };\n}\nfunction createResourceMap(logRecords) {\n  var e_1, _a;\n  var resourceMap = new Map();\n  try {\n    for (var logRecords_1 = __values(logRecords), logRecords_1_1 = logRecords_1.next(); !logRecords_1_1.done; logRecords_1_1 = logRecords_1.next()) {\n      var record = logRecords_1_1.value;\n      var resource = record.resource,\n        _b = record.instrumentationScope,\n        name_1 = _b.name,\n        _c = _b.version,\n        version = _c === void 0 ? '' : _c,\n        _d = _b.schemaUrl,\n        schemaUrl = _d === void 0 ? '' : _d;\n      var ismMap = resourceMap.get(resource);\n      if (!ismMap) {\n        ismMap = new Map();\n        resourceMap.set(resource, ismMap);\n      }\n      var ismKey = name_1 + \"@\" + version + \":\" + schemaUrl;\n      var records = ismMap.get(ismKey);\n      if (!records) {\n        records = [];\n        ismMap.set(ismKey, records);\n      }\n      records.push(record);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (logRecords_1_1 && !logRecords_1_1.done && (_a = logRecords_1.return)) _a.call(logRecords_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return resourceMap;\n}\nfunction logRecordsToResourceLogs(logRecords, encoder) {\n  var resourceMap = createResourceMap(logRecords);\n  return Array.from(resourceMap, function (_a) {\n    var _b = __read(_a, 2),\n      resource = _b[0],\n      ismMap = _b[1];\n    return {\n      resource: {\n        attributes: toAttributes(resource.attributes),\n        droppedAttributesCount: 0\n      },\n      scopeLogs: Array.from(ismMap, function (_a) {\n        var _b = __read(_a, 2),\n          scopeLogs = _b[1];\n        var _c = scopeLogs[0].instrumentationScope,\n          name = _c.name,\n          version = _c.version,\n          schemaUrl = _c.schemaUrl;\n        return {\n          scope: {\n            name: name,\n            version: version\n          },\n          logRecords: scopeLogs.map(function (log) {\n            return toLogRecord(log, encoder);\n          }),\n          schemaUrl: schemaUrl\n        };\n      }),\n      schemaUrl: undefined\n    };\n  });\n}\nfunction toLogRecord(log, encoder) {\n  var _a, _b, _c;\n  return {\n    timeUnixNano: encoder.encodeHrTime(log.hrTime),\n    observedTimeUnixNano: encoder.encodeHrTime(log.hrTimeObserved),\n    severityNumber: toSeverityNumber(log.severityNumber),\n    severityText: log.severityText,\n    body: toAnyValue(log.body),\n    attributes: toLogAttributes(log.attributes),\n    droppedAttributesCount: log.droppedAttributesCount,\n    flags: (_a = log.spanContext) === null || _a === void 0 ? void 0 : _a.traceFlags,\n    traceId: encoder.encodeOptionalSpanContext((_b = log.spanContext) === null || _b === void 0 ? void 0 : _b.traceId),\n    spanId: encoder.encodeOptionalSpanContext((_c = log.spanContext) === null || _c === void 0 ? void 0 : _c.spanId)\n  };\n}\nfunction toSeverityNumber(severityNumber) {\n  return severityNumber;\n}\nexport function toLogAttributes(attributes) {\n  return Object.keys(attributes).map(function (key) {\n    return toKeyValue(key, attributes[key]);\n  });\n}","map":{"version":3,"names":["getOtlpEncoder","toAnyValue","toAttributes","toKeyValue","createExportLogsServiceRequest","logRecords","options","encoder","resourceLogs","logRecordsToResourceLogs","createResourceMap","resourceMap","Map","logRecords_1","__values","logRecords_1_1","next","done","record","value","resource","_b","instrumentationScope","name_1","name","_c","version","_d","schemaUrl","ismMap","get","set","ismKey","records","push","Array","from","_a","__read","attributes","droppedAttributesCount","scopeLogs","scope","map","log","toLogRecord","undefined","timeUnixNano","encodeHrTime","hrTime","observedTimeUnixNano","hrTimeObserved","severityNumber","toSeverityNumber","severityText","body","toLogAttributes","flags","spanContext","traceFlags","traceId","encodeOptionalSpanContext","spanId","Object","keys","key"],"sources":["/home/egor/node_modules/@opentelemetry/otlp-transformer/src/logs/index.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ReadableLogRecord } from '@opentelemetry/sdk-logs';\nimport {\n  ESeverityNumber,\n  IExportLogsServiceRequest,\n  ILogRecord,\n  IResourceLogs,\n} from './types';\nimport { IResource } from '@opentelemetry/resources';\nimport { Encoder, getOtlpEncoder } from '../common';\nimport { toAnyValue, toAttributes, toKeyValue } from '../common/internal';\nimport { SeverityNumber } from '@opentelemetry/api-logs';\nimport { OtlpEncodingOptions, IKeyValue } from '../common/types';\nimport { LogAttributes } from '@opentelemetry/api-logs';\n\nexport function createExportLogsServiceRequest(\n  logRecords: ReadableLogRecord[],\n  options?: OtlpEncodingOptions\n): IExportLogsServiceRequest {\n  const encoder = getOtlpEncoder(options);\n  return {\n    resourceLogs: logRecordsToResourceLogs(logRecords, encoder),\n  };\n}\n\nfunction createResourceMap(\n  logRecords: ReadableLogRecord[]\n): Map<IResource, Map<string, ReadableLogRecord[]>> {\n  const resourceMap: Map<\n    IResource,\n    Map<string, ReadableLogRecord[]>\n  > = new Map();\n\n  for (const record of logRecords) {\n    const {\n      resource,\n      instrumentationScope: { name, version = '', schemaUrl = '' },\n    } = record;\n\n    let ismMap = resourceMap.get(resource);\n    if (!ismMap) {\n      ismMap = new Map();\n      resourceMap.set(resource, ismMap);\n    }\n\n    const ismKey = `${name}@${version}:${schemaUrl}`;\n    let records = ismMap.get(ismKey);\n    if (!records) {\n      records = [];\n      ismMap.set(ismKey, records);\n    }\n    records.push(record);\n  }\n  return resourceMap;\n}\n\nfunction logRecordsToResourceLogs(\n  logRecords: ReadableLogRecord[],\n  encoder: Encoder\n): IResourceLogs[] {\n  const resourceMap = createResourceMap(logRecords);\n  return Array.from(resourceMap, ([resource, ismMap]) => ({\n    resource: {\n      attributes: toAttributes(resource.attributes),\n      droppedAttributesCount: 0,\n    },\n    scopeLogs: Array.from(ismMap, ([, scopeLogs]) => {\n      const {\n        instrumentationScope: { name, version, schemaUrl },\n      } = scopeLogs[0];\n      return {\n        scope: { name, version },\n        logRecords: scopeLogs.map(log => toLogRecord(log, encoder)),\n        schemaUrl,\n      };\n    }),\n    schemaUrl: undefined,\n  }));\n}\n\nfunction toLogRecord(log: ReadableLogRecord, encoder: Encoder): ILogRecord {\n  return {\n    timeUnixNano: encoder.encodeHrTime(log.hrTime),\n    observedTimeUnixNano: encoder.encodeHrTime(log.hrTimeObserved),\n    severityNumber: toSeverityNumber(log.severityNumber),\n    severityText: log.severityText,\n    body: toAnyValue(log.body),\n    attributes: toLogAttributes(log.attributes),\n    droppedAttributesCount: log.droppedAttributesCount,\n    flags: log.spanContext?.traceFlags,\n    traceId: encoder.encodeOptionalSpanContext(log.spanContext?.traceId),\n    spanId: encoder.encodeOptionalSpanContext(log.spanContext?.spanId),\n  };\n}\n\nfunction toSeverityNumber(\n  severityNumber: SeverityNumber | undefined\n): ESeverityNumber | undefined {\n  return severityNumber as number | undefined as ESeverityNumber | undefined;\n}\n\nexport function toLogAttributes(attributes: LogAttributes): IKeyValue[] {\n  return Object.keys(attributes).map(key => toKeyValue(key, attributes[key]));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}