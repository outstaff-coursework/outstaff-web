{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport * as api from '@opentelemetry/api';\nimport { isWrapped, InstrumentationBase, safeExecuteInTheMiddle } from '@opentelemetry/instrumentation';\nimport { hrTime, isUrlIgnored, otperformance } from '@opentelemetry/core';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { addSpanNetworkEvents, getResource, PerformanceTimingNames as PTN, shouldPropagateTraceHeaders, parseUrl } from '@opentelemetry/sdk-trace-web';\nimport { EventNames } from './enums/EventNames';\nimport { VERSION } from './version';\nimport { AttributeNames } from './enums/AttributeNames';\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nvar OBSERVER_WAIT_TIME_MS = 300;\n/**\n * This class represents a XMLHttpRequest plugin for auto instrumentation\n */\nvar XMLHttpRequestInstrumentation = /** @class */function (_super) {\n  __extends(XMLHttpRequestInstrumentation, _super);\n  function XMLHttpRequestInstrumentation(config) {\n    var _this = _super.call(this, '@opentelemetry/instrumentation-xml-http-request', VERSION, config) || this;\n    _this.component = 'xml-http-request';\n    _this.version = VERSION;\n    _this.moduleName = _this.component;\n    _this._tasksCount = 0;\n    _this._xhrMem = new WeakMap();\n    _this._usedResources = new WeakSet();\n    return _this;\n  }\n  XMLHttpRequestInstrumentation.prototype.init = function () {};\n  XMLHttpRequestInstrumentation.prototype._getConfig = function () {\n    return this._config;\n  };\n  /**\n   * Adds custom headers to XMLHttpRequest\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._addHeaders = function (xhr, spanUrl) {\n    var url = parseUrl(spanUrl).href;\n    if (!shouldPropagateTraceHeaders(url, this._getConfig().propagateTraceHeaderCorsUrls)) {\n      var headers_1 = {};\n      api.propagation.inject(api.context.active(), headers_1);\n      if (Object.keys(headers_1).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n    var headers = {};\n    api.propagation.inject(api.context.active(), headers);\n    Object.keys(headers).forEach(function (key) {\n      xhr.setRequestHeader(key, String(headers[key]));\n    });\n  };\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._addChildSpan = function (span, corsPreFlightRequest) {\n    var _this = this;\n    api.context.with(api.trace.setSpan(api.context.active(), span), function () {\n      var childSpan = _this.tracer.startSpan('CORS Preflight', {\n        startTime: corsPreFlightRequest[PTN.FETCH_START]\n      });\n      addSpanNetworkEvents(childSpan, corsPreFlightRequest);\n      childSpan.end(corsPreFlightRequest[PTN.RESPONSE_END]);\n    });\n  };\n  /**\n   * Add attributes when span is going to end\n   * @param span\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._addFinalSpanAttributes = function (span, xhrMem, spanUrl) {\n    if (typeof spanUrl === 'string') {\n      var parsedUrl = parseUrl(spanUrl);\n      if (xhrMem.status !== undefined) {\n        span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, xhrMem.status);\n      }\n      if (xhrMem.statusText !== undefined) {\n        span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, xhrMem.statusText);\n      }\n      span.setAttribute(SemanticAttributes.HTTP_HOST, parsedUrl.host);\n      span.setAttribute(SemanticAttributes.HTTP_SCHEME, parsedUrl.protocol.replace(':', ''));\n      // @TODO do we want to collect this or it will be collected earlier once only or\n      //    maybe when parent span is not available ?\n      span.setAttribute(SemanticAttributes.HTTP_USER_AGENT, navigator.userAgent);\n    }\n  };\n  XMLHttpRequestInstrumentation.prototype._applyAttributesAfterXHR = function (span, xhr) {\n    var _this = this;\n    var applyCustomAttributesOnSpan = this._getConfig().applyCustomAttributesOnSpan;\n    if (typeof applyCustomAttributesOnSpan === 'function') {\n      safeExecuteInTheMiddle(function () {\n        return applyCustomAttributesOnSpan(span, xhr);\n      }, function (error) {\n        if (!error) {\n          return;\n        }\n        _this._diag.error('applyCustomAttributesOnSpan', error);\n      }, true);\n    }\n  };\n  /**\n   * will collect information about all resources created\n   * between \"send\" and \"end\" with additional waiting for main resource\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._addResourceObserver = function (xhr, spanUrl) {\n    var xhrMem = this._xhrMem.get(xhr);\n    if (!xhrMem || typeof PerformanceObserver !== 'function' || typeof PerformanceResourceTiming !== 'function') {\n      return;\n    }\n    xhrMem.createdResources = {\n      observer: new PerformanceObserver(function (list) {\n        var entries = list.getEntries();\n        var parsedUrl = parseUrl(spanUrl);\n        entries.forEach(function (entry) {\n          if (entry.initiatorType === 'xmlhttprequest' && entry.name === parsedUrl.href) {\n            if (xhrMem.createdResources) {\n              xhrMem.createdResources.entries.push(entry);\n            }\n          }\n        });\n      }),\n      entries: []\n    };\n    xhrMem.createdResources.observer.observe({\n      entryTypes: ['resource']\n    });\n  };\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link XMLHttpRequestInstrumentationConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._clearResources = function () {\n    if (this._tasksCount === 0 && this._getConfig().clearTimingResources) {\n      otperformance.clearResourceTimings();\n      this._xhrMem = new WeakMap();\n      this._usedResources = new WeakSet();\n    }\n  };\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   */\n  XMLHttpRequestInstrumentation.prototype._findResourceAndAddNetworkEvents = function (xhrMem, span, spanUrl, startTime, endTime) {\n    if (!spanUrl || !startTime || !endTime || !xhrMem.createdResources) {\n      return;\n    }\n    var resources = xhrMem.createdResources.entries;\n    if (!resources || !resources.length) {\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      // ts thinks this is the perf_hooks module, but it is the browser performance api\n      resources = otperformance.getEntriesByType('resource');\n    }\n    var resource = getResource(parseUrl(spanUrl).href, startTime, endTime, resources, this._usedResources);\n    if (resource.mainRequest) {\n      var mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n      var corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      addSpanNetworkEvents(span, mainRequest);\n    }\n  };\n  /**\n   * Removes the previous information about span.\n   * This might happened when the same xhr is used again.\n   * @param xhr\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._cleanPreviousSpanInformation = function (xhr) {\n    var xhrMem = this._xhrMem.get(xhr);\n    if (xhrMem) {\n      var callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n      if (callbackToRemoveEvents) {\n        callbackToRemoveEvents();\n      }\n      this._xhrMem.delete(xhr);\n    }\n  };\n  /**\n   * Creates a new span when method \"open\" is called\n   * @param xhr\n   * @param url\n   * @param method\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._createSpan = function (xhr, url, method) {\n    var _a;\n    if (isUrlIgnored(url, this._getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n    var spanName = method.toUpperCase();\n    var currentSpan = this.tracer.startSpan(spanName, {\n      kind: api.SpanKind.CLIENT,\n      attributes: (_a = {}, _a[SemanticAttributes.HTTP_METHOD] = method, _a[SemanticAttributes.HTTP_URL] = parseUrl(url).toString(), _a)\n    });\n    currentSpan.addEvent(EventNames.METHOD_OPEN);\n    this._cleanPreviousSpanInformation(xhr);\n    this._xhrMem.set(xhr, {\n      span: currentSpan,\n      spanUrl: url\n    });\n    return currentSpan;\n  };\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._markResourceAsUsed = function (resource) {\n    this._usedResources.add(resource);\n  };\n  /**\n   * Patches the method open\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._patchOpen = function () {\n    var _this = this;\n    return function (original) {\n      var plugin = _this;\n      return function patchOpen() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var method = args[0];\n        var url = args[1];\n        plugin._createSpan(this, url, method);\n        return original.apply(this, args);\n      };\n    };\n  };\n  /**\n   * Patches the method send\n   * @private\n   */\n  XMLHttpRequestInstrumentation.prototype._patchSend = function () {\n    var plugin = this;\n    function endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime) {\n      var callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n      if (typeof callbackToRemoveEvents === 'function') {\n        callbackToRemoveEvents();\n      }\n      var span = xhrMem.span,\n        spanUrl = xhrMem.spanUrl,\n        sendStartTime = xhrMem.sendStartTime;\n      if (span) {\n        plugin._findResourceAndAddNetworkEvents(xhrMem, span, spanUrl, sendStartTime, performanceEndTime);\n        span.addEvent(eventName, endTime);\n        plugin._addFinalSpanAttributes(span, xhrMem, spanUrl);\n        span.end(endTime);\n        plugin._tasksCount--;\n      }\n      plugin._clearResources();\n    }\n    function endSpan(eventName, xhr) {\n      var xhrMem = plugin._xhrMem.get(xhr);\n      if (!xhrMem) {\n        return;\n      }\n      xhrMem.status = xhr.status;\n      xhrMem.statusText = xhr.statusText;\n      plugin._xhrMem.delete(xhr);\n      if (xhrMem.span) {\n        plugin._applyAttributesAfterXHR(xhrMem.span, xhr);\n      }\n      var performanceEndTime = hrTime();\n      var endTime = Date.now();\n      // the timeout is needed as observer doesn't have yet information\n      // when event \"load\" is called. Also the time may differ depends on\n      // browser and speed of computer\n      setTimeout(function () {\n        endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime);\n      }, OBSERVER_WAIT_TIME_MS);\n    }\n    function onError() {\n      endSpan(EventNames.EVENT_ERROR, this);\n    }\n    function onAbort() {\n      endSpan(EventNames.EVENT_ABORT, this);\n    }\n    function onTimeout() {\n      endSpan(EventNames.EVENT_TIMEOUT, this);\n    }\n    function onLoad() {\n      if (this.status < 299) {\n        endSpan(EventNames.EVENT_LOAD, this);\n      } else {\n        endSpan(EventNames.EVENT_ERROR, this);\n      }\n    }\n    function unregister(xhr) {\n      xhr.removeEventListener('abort', onAbort);\n      xhr.removeEventListener('error', onError);\n      xhr.removeEventListener('load', onLoad);\n      xhr.removeEventListener('timeout', onTimeout);\n      var xhrMem = plugin._xhrMem.get(xhr);\n      if (xhrMem) {\n        xhrMem.callbackToRemoveEvents = undefined;\n      }\n    }\n    return function (original) {\n      return function patchSend() {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var xhrMem = plugin._xhrMem.get(this);\n        if (!xhrMem) {\n          return original.apply(this, args);\n        }\n        var currentSpan = xhrMem.span;\n        var spanUrl = xhrMem.spanUrl;\n        if (currentSpan && spanUrl) {\n          api.context.with(api.trace.setSpan(api.context.active(), currentSpan), function () {\n            plugin._tasksCount++;\n            xhrMem.sendStartTime = hrTime();\n            currentSpan.addEvent(EventNames.METHOD_SEND);\n            _this.addEventListener('abort', onAbort);\n            _this.addEventListener('error', onError);\n            _this.addEventListener('load', onLoad);\n            _this.addEventListener('timeout', onTimeout);\n            xhrMem.callbackToRemoveEvents = function () {\n              unregister(_this);\n              if (xhrMem.createdResources) {\n                xhrMem.createdResources.observer.disconnect();\n              }\n            };\n            plugin._addHeaders(_this, spanUrl);\n            plugin._addResourceObserver(_this, spanUrl);\n          });\n        }\n        return original.apply(this, args);\n      };\n    };\n  };\n  /**\n   * implements enable function\n   */\n  XMLHttpRequestInstrumentation.prototype.enable = function () {\n    this._diag.debug('applying patch to', this.moduleName, this.version);\n    if (isWrapped(XMLHttpRequest.prototype.open)) {\n      this._unwrap(XMLHttpRequest.prototype, 'open');\n      this._diag.debug('removing previous patch from method open');\n    }\n    if (isWrapped(XMLHttpRequest.prototype.send)) {\n      this._unwrap(XMLHttpRequest.prototype, 'send');\n      this._diag.debug('removing previous patch from method send');\n    }\n    this._wrap(XMLHttpRequest.prototype, 'open', this._patchOpen());\n    this._wrap(XMLHttpRequest.prototype, 'send', this._patchSend());\n  };\n  /**\n   * implements disable function\n   */\n  XMLHttpRequestInstrumentation.prototype.disable = function () {\n    this._diag.debug('removing patch from', this.moduleName, this.version);\n    this._unwrap(XMLHttpRequest.prototype, 'open');\n    this._unwrap(XMLHttpRequest.prototype, 'send');\n    this._tasksCount = 0;\n    this._xhrMem = new WeakMap();\n    this._usedResources = new WeakSet();\n  };\n  return XMLHttpRequestInstrumentation;\n}(InstrumentationBase);\nexport { XMLHttpRequestInstrumentation };","map":{"version":3,"names":["api","isWrapped","InstrumentationBase","safeExecuteInTheMiddle","hrTime","isUrlIgnored","otperformance","SemanticAttributes","addSpanNetworkEvents","getResource","PerformanceTimingNames","PTN","shouldPropagateTraceHeaders","parseUrl","EventNames","VERSION","AttributeNames","OBSERVER_WAIT_TIME_MS","XMLHttpRequestInstrumentation","_super","__extends","config","_this","call","component","version","moduleName","_tasksCount","_xhrMem","WeakMap","_usedResources","WeakSet","prototype","init","_getConfig","_config","_addHeaders","xhr","spanUrl","url","href","propagateTraceHeaderCorsUrls","headers_1","propagation","inject","context","active","Object","keys","length","_diag","debug","headers","forEach","key","setRequestHeader","String","_addChildSpan","span","corsPreFlightRequest","with","trace","setSpan","childSpan","tracer","startSpan","startTime","FETCH_START","end","RESPONSE_END","_addFinalSpanAttributes","xhrMem","parsedUrl","status","undefined","setAttribute","HTTP_STATUS_CODE","statusText","HTTP_STATUS_TEXT","HTTP_HOST","host","HTTP_SCHEME","protocol","replace","HTTP_USER_AGENT","navigator","userAgent","_applyAttributesAfterXHR","applyCustomAttributesOnSpan","error","_addResourceObserver","get","PerformanceObserver","PerformanceResourceTiming","createdResources","observer","list","entries","getEntries","entry","initiatorType","name","push","observe","entryTypes","_clearResources","clearTimingResources","clearResourceTimings","_findResourceAndAddNetworkEvents","endTime","resources","getEntriesByType","resource","mainRequest","_markResourceAsUsed","_cleanPreviousSpanInformation","callbackToRemoveEvents","delete","_createSpan","method","ignoreUrls","spanName","toUpperCase","currentSpan","kind","SpanKind","CLIENT","attributes","_a","HTTP_METHOD","HTTP_URL","toString","addEvent","METHOD_OPEN","set","add","_patchOpen","original","plugin","patchOpen","args","_i","arguments","apply","_patchSend","endSpanTimeout","eventName","performanceEndTime","sendStartTime","endSpan","Date","now","setTimeout","onError","EVENT_ERROR","onAbort","EVENT_ABORT","onTimeout","EVENT_TIMEOUT","onLoad","EVENT_LOAD","unregister","removeEventListener","patchSend","METHOD_SEND","addEventListener","disconnect","enable","XMLHttpRequest","open","_unwrap","send","_wrap","disable"],"sources":["/home/egor/node_modules/@opentelemetry/instrumentation-xml-http-request/src/xhr.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  isWrapped,\n  InstrumentationBase,\n  InstrumentationConfig,\n  safeExecuteInTheMiddle,\n} from '@opentelemetry/instrumentation';\nimport { hrTime, isUrlIgnored, otperformance } from '@opentelemetry/core';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport {\n  addSpanNetworkEvents,\n  getResource,\n  PerformanceTimingNames as PTN,\n  shouldPropagateTraceHeaders,\n  parseUrl,\n} from '@opentelemetry/sdk-trace-web';\nimport { EventNames } from './enums/EventNames';\nimport {\n  OpenFunction,\n  PropagateTraceHeaderCorsUrls,\n  SendFunction,\n  XhrMem,\n} from './types';\nimport { VERSION } from './version';\nimport { AttributeNames } from './enums/AttributeNames';\n\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nconst OBSERVER_WAIT_TIME_MS = 300;\n\nexport type XHRCustomAttributeFunction = (\n  span: api.Span,\n  xhr: XMLHttpRequest\n) => void;\n\n/**\n * XMLHttpRequest config\n */\nexport interface XMLHttpRequestInstrumentationConfig\n  extends InstrumentationConfig {\n  /**\n   * The number of timing resources is limited, after the limit\n   * (chrome 250, safari 150) the information is not collected anymore.\n   * The only way to prevent that is to regularly clean the resources\n   * whenever it is possible. This is needed only when PerformanceObserver\n   * is not available\n   */\n  clearTimingResources?: boolean;\n  /** URLs which should include trace headers when origin doesn't match */\n  propagateTraceHeaderCorsUrls?: PropagateTraceHeaderCorsUrls;\n  /**\n   * URLs that partially match any regex in ignoreUrls will not be traced.\n   * In addition, URLs that are _exact matches_ of strings in ignoreUrls will\n   * also not be traced.\n   */\n  ignoreUrls?: Array<string | RegExp>;\n  /** Function for adding custom attributes on the span */\n  applyCustomAttributesOnSpan?: XHRCustomAttributeFunction;\n}\n\n/**\n * This class represents a XMLHttpRequest plugin for auto instrumentation\n */\nexport class XMLHttpRequestInstrumentation extends InstrumentationBase<XMLHttpRequest> {\n  readonly component: string = 'xml-http-request';\n  readonly version: string = VERSION;\n  moduleName = this.component;\n\n  private _tasksCount = 0;\n  private _xhrMem = new WeakMap<XMLHttpRequest, XhrMem>();\n  private _usedResources = new WeakSet<PerformanceResourceTiming>();\n\n  constructor(config?: XMLHttpRequestInstrumentationConfig) {\n    super('@opentelemetry/instrumentation-xml-http-request', VERSION, config);\n  }\n\n  init() {}\n\n  private _getConfig(): XMLHttpRequestInstrumentationConfig {\n    return this._config;\n  }\n\n  /**\n   * Adds custom headers to XMLHttpRequest\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  private _addHeaders(xhr: XMLHttpRequest, spanUrl: string) {\n    const url = parseUrl(spanUrl).href;\n    if (\n      !shouldPropagateTraceHeaders(\n        url,\n        this._getConfig().propagateTraceHeaderCorsUrls\n      )\n    ) {\n      const headers: Partial<Record<string, unknown>> = {};\n      api.propagation.inject(api.context.active(), headers);\n      if (Object.keys(headers).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n    const headers: { [key: string]: unknown } = {};\n    api.propagation.inject(api.context.active(), headers);\n    Object.keys(headers).forEach(key => {\n      xhr.setRequestHeader(key, String(headers[key]));\n    });\n  }\n\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   * @private\n   */\n  private _addChildSpan(\n    span: api.Span,\n    corsPreFlightRequest: PerformanceResourceTiming\n  ): void {\n    api.context.with(api.trace.setSpan(api.context.active(), span), () => {\n      const childSpan = this.tracer.startSpan('CORS Preflight', {\n        startTime: corsPreFlightRequest[PTN.FETCH_START],\n      });\n      addSpanNetworkEvents(childSpan, corsPreFlightRequest);\n      childSpan.end(corsPreFlightRequest[PTN.RESPONSE_END]);\n    });\n  }\n\n  /**\n   * Add attributes when span is going to end\n   * @param span\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  _addFinalSpanAttributes(span: api.Span, xhrMem: XhrMem, spanUrl?: string) {\n    if (typeof spanUrl === 'string') {\n      const parsedUrl = parseUrl(spanUrl);\n      if (xhrMem.status !== undefined) {\n        span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, xhrMem.status);\n      }\n      if (xhrMem.statusText !== undefined) {\n        span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, xhrMem.statusText);\n      }\n      span.setAttribute(SemanticAttributes.HTTP_HOST, parsedUrl.host);\n      span.setAttribute(\n        SemanticAttributes.HTTP_SCHEME,\n        parsedUrl.protocol.replace(':', '')\n      );\n\n      // @TODO do we want to collect this or it will be collected earlier once only or\n      //    maybe when parent span is not available ?\n      span.setAttribute(\n        SemanticAttributes.HTTP_USER_AGENT,\n        navigator.userAgent\n      );\n    }\n  }\n\n  private _applyAttributesAfterXHR(span: api.Span, xhr: XMLHttpRequest) {\n    const applyCustomAttributesOnSpan =\n      this._getConfig().applyCustomAttributesOnSpan;\n    if (typeof applyCustomAttributesOnSpan === 'function') {\n      safeExecuteInTheMiddle(\n        () => applyCustomAttributesOnSpan(span, xhr),\n        error => {\n          if (!error) {\n            return;\n          }\n\n          this._diag.error('applyCustomAttributesOnSpan', error);\n        },\n        true\n      );\n    }\n  }\n\n  /**\n   * will collect information about all resources created\n   * between \"send\" and \"end\" with additional waiting for main resource\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  private _addResourceObserver(xhr: XMLHttpRequest, spanUrl: string) {\n    const xhrMem = this._xhrMem.get(xhr);\n    if (\n      !xhrMem ||\n      typeof PerformanceObserver !== 'function' ||\n      typeof PerformanceResourceTiming !== 'function'\n    ) {\n      return;\n    }\n    xhrMem.createdResources = {\n      observer: new PerformanceObserver(list => {\n        const entries = list.getEntries() as PerformanceResourceTiming[];\n        const parsedUrl = parseUrl(spanUrl);\n\n        entries.forEach(entry => {\n          if (\n            entry.initiatorType === 'xmlhttprequest' &&\n            entry.name === parsedUrl.href\n          ) {\n            if (xhrMem.createdResources) {\n              xhrMem.createdResources.entries.push(entry);\n            }\n          }\n        });\n      }),\n      entries: [],\n    };\n    xhrMem.createdResources.observer.observe({\n      entryTypes: ['resource'],\n    });\n  }\n\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link XMLHttpRequestInstrumentationConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  private _clearResources() {\n    if (this._tasksCount === 0 && this._getConfig().clearTimingResources) {\n      (otperformance as unknown as Performance).clearResourceTimings();\n      this._xhrMem = new WeakMap<XMLHttpRequest, XhrMem>();\n      this._usedResources = new WeakSet<PerformanceResourceTiming>();\n    }\n  }\n\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   */\n  private _findResourceAndAddNetworkEvents(\n    xhrMem: XhrMem,\n    span: api.Span,\n    spanUrl?: string,\n    startTime?: api.HrTime,\n    endTime?: api.HrTime\n  ): void {\n    if (!spanUrl || !startTime || !endTime || !xhrMem.createdResources) {\n      return;\n    }\n\n    let resources: PerformanceResourceTiming[] =\n      xhrMem.createdResources.entries;\n\n    if (!resources || !resources.length) {\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      // ts thinks this is the perf_hooks module, but it is the browser performance api\n      resources = (otperformance as unknown as Performance).getEntriesByType(\n        'resource'\n      ) as PerformanceResourceTiming[];\n    }\n\n    const resource = getResource(\n      parseUrl(spanUrl).href,\n      startTime,\n      endTime,\n      resources,\n      this._usedResources\n    );\n\n    if (resource.mainRequest) {\n      const mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n\n      const corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      addSpanNetworkEvents(span, mainRequest);\n    }\n  }\n\n  /**\n   * Removes the previous information about span.\n   * This might happened when the same xhr is used again.\n   * @param xhr\n   * @private\n   */\n  private _cleanPreviousSpanInformation(xhr: XMLHttpRequest) {\n    const xhrMem = this._xhrMem.get(xhr);\n    if (xhrMem) {\n      const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n      if (callbackToRemoveEvents) {\n        callbackToRemoveEvents();\n      }\n      this._xhrMem.delete(xhr);\n    }\n  }\n\n  /**\n   * Creates a new span when method \"open\" is called\n   * @param xhr\n   * @param url\n   * @param method\n   * @private\n   */\n  private _createSpan(\n    xhr: XMLHttpRequest,\n    url: string,\n    method: string\n  ): api.Span | undefined {\n    if (isUrlIgnored(url, this._getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n    const spanName = method.toUpperCase();\n\n    const currentSpan = this.tracer.startSpan(spanName, {\n      kind: api.SpanKind.CLIENT,\n      attributes: {\n        [SemanticAttributes.HTTP_METHOD]: method,\n        [SemanticAttributes.HTTP_URL]: parseUrl(url).toString(),\n      },\n    });\n\n    currentSpan.addEvent(EventNames.METHOD_OPEN);\n\n    this._cleanPreviousSpanInformation(xhr);\n\n    this._xhrMem.set(xhr, {\n      span: currentSpan,\n      spanUrl: url,\n    });\n\n    return currentSpan;\n  }\n\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   * @private\n   */\n  private _markResourceAsUsed(resource: PerformanceResourceTiming) {\n    this._usedResources.add(resource);\n  }\n\n  /**\n   * Patches the method open\n   * @private\n   */\n  protected _patchOpen() {\n    return (original: OpenFunction): OpenFunction => {\n      const plugin = this;\n      return function patchOpen(this: XMLHttpRequest, ...args): void {\n        const method: string = args[0];\n        const url: string = args[1];\n        plugin._createSpan(this, url, method);\n\n        return original.apply(this, args);\n      };\n    };\n  }\n\n  /**\n   * Patches the method send\n   * @private\n   */\n  protected _patchSend() {\n    const plugin = this;\n\n    function endSpanTimeout(\n      eventName: string,\n      xhrMem: XhrMem,\n      performanceEndTime: api.HrTime,\n      endTime: number\n    ) {\n      const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n\n      if (typeof callbackToRemoveEvents === 'function') {\n        callbackToRemoveEvents();\n      }\n\n      const { span, spanUrl, sendStartTime } = xhrMem;\n\n      if (span) {\n        plugin._findResourceAndAddNetworkEvents(\n          xhrMem,\n          span,\n          spanUrl,\n          sendStartTime,\n          performanceEndTime\n        );\n        span.addEvent(eventName, endTime);\n        plugin._addFinalSpanAttributes(span, xhrMem, spanUrl);\n        span.end(endTime);\n        plugin._tasksCount--;\n      }\n      plugin._clearResources();\n    }\n\n    function endSpan(eventName: string, xhr: XMLHttpRequest) {\n      const xhrMem = plugin._xhrMem.get(xhr);\n      if (!xhrMem) {\n        return;\n      }\n      xhrMem.status = xhr.status;\n      xhrMem.statusText = xhr.statusText;\n      plugin._xhrMem.delete(xhr);\n\n      if (xhrMem.span) {\n        plugin._applyAttributesAfterXHR(xhrMem.span, xhr);\n      }\n      const performanceEndTime = hrTime();\n      const endTime = Date.now();\n\n      // the timeout is needed as observer doesn't have yet information\n      // when event \"load\" is called. Also the time may differ depends on\n      // browser and speed of computer\n      setTimeout(() => {\n        endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime);\n      }, OBSERVER_WAIT_TIME_MS);\n    }\n\n    function onError(this: XMLHttpRequest) {\n      endSpan(EventNames.EVENT_ERROR, this);\n    }\n\n    function onAbort(this: XMLHttpRequest) {\n      endSpan(EventNames.EVENT_ABORT, this);\n    }\n\n    function onTimeout(this: XMLHttpRequest) {\n      endSpan(EventNames.EVENT_TIMEOUT, this);\n    }\n\n    function onLoad(this: XMLHttpRequest) {\n      if (this.status < 299) {\n        endSpan(EventNames.EVENT_LOAD, this);\n      } else {\n        endSpan(EventNames.EVENT_ERROR, this);\n      }\n    }\n\n    function unregister(xhr: XMLHttpRequest) {\n      xhr.removeEventListener('abort', onAbort);\n      xhr.removeEventListener('error', onError);\n      xhr.removeEventListener('load', onLoad);\n      xhr.removeEventListener('timeout', onTimeout);\n      const xhrMem = plugin._xhrMem.get(xhr);\n      if (xhrMem) {\n        xhrMem.callbackToRemoveEvents = undefined;\n      }\n    }\n\n    return (original: SendFunction): SendFunction => {\n      return function patchSend(this: XMLHttpRequest, ...args): void {\n        const xhrMem = plugin._xhrMem.get(this);\n        if (!xhrMem) {\n          return original.apply(this, args);\n        }\n        const currentSpan = xhrMem.span;\n        const spanUrl = xhrMem.spanUrl;\n\n        if (currentSpan && spanUrl) {\n          api.context.with(\n            api.trace.setSpan(api.context.active(), currentSpan),\n            () => {\n              plugin._tasksCount++;\n              xhrMem.sendStartTime = hrTime();\n              currentSpan.addEvent(EventNames.METHOD_SEND);\n\n              this.addEventListener('abort', onAbort);\n              this.addEventListener('error', onError);\n              this.addEventListener('load', onLoad);\n              this.addEventListener('timeout', onTimeout);\n\n              xhrMem.callbackToRemoveEvents = () => {\n                unregister(this);\n                if (xhrMem.createdResources) {\n                  xhrMem.createdResources.observer.disconnect();\n                }\n              };\n              plugin._addHeaders(this, spanUrl);\n              plugin._addResourceObserver(this, spanUrl);\n            }\n          );\n        }\n        return original.apply(this, args);\n      };\n    };\n  }\n\n  /**\n   * implements enable function\n   */\n  override enable() {\n    this._diag.debug('applying patch to', this.moduleName, this.version);\n\n    if (isWrapped(XMLHttpRequest.prototype.open)) {\n      this._unwrap(XMLHttpRequest.prototype, 'open');\n      this._diag.debug('removing previous patch from method open');\n    }\n\n    if (isWrapped(XMLHttpRequest.prototype.send)) {\n      this._unwrap(XMLHttpRequest.prototype, 'send');\n      this._diag.debug('removing previous patch from method send');\n    }\n\n    this._wrap(XMLHttpRequest.prototype, 'open', this._patchOpen());\n    this._wrap(XMLHttpRequest.prototype, 'send', this._patchSend());\n  }\n\n  /**\n   * implements disable function\n   */\n  override disable() {\n    this._diag.debug('removing patch from', this.moduleName, this.version);\n\n    this._unwrap(XMLHttpRequest.prototype, 'open');\n    this._unwrap(XMLHttpRequest.prototype, 'send');\n\n    this._tasksCount = 0;\n    this._xhrMem = new WeakMap<XMLHttpRequest, XhrMem>();\n    this._usedResources = new WeakSet<PerformanceResourceTiming>();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}