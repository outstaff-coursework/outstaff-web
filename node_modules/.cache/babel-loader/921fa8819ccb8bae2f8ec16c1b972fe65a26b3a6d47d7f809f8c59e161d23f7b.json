{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AggregatorKind } from './types';\nimport { DataPointType } from '../export/MetricData';\nimport { diag } from '@opentelemetry/api';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { Buckets } from './exponential-histogram/Buckets';\nimport { getMapping } from './exponential-histogram/mapping/getMapping';\nimport { nextGreaterSquare } from './exponential-histogram/util';\n// HighLow is a utility class used for computing a common scale for\n// two exponential histogram accumulations\nvar HighLow = /** @class */function () {\n  function HighLow(low, high) {\n    this.low = low;\n    this.high = high;\n  }\n  HighLow.combine = function (h1, h2) {\n    return new HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));\n  };\n  return HighLow;\n}();\nvar MAX_SCALE = 20;\nvar DEFAULT_MAX_SIZE = 160;\nvar MIN_MAX_SIZE = 2;\nvar ExponentialHistogramAccumulation = /** @class */function () {\n  function ExponentialHistogramAccumulation(startTime, _maxSize, _recordMinMax, _sum, _count, _zeroCount, _min, _max, _positive, _negative, _mapping) {\n    if (startTime === void 0) {\n      startTime = startTime;\n    }\n    if (_maxSize === void 0) {\n      _maxSize = DEFAULT_MAX_SIZE;\n    }\n    if (_recordMinMax === void 0) {\n      _recordMinMax = true;\n    }\n    if (_sum === void 0) {\n      _sum = 0;\n    }\n    if (_count === void 0) {\n      _count = 0;\n    }\n    if (_zeroCount === void 0) {\n      _zeroCount = 0;\n    }\n    if (_min === void 0) {\n      _min = Number.POSITIVE_INFINITY;\n    }\n    if (_max === void 0) {\n      _max = Number.NEGATIVE_INFINITY;\n    }\n    if (_positive === void 0) {\n      _positive = new Buckets();\n    }\n    if (_negative === void 0) {\n      _negative = new Buckets();\n    }\n    if (_mapping === void 0) {\n      _mapping = getMapping(MAX_SCALE);\n    }\n    this.startTime = startTime;\n    this._maxSize = _maxSize;\n    this._recordMinMax = _recordMinMax;\n    this._sum = _sum;\n    this._count = _count;\n    this._zeroCount = _zeroCount;\n    this._min = _min;\n    this._max = _max;\n    this._positive = _positive;\n    this._negative = _negative;\n    this._mapping = _mapping;\n    if (this._maxSize < MIN_MAX_SIZE) {\n      diag.warn(\"Exponential Histogram Max Size set to \" + this._maxSize + \",                 changing to the minimum size of: \" + MIN_MAX_SIZE);\n      this._maxSize = MIN_MAX_SIZE;\n    }\n  }\n  /**\n   * record updates a histogram with a single count\n   * @param {Number} value\n   */\n  ExponentialHistogramAccumulation.prototype.record = function (value) {\n    this.updateByIncrement(value, 1);\n  };\n  /**\n   * Sets the start time for this accumulation\n   * @param {HrTime} startTime\n   */\n  ExponentialHistogramAccumulation.prototype.setStartTime = function (startTime) {\n    this.startTime = startTime;\n  };\n  /**\n   * Returns the datapoint representation of this accumulation\n   * @param {HrTime} startTime\n   */\n  ExponentialHistogramAccumulation.prototype.toPointValue = function () {\n    return {\n      hasMinMax: this._recordMinMax,\n      min: this.min,\n      max: this.max,\n      sum: this.sum,\n      positive: {\n        offset: this.positive.offset,\n        bucketCounts: this.positive.counts()\n      },\n      negative: {\n        offset: this.negative.offset,\n        bucketCounts: this.negative.counts()\n      },\n      count: this.count,\n      scale: this.scale,\n      zeroCount: this.zeroCount\n    };\n  };\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"sum\", {\n    /**\n     * @returns {Number} The sum of values recorded by this accumulation\n     */\n    get: function () {\n      return this._sum;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"min\", {\n    /**\n     * @returns {Number} The minimum value recorded by this accumulation\n     */\n    get: function () {\n      return this._min;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"max\", {\n    /**\n     * @returns {Number} The maximum value recorded by this accumulation\n     */\n    get: function () {\n      return this._max;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"count\", {\n    /**\n     * @returns {Number} The count of values recorded by this accumulation\n     */\n    get: function () {\n      return this._count;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"zeroCount\", {\n    /**\n     * @returns {Number} The number of 0 values recorded by this accumulation\n     */\n    get: function () {\n      return this._zeroCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"scale\", {\n    /**\n     * @returns {Number} The scale used by thie accumulation\n     */\n    get: function () {\n      if (this._count === this._zeroCount) {\n        // all zeros! scale doesn't matter, use zero\n        return 0;\n      }\n      return this._mapping.scale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"positive\", {\n    /**\n     * positive holds the postive values\n     * @returns {Buckets}\n     */\n    get: function () {\n      return this._positive;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"negative\", {\n    /**\n     * negative holds the negative values by their absolute value\n     * @returns {Buckets}\n     */\n    get: function () {\n      return this._negative;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * uppdateByIncr supports updating a histogram with a non-negative\n   * increment.\n   * @param value\n   * @param increment\n   */\n  ExponentialHistogramAccumulation.prototype.updateByIncrement = function (value, increment) {\n    if (value > this._max) {\n      this._max = value;\n    }\n    if (value < this._min) {\n      this._min = value;\n    }\n    this._count += increment;\n    if (value === 0) {\n      this._zeroCount += increment;\n      return;\n    }\n    this._sum += value * increment;\n    if (value > 0) {\n      this._updateBuckets(this._positive, value, increment);\n    } else {\n      this._updateBuckets(this._negative, -value, increment);\n    }\n  };\n  /**\n   * merge combines data from previous value into self\n   * @param {ExponentialHistogramAccumulation} previous\n   */\n  ExponentialHistogramAccumulation.prototype.merge = function (previous) {\n    if (this._count === 0) {\n      this._min = previous.min;\n      this._max = previous.max;\n    } else if (previous.count !== 0) {\n      if (previous.min < this.min) {\n        this._min = previous.min;\n      }\n      if (previous.max > this.max) {\n        this._max = previous.max;\n      }\n    }\n    this.startTime = previous.startTime;\n    this._sum += previous.sum;\n    this._count += previous.count;\n    this._zeroCount += previous.zeroCount;\n    var minScale = this._minScale(previous);\n    this._downscale(this.scale - minScale);\n    this._mergeBuckets(this.positive, previous, previous.positive, minScale);\n    this._mergeBuckets(this.negative, previous, previous.negative, minScale);\n  };\n  /**\n   * diff substracts other from self\n   * @param {ExponentialHistogramAccumulation} other\n   */\n  ExponentialHistogramAccumulation.prototype.diff = function (other) {\n    this._min = Infinity;\n    this._max = -Infinity;\n    this._sum -= other.sum;\n    this._count -= other.count;\n    this._zeroCount -= other.zeroCount;\n    var minScale = this._minScale(other);\n    this._downscale(this.scale - minScale);\n    this._diffBuckets(this.positive, other, other.positive, minScale);\n    this._diffBuckets(this.negative, other, other.negative, minScale);\n  };\n  /**\n   * clone returns a deep copy of self\n   * @returns {ExponentialHistogramAccumulation}\n   */\n  ExponentialHistogramAccumulation.prototype.clone = function () {\n    return new ExponentialHistogramAccumulation(this.startTime, this._maxSize, this._recordMinMax, this._sum, this._count, this._zeroCount, this._min, this._max, this.positive.clone(), this.negative.clone(), this._mapping);\n  };\n  /**\n   * _updateBuckets maps the incoming value to a bucket index for the current\n   * scale. If the bucket index is outside of the range of the backing array,\n   * it will rescale the backing array and update the mapping for the new scale.\n   */\n  ExponentialHistogramAccumulation.prototype._updateBuckets = function (buckets, value, increment) {\n    var index = this._mapping.mapToIndex(value);\n    // rescale the mapping if needed\n    var rescalingNeeded = false;\n    var high = 0;\n    var low = 0;\n    if (buckets.length === 0) {\n      buckets.indexStart = index;\n      buckets.indexEnd = buckets.indexStart;\n      buckets.indexBase = buckets.indexStart;\n    } else if (index < buckets.indexStart && buckets.indexEnd - index >= this._maxSize) {\n      rescalingNeeded = true;\n      low = index;\n      high = buckets.indexEnd;\n    } else if (index > buckets.indexEnd && index - buckets.indexStart >= this._maxSize) {\n      rescalingNeeded = true;\n      low = buckets.indexStart;\n      high = index;\n    }\n    // rescale and compute index at new scale\n    if (rescalingNeeded) {\n      var change = this._changeScale(high, low);\n      this._downscale(change);\n      index = this._mapping.mapToIndex(value);\n    }\n    this._incrementIndexBy(buckets, index, increment);\n  };\n  /**\n   * _incrementIndexBy increments the count of the bucket specified by `index`.\n   * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]\n   * the boundaries of the backing array will be adjusted and more buckets will\n   * be added if needed.\n   */\n  ExponentialHistogramAccumulation.prototype._incrementIndexBy = function (buckets, index, increment) {\n    if (increment === 0) {\n      // nothing to do for a zero increment, can happen during a merge operation\n      return;\n    }\n    if (index < buckets.indexStart) {\n      var span = buckets.indexEnd - index;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexStart = index;\n    } else if (index > buckets.indexEnd) {\n      var span = index - buckets.indexStart;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexEnd = index;\n    }\n    var bucketIndex = index - buckets.indexBase;\n    if (bucketIndex < 0) {\n      bucketIndex += buckets.backing.length;\n    }\n    buckets.incrementBucket(bucketIndex, increment);\n  };\n  /**\n   * grow resizes the backing array by doubling in size up to maxSize.\n   * This extends the array with a bunch of zeros and copies the\n   * existing counts to the same position.\n   */\n  ExponentialHistogramAccumulation.prototype._grow = function (buckets, needed) {\n    var size = buckets.backing.length;\n    var bias = buckets.indexBase - buckets.indexStart;\n    var oldPositiveLimit = size - bias;\n    var newSize = nextGreaterSquare(needed);\n    if (newSize > this._maxSize) {\n      newSize = this._maxSize;\n    }\n    var newPositiveLimit = newSize - bias;\n    buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);\n  };\n  /**\n   * _changeScale computes how much downscaling is needed by shifting the\n   * high and low values until they are separated by no more than size.\n   */\n  ExponentialHistogramAccumulation.prototype._changeScale = function (high, low) {\n    var change = 0;\n    while (high - low >= this._maxSize) {\n      high >>= 1;\n      low >>= 1;\n      change++;\n    }\n    return change;\n  };\n  /**\n   * _downscale subtracts `change` from the current mapping scale.\n   */\n  ExponentialHistogramAccumulation.prototype._downscale = function (change) {\n    if (change === 0) {\n      return;\n    }\n    if (change < 0) {\n      // Note: this should be impossible. If we get here it's because\n      // there is a bug in the implementation.\n      throw new Error(\"impossible change of scale: \" + this.scale);\n    }\n    var newScale = this._mapping.scale - change;\n    this._positive.downscale(change);\n    this._negative.downscale(change);\n    this._mapping = getMapping(newScale);\n  };\n  /**\n   * _minScale is used by diff and merge to compute an ideal combined scale\n   */\n  ExponentialHistogramAccumulation.prototype._minScale = function (other) {\n    var minScale = Math.min(this.scale, other.scale);\n    var highLowPos = HighLow.combine(this._highLowAtScale(this.positive, this.scale, minScale), this._highLowAtScale(other.positive, other.scale, minScale));\n    var highLowNeg = HighLow.combine(this._highLowAtScale(this.negative, this.scale, minScale), this._highLowAtScale(other.negative, other.scale, minScale));\n    return Math.min(minScale - this._changeScale(highLowPos.high, highLowPos.low), minScale - this._changeScale(highLowNeg.high, highLowNeg.low));\n  };\n  /**\n   * _highLowAtScale is used by diff and merge to compute an ideal combined scale.\n   */\n  ExponentialHistogramAccumulation.prototype._highLowAtScale = function (buckets, currentScale, newScale) {\n    if (buckets.length === 0) {\n      return new HighLow(0, -1);\n    }\n    var shift = currentScale - newScale;\n    return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);\n  };\n  /**\n   * _mergeBuckets translates index values from another histogram and\n   * adds the values into the corresponding buckets of this histogram.\n   */\n  ExponentialHistogramAccumulation.prototype._mergeBuckets = function (ours, other, theirs, scale) {\n    var theirOffset = theirs.offset;\n    var theirChange = other.scale - scale;\n    for (var i = 0; i < theirs.length; i++) {\n      this._incrementIndexBy(ours, theirOffset + i >> theirChange, theirs.at(i));\n    }\n  };\n  /**\n   * _diffBuckets translates index values from another histogram and\n   * subtracts the values in the corresponding buckets of this histogram.\n   */\n  ExponentialHistogramAccumulation.prototype._diffBuckets = function (ours, other, theirs, scale) {\n    var theirOffset = theirs.offset;\n    var theirChange = other.scale - scale;\n    for (var i = 0; i < theirs.length; i++) {\n      var ourIndex = theirOffset + i >> theirChange;\n      var bucketIndex = ourIndex - ours.indexBase;\n      if (bucketIndex < 0) {\n        bucketIndex += ours.backing.length;\n      }\n      ours.decrementBucket(bucketIndex, theirs.at(i));\n    }\n    ours.trim();\n  };\n  return ExponentialHistogramAccumulation;\n}();\nexport { ExponentialHistogramAccumulation };\n/**\n * Aggregator for ExponentialHistogramAccumlations\n */\nvar ExponentialHistogramAggregator = /** @class */function () {\n  /**\n   * @param _maxSize Maximum number of buckets for each of the positive\n   *    and negative ranges, exclusive of the zero-bucket.\n   * @param _recordMinMax If set to true, min and max will be recorded.\n   *    Otherwise, min and max will not be recorded.\n   */\n  function ExponentialHistogramAggregator(_maxSize, _recordMinMax) {\n    this._maxSize = _maxSize;\n    this._recordMinMax = _recordMinMax;\n    this.kind = AggregatorKind.EXPONENTIAL_HISTOGRAM;\n  }\n  ExponentialHistogramAggregator.prototype.createAccumulation = function (startTime) {\n    return new ExponentialHistogramAccumulation(startTime, this._maxSize, this._recordMinMax);\n  };\n  /**\n   * Return the result of the merge of two exponential histogram accumulations.\n   */\n  ExponentialHistogramAggregator.prototype.merge = function (previous, delta) {\n    var result = delta.clone();\n    result.merge(previous);\n    return result;\n  };\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  ExponentialHistogramAggregator.prototype.diff = function (previous, current) {\n    var result = current.clone();\n    result.diff(previous);\n    return result;\n  };\n  ExponentialHistogramAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor: descriptor,\n      aggregationTemporality: aggregationTemporality,\n      dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(function (_a) {\n        var _b = __read(_a, 2),\n          attributes = _b[0],\n          accumulation = _b[1];\n        var pointValue = accumulation.toPointValue();\n        // determine if instrument allows negative values.\n        var allowsNegativeValues = descriptor.type === InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n        return {\n          attributes: attributes,\n          startTime: accumulation.startTime,\n          endTime: endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            positive: {\n              offset: pointValue.positive.offset,\n              bucketCounts: pointValue.positive.bucketCounts\n            },\n            negative: {\n              offset: pointValue.negative.offset,\n              bucketCounts: pointValue.negative.bucketCounts\n            },\n            count: pointValue.count,\n            scale: pointValue.scale,\n            zeroCount: pointValue.zeroCount\n          }\n        };\n      })\n    };\n  };\n  return ExponentialHistogramAggregator;\n}();\nexport { ExponentialHistogramAggregator };","map":{"version":3,"names":["AggregatorKind","DataPointType","diag","InstrumentType","Buckets","getMapping","nextGreaterSquare","HighLow","low","high","combine","h1","h2","Math","min","max","MAX_SCALE","DEFAULT_MAX_SIZE","MIN_MAX_SIZE","ExponentialHistogramAccumulation","startTime","_maxSize","_recordMinMax","_sum","_count","_zeroCount","_min","_max","_positive","_negative","_mapping","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","warn","prototype","record","value","updateByIncrement","setStartTime","toPointValue","hasMinMax","sum","positive","offset","bucketCounts","counts","negative","count","scale","zeroCount","Object","defineProperty","get","increment","_updateBuckets","merge","previous","minScale","_minScale","_downscale","_mergeBuckets","diff","other","Infinity","_diffBuckets","clone","buckets","index","mapToIndex","rescalingNeeded","length","indexStart","indexEnd","indexBase","change","_changeScale","_incrementIndexBy","span","backing","_grow","bucketIndex","incrementBucket","needed","size","bias","oldPositiveLimit","newSize","newPositiveLimit","growTo","Error","newScale","downscale","highLowPos","_highLowAtScale","highLowNeg","currentScale","shift","ours","theirs","theirOffset","theirChange","i","at","ourIndex","decrementBucket","trim","ExponentialHistogramAggregator","kind","EXPONENTIAL_HISTOGRAM","createAccumulation","delta","result","current","toMetricData","descriptor","aggregationTemporality","accumulationByAttributes","endTime","dataPointType","dataPoints","map","_a","_b","__read","attributes","accumulation","pointValue","allowsNegativeValues","type","UP_DOWN_COUNTER","OBSERVABLE_GAUGE","OBSERVABLE_UP_DOWN_COUNTER","undefined"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/aggregator/ExponentialHistogram.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n  ExponentialHistogram,\n} from './types';\nimport {\n  DataPointType,\n  ExponentialHistogramMetricData,\n  MetricDescriptor,\n} from '../export/MetricData';\nimport { diag, HrTime } from '@opentelemetry/api';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { Buckets } from './exponential-histogram/Buckets';\nimport { getMapping } from './exponential-histogram/mapping/getMapping';\nimport { Mapping } from './exponential-histogram/mapping/types';\nimport { nextGreaterSquare } from './exponential-histogram/util';\n\n/**\n * Internal value type for ExponentialHistogramAggregation.\n * Differs from the exported type as undefined sum/min/max complicate arithmetic\n * performed by this aggregation, but are required to be undefined in the exported types.\n */\ninterface InternalHistogram extends ExponentialHistogram {\n  hasMinMax: boolean;\n  min: number;\n  max: number;\n  sum: number;\n}\n\n// HighLow is a utility class used for computing a common scale for\n// two exponential histogram accumulations\nclass HighLow {\n  static combine(h1: HighLow, h2: HighLow): HighLow {\n    return new HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));\n  }\n  constructor(\n    public low: number,\n    public high: number\n  ) {}\n}\n\nconst MAX_SCALE = 20;\nconst DEFAULT_MAX_SIZE = 160;\nconst MIN_MAX_SIZE = 2;\n\nexport class ExponentialHistogramAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime = startTime,\n    private _maxSize = DEFAULT_MAX_SIZE,\n    private _recordMinMax = true,\n    private _sum = 0,\n    private _count = 0,\n    private _zeroCount = 0,\n    private _min = Number.POSITIVE_INFINITY,\n    private _max = Number.NEGATIVE_INFINITY,\n    private _positive = new Buckets(),\n    private _negative = new Buckets(),\n    private _mapping: Mapping = getMapping(MAX_SCALE)\n  ) {\n    if (this._maxSize < MIN_MAX_SIZE) {\n      diag.warn(`Exponential Histogram Max Size set to ${this._maxSize}, \\\n                changing to the minimum size of: ${MIN_MAX_SIZE}`);\n      this._maxSize = MIN_MAX_SIZE;\n    }\n  }\n\n  /**\n   * record updates a histogram with a single count\n   * @param {Number} value\n   */\n  record(value: number) {\n    this.updateByIncrement(value, 1);\n  }\n\n  /**\n   * Sets the start time for this accumulation\n   * @param {HrTime} startTime\n   */\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  /**\n   * Returns the datapoint representation of this accumulation\n   * @param {HrTime} startTime\n   */\n  toPointValue(): InternalHistogram {\n    return {\n      hasMinMax: this._recordMinMax,\n      min: this.min,\n      max: this.max,\n      sum: this.sum,\n      positive: {\n        offset: this.positive.offset,\n        bucketCounts: this.positive.counts(),\n      },\n      negative: {\n        offset: this.negative.offset,\n        bucketCounts: this.negative.counts(),\n      },\n      count: this.count,\n      scale: this.scale,\n      zeroCount: this.zeroCount,\n    };\n  }\n\n  /**\n   * @returns {Number} The sum of values recorded by this accumulation\n   */\n  get sum(): number {\n    return this._sum;\n  }\n\n  /**\n   * @returns {Number} The minimum value recorded by this accumulation\n   */\n  get min(): number {\n    return this._min;\n  }\n\n  /**\n   * @returns {Number} The maximum value recorded by this accumulation\n   */\n  get max(): number {\n    return this._max;\n  }\n\n  /**\n   * @returns {Number} The count of values recorded by this accumulation\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * @returns {Number} The number of 0 values recorded by this accumulation\n   */\n  get zeroCount(): number {\n    return this._zeroCount;\n  }\n\n  /**\n   * @returns {Number} The scale used by thie accumulation\n   */\n  get scale(): number {\n    if (this._count === this._zeroCount) {\n      // all zeros! scale doesn't matter, use zero\n      return 0;\n    }\n    return this._mapping.scale;\n  }\n\n  /**\n   * positive holds the postive values\n   * @returns {Buckets}\n   */\n  get positive(): Buckets {\n    return this._positive;\n  }\n\n  /**\n   * negative holds the negative values by their absolute value\n   * @returns {Buckets}\n   */\n  get negative(): Buckets {\n    return this._negative;\n  }\n\n  /**\n   * uppdateByIncr supports updating a histogram with a non-negative\n   * increment.\n   * @param value\n   * @param increment\n   */\n  updateByIncrement(value: number, increment: number) {\n    if (value > this._max) {\n      this._max = value;\n    }\n    if (value < this._min) {\n      this._min = value;\n    }\n\n    this._count += increment;\n\n    if (value === 0) {\n      this._zeroCount += increment;\n      return;\n    }\n\n    this._sum += value * increment;\n\n    if (value > 0) {\n      this._updateBuckets(this._positive, value, increment);\n    } else {\n      this._updateBuckets(this._negative, -value, increment);\n    }\n  }\n\n  /**\n   * merge combines data from previous value into self\n   * @param {ExponentialHistogramAccumulation} previous\n   */\n  merge(previous: ExponentialHistogramAccumulation) {\n    if (this._count === 0) {\n      this._min = previous.min;\n      this._max = previous.max;\n    } else if (previous.count !== 0) {\n      if (previous.min < this.min) {\n        this._min = previous.min;\n      }\n      if (previous.max > this.max) {\n        this._max = previous.max;\n      }\n    }\n\n    this.startTime = previous.startTime;\n    this._sum += previous.sum;\n    this._count += previous.count;\n    this._zeroCount += previous.zeroCount;\n\n    const minScale = this._minScale(previous);\n\n    this._downscale(this.scale - minScale);\n\n    this._mergeBuckets(this.positive, previous, previous.positive, minScale);\n    this._mergeBuckets(this.negative, previous, previous.negative, minScale);\n  }\n\n  /**\n   * diff substracts other from self\n   * @param {ExponentialHistogramAccumulation} other\n   */\n  diff(other: ExponentialHistogramAccumulation) {\n    this._min = Infinity;\n    this._max = -Infinity;\n    this._sum -= other.sum;\n    this._count -= other.count;\n    this._zeroCount -= other.zeroCount;\n\n    const minScale = this._minScale(other);\n\n    this._downscale(this.scale - minScale);\n\n    this._diffBuckets(this.positive, other, other.positive, minScale);\n    this._diffBuckets(this.negative, other, other.negative, minScale);\n  }\n\n  /**\n   * clone returns a deep copy of self\n   * @returns {ExponentialHistogramAccumulation}\n   */\n  clone(): ExponentialHistogramAccumulation {\n    return new ExponentialHistogramAccumulation(\n      this.startTime,\n      this._maxSize,\n      this._recordMinMax,\n      this._sum,\n      this._count,\n      this._zeroCount,\n      this._min,\n      this._max,\n      this.positive.clone(),\n      this.negative.clone(),\n      this._mapping\n    );\n  }\n\n  /**\n   * _updateBuckets maps the incoming value to a bucket index for the current\n   * scale. If the bucket index is outside of the range of the backing array,\n   * it will rescale the backing array and update the mapping for the new scale.\n   */\n  private _updateBuckets(buckets: Buckets, value: number, increment: number) {\n    let index = this._mapping.mapToIndex(value);\n\n    // rescale the mapping if needed\n    let rescalingNeeded = false;\n    let high = 0;\n    let low = 0;\n\n    if (buckets.length === 0) {\n      buckets.indexStart = index;\n      buckets.indexEnd = buckets.indexStart;\n      buckets.indexBase = buckets.indexStart;\n    } else if (\n      index < buckets.indexStart &&\n      buckets.indexEnd - index >= this._maxSize\n    ) {\n      rescalingNeeded = true;\n      low = index;\n      high = buckets.indexEnd;\n    } else if (\n      index > buckets.indexEnd &&\n      index - buckets.indexStart >= this._maxSize\n    ) {\n      rescalingNeeded = true;\n      low = buckets.indexStart;\n      high = index;\n    }\n\n    // rescale and compute index at new scale\n    if (rescalingNeeded) {\n      const change = this._changeScale(high, low);\n      this._downscale(change);\n      index = this._mapping.mapToIndex(value);\n    }\n\n    this._incrementIndexBy(buckets, index, increment);\n  }\n\n  /**\n   * _incrementIndexBy increments the count of the bucket specified by `index`.\n   * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]\n   * the boundaries of the backing array will be adjusted and more buckets will\n   * be added if needed.\n   */\n  private _incrementIndexBy(\n    buckets: Buckets,\n    index: number,\n    increment: number\n  ) {\n    if (increment === 0) {\n      // nothing to do for a zero increment, can happen during a merge operation\n      return;\n    }\n\n    if (index < buckets.indexStart) {\n      const span = buckets.indexEnd - index;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexStart = index;\n    } else if (index > buckets.indexEnd) {\n      const span = index - buckets.indexStart;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexEnd = index;\n    }\n\n    let bucketIndex = index - buckets.indexBase;\n    if (bucketIndex < 0) {\n      bucketIndex += buckets.backing.length;\n    }\n    buckets.incrementBucket(bucketIndex, increment);\n  }\n\n  /**\n   * grow resizes the backing array by doubling in size up to maxSize.\n   * This extends the array with a bunch of zeros and copies the\n   * existing counts to the same position.\n   */\n  private _grow(buckets: Buckets, needed: number) {\n    const size = buckets.backing.length;\n    const bias = buckets.indexBase - buckets.indexStart;\n    const oldPositiveLimit = size - bias;\n    let newSize = nextGreaterSquare(needed);\n    if (newSize > this._maxSize) {\n      newSize = this._maxSize;\n    }\n    const newPositiveLimit = newSize - bias;\n    buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);\n  }\n\n  /**\n   * _changeScale computes how much downscaling is needed by shifting the\n   * high and low values until they are separated by no more than size.\n   */\n  private _changeScale(high: number, low: number): number {\n    let change = 0;\n    while (high - low >= this._maxSize) {\n      high >>= 1;\n      low >>= 1;\n      change++;\n    }\n    return change;\n  }\n\n  /**\n   * _downscale subtracts `change` from the current mapping scale.\n   */\n  private _downscale(change: number) {\n    if (change === 0) {\n      return;\n    }\n    if (change < 0) {\n      // Note: this should be impossible. If we get here it's because\n      // there is a bug in the implementation.\n      throw new Error(`impossible change of scale: ${this.scale}`);\n    }\n    const newScale = this._mapping.scale - change;\n\n    this._positive.downscale(change);\n    this._negative.downscale(change);\n\n    this._mapping = getMapping(newScale);\n  }\n\n  /**\n   * _minScale is used by diff and merge to compute an ideal combined scale\n   */\n  private _minScale(other: ExponentialHistogramAccumulation): number {\n    const minScale = Math.min(this.scale, other.scale);\n\n    const highLowPos = HighLow.combine(\n      this._highLowAtScale(this.positive, this.scale, minScale),\n      this._highLowAtScale(other.positive, other.scale, minScale)\n    );\n\n    const highLowNeg = HighLow.combine(\n      this._highLowAtScale(this.negative, this.scale, minScale),\n      this._highLowAtScale(other.negative, other.scale, minScale)\n    );\n\n    return Math.min(\n      minScale - this._changeScale(highLowPos.high, highLowPos.low),\n      minScale - this._changeScale(highLowNeg.high, highLowNeg.low)\n    );\n  }\n\n  /**\n   * _highLowAtScale is used by diff and merge to compute an ideal combined scale.\n   */\n  private _highLowAtScale(\n    buckets: Buckets,\n    currentScale: number,\n    newScale: number\n  ): HighLow {\n    if (buckets.length === 0) {\n      return new HighLow(0, -1);\n    }\n    const shift = currentScale - newScale;\n    return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);\n  }\n\n  /**\n   * _mergeBuckets translates index values from another histogram and\n   * adds the values into the corresponding buckets of this histogram.\n   */\n  private _mergeBuckets(\n    ours: Buckets,\n    other: ExponentialHistogramAccumulation,\n    theirs: Buckets,\n    scale: number\n  ) {\n    const theirOffset = theirs.offset;\n    const theirChange = other.scale - scale;\n\n    for (let i = 0; i < theirs.length; i++) {\n      this._incrementIndexBy(\n        ours,\n        (theirOffset + i) >> theirChange,\n        theirs.at(i)\n      );\n    }\n  }\n\n  /**\n   * _diffBuckets translates index values from another histogram and\n   * subtracts the values in the corresponding buckets of this histogram.\n   */\n  private _diffBuckets(\n    ours: Buckets,\n    other: ExponentialHistogramAccumulation,\n    theirs: Buckets,\n    scale: number\n  ) {\n    const theirOffset = theirs.offset;\n    const theirChange = other.scale - scale;\n\n    for (let i = 0; i < theirs.length; i++) {\n      const ourIndex = (theirOffset + i) >> theirChange;\n      let bucketIndex = ourIndex - ours.indexBase;\n      if (bucketIndex < 0) {\n        bucketIndex += ours.backing.length;\n      }\n      ours.decrementBucket(bucketIndex, theirs.at(i));\n    }\n\n    ours.trim();\n  }\n}\n\n/**\n * Aggregator for ExponentialHistogramAccumlations\n */\nexport class ExponentialHistogramAggregator\n  implements Aggregator<ExponentialHistogramAccumulation>\n{\n  public kind: AggregatorKind.EXPONENTIAL_HISTOGRAM =\n    AggregatorKind.EXPONENTIAL_HISTOGRAM;\n\n  /**\n   * @param _maxSize Maximum number of buckets for each of the positive\n   *    and negative ranges, exclusive of the zero-bucket.\n   * @param _recordMinMax If set to true, min and max will be recorded.\n   *    Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    readonly _maxSize: number,\n    private readonly _recordMinMax: boolean\n  ) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new ExponentialHistogramAccumulation(\n      startTime,\n      this._maxSize,\n      this._recordMinMax\n    );\n  }\n\n  /**\n   * Return the result of the merge of two exponential histogram accumulations.\n   */\n  merge(\n    previous: ExponentialHistogramAccumulation,\n    delta: ExponentialHistogramAccumulation\n  ): ExponentialHistogramAccumulation {\n    const result = delta.clone();\n    result.merge(previous);\n\n    return result;\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(\n    previous: ExponentialHistogramAccumulation,\n    current: ExponentialHistogramAccumulation\n  ): ExponentialHistogramAccumulation {\n    const result = current.clone();\n    result.diff(previous);\n\n    return result;\n  }\n\n  toMetricData(\n    descriptor: MetricDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<ExponentialHistogramAccumulation>[],\n    endTime: HrTime\n  ): Maybe<ExponentialHistogramMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        const pointValue = accumulation.toPointValue();\n\n        // determine if instrument allows negative values.\n        const allowsNegativeValues =\n          descriptor.type === InstrumentType.UP_DOWN_COUNTER ||\n          descriptor.type === InstrumentType.OBSERVABLE_GAUGE ||\n          descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            positive: {\n              offset: pointValue.positive.offset,\n              bucketCounts: pointValue.positive.bucketCounts,\n            },\n            negative: {\n              offset: pointValue.negative.offset,\n              bucketCounts: pointValue.negative.bucketCounts,\n            },\n            count: pointValue.count,\n            scale: pointValue.scale,\n            zeroCount: pointValue.zeroCount,\n          },\n        };\n      }),\n    };\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,SAIEA,cAAc,QAET,SAAS;AAChB,SACEC,aAAa,QAGR,sBAAsB;AAC7B,SAASC,IAAI,QAAgB,oBAAoB;AACjD,SAASC,cAAc,QAAQ,yBAAyB;AAGxD,SAASC,OAAO,QAAQ,iCAAiC;AACzD,SAASC,UAAU,QAAQ,4CAA4C;AAEvE,SAASC,iBAAiB,QAAQ,8BAA8B;AAchE;AACA;AACA,IAAAC,OAAA;EAIE,SAAAA,QACSC,GAAW,EACXC,IAAY;IADZ,KAAAD,GAAG,GAAHA,GAAG;IACH,KAAAC,IAAI,GAAJA,IAAI;EACV;EANIF,OAAA,CAAAG,OAAO,GAAd,UAAeC,EAAW,EAAEC,EAAW;IACrC,OAAO,IAAIL,OAAO,CAACM,IAAI,CAACC,GAAG,CAACH,EAAE,CAACH,GAAG,EAAEI,EAAE,CAACJ,GAAG,CAAC,EAAEK,IAAI,CAACE,GAAG,CAACJ,EAAE,CAACF,IAAI,EAAEG,EAAE,CAACH,IAAI,CAAC,CAAC;EAC1E,CAAC;EAKH,OAAAF,OAAC;AAAD,CAAC,CARD;AAUA,IAAMS,SAAS,GAAG,EAAE;AACpB,IAAMC,gBAAgB,GAAG,GAAG;AAC5B,IAAMC,YAAY,GAAG,CAAC;AAEtB,IAAAC,gCAAA;EACE,SAAAA,iCACSC,SAA6B,EAC5BC,QAA2B,EAC3BC,aAAoB,EACpBC,IAAQ,EACRC,MAAU,EACVC,UAAc,EACdC,IAA+B,EAC/BC,IAA+B,EAC/BC,SAAyB,EACzBC,SAAyB,EACzBC,QAAyC;IAV1C,IAAAV,SAAA;MAAAA,SAAA,GAAAA,SAA6B;IAAA;IAC5B,IAAAC,QAAA;MAAAA,QAAA,GAAAJ,gBAA2B;IAAA;IAC3B,IAAAK,aAAA;MAAAA,aAAA,OAAoB;IAAA;IACpB,IAAAC,IAAA;MAAAA,IAAA,IAAQ;IAAA;IACR,IAAAC,MAAA;MAAAA,MAAA,IAAU;IAAA;IACV,IAAAC,UAAA;MAAAA,UAAA,IAAc;IAAA;IACd,IAAAC,IAAA;MAAAA,IAAA,GAAOK,MAAM,CAACC,iBAAiB;IAAA;IAC/B,IAAAL,IAAA;MAAAA,IAAA,GAAOI,MAAM,CAACE,iBAAiB;IAAA;IAC/B,IAAAL,SAAA;MAAAA,SAAA,OAAgBxB,OAAO,EAAE;IAAA;IACzB,IAAAyB,SAAA;MAAAA,SAAA,OAAgBzB,OAAO,EAAE;IAAA;IACzB,IAAA0B,QAAA;MAAAA,QAAA,GAAoBzB,UAAU,CAACW,SAAS,CAAC;IAAA;IAV1C,KAAAI,SAAS,GAATA,SAAS;IACR,KAAAC,QAAQ,GAARA,QAAQ;IACR,KAAAC,aAAa,GAAbA,aAAa;IACb,KAAAC,IAAI,GAAJA,IAAI;IACJ,KAAAC,MAAM,GAANA,MAAM;IACN,KAAAC,UAAU,GAAVA,UAAU;IACV,KAAAC,IAAI,GAAJA,IAAI;IACJ,KAAAC,IAAI,GAAJA,IAAI;IACJ,KAAAC,SAAS,GAATA,SAAS;IACT,KAAAC,SAAS,GAATA,SAAS;IACT,KAAAC,QAAQ,GAARA,QAAQ;IAEhB,IAAI,IAAI,CAACT,QAAQ,GAAGH,YAAY,EAAE;MAChChB,IAAI,CAACgC,IAAI,CAAC,2CAAyC,IAAI,CAACb,QAAQ,2DACnBH,YAAc,CAAC;MAC5D,IAAI,CAACG,QAAQ,GAAGH,YAAY;;EAEhC;EAEA;;;;EAIAC,gCAAA,CAAAgB,SAAA,CAAAC,MAAM,GAAN,UAAOC,KAAa;IAClB,IAAI,CAACC,iBAAiB,CAACD,KAAK,EAAE,CAAC,CAAC;EAClC,CAAC;EAED;;;;EAIAlB,gCAAA,CAAAgB,SAAA,CAAAI,YAAY,GAAZ,UAAanB,SAAiB;IAC5B,IAAI,CAACA,SAAS,GAAGA,SAAS;EAC5B,CAAC;EAED;;;;EAIAD,gCAAA,CAAAgB,SAAA,CAAAK,YAAY,GAAZ;IACE,OAAO;MACLC,SAAS,EAAE,IAAI,CAACnB,aAAa;MAC7BR,GAAG,EAAE,IAAI,CAACA,GAAG;MACbC,GAAG,EAAE,IAAI,CAACA,GAAG;MACb2B,GAAG,EAAE,IAAI,CAACA,GAAG;MACbC,QAAQ,EAAE;QACRC,MAAM,EAAE,IAAI,CAACD,QAAQ,CAACC,MAAM;QAC5BC,YAAY,EAAE,IAAI,CAACF,QAAQ,CAACG,MAAM;OACnC;MACDC,QAAQ,EAAE;QACRH,MAAM,EAAE,IAAI,CAACG,QAAQ,CAACH,MAAM;QAC5BC,YAAY,EAAE,IAAI,CAACE,QAAQ,CAACD,MAAM;OACnC;MACDE,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBC,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBC,SAAS,EAAE,IAAI,CAACA;KACjB;EACH,CAAC;EAKDC,MAAA,CAAAC,cAAA,CAAIjC,gCAAA,CAAAgB,SAAA,OAAG;IAHP;;;SAGA,SAAAkB,CAAA;MACE,OAAO,IAAI,CAAC9B,IAAI;IAClB,CAAC;;;;EAKD4B,MAAA,CAAAC,cAAA,CAAIjC,gCAAA,CAAAgB,SAAA,OAAG;IAHP;;;SAGA,SAAAkB,CAAA;MACE,OAAO,IAAI,CAAC3B,IAAI;IAClB,CAAC;;;;EAKDyB,MAAA,CAAAC,cAAA,CAAIjC,gCAAA,CAAAgB,SAAA,OAAG;IAHP;;;SAGA,SAAAkB,CAAA;MACE,OAAO,IAAI,CAAC1B,IAAI;IAClB,CAAC;;;;EAKDwB,MAAA,CAAAC,cAAA,CAAIjC,gCAAA,CAAAgB,SAAA,SAAK;IAHT;;;SAGA,SAAAkB,CAAA;MACE,OAAO,IAAI,CAAC7B,MAAM;IACpB,CAAC;;;;EAKD2B,MAAA,CAAAC,cAAA,CAAIjC,gCAAA,CAAAgB,SAAA,aAAS;IAHb;;;SAGA,SAAAkB,CAAA;MACE,OAAO,IAAI,CAAC5B,UAAU;IACxB,CAAC;;;;EAKD0B,MAAA,CAAAC,cAAA,CAAIjC,gCAAA,CAAAgB,SAAA,SAAK;IAHT;;;SAGA,SAAAkB,CAAA;MACE,IAAI,IAAI,CAAC7B,MAAM,KAAK,IAAI,CAACC,UAAU,EAAE;QACnC;QACA,OAAO,CAAC;;MAEV,OAAO,IAAI,CAACK,QAAQ,CAACmB,KAAK;IAC5B,CAAC;;;;EAMDE,MAAA,CAAAC,cAAA,CAAIjC,gCAAA,CAAAgB,SAAA,YAAQ;IAJZ;;;;SAIA,SAAAkB,CAAA;MACE,OAAO,IAAI,CAACzB,SAAS;IACvB,CAAC;;;;EAMDuB,MAAA,CAAAC,cAAA,CAAIjC,gCAAA,CAAAgB,SAAA,YAAQ;IAJZ;;;;SAIA,SAAAkB,CAAA;MACE,OAAO,IAAI,CAACxB,SAAS;IACvB,CAAC;;;;EAED;;;;;;EAMAV,gCAAA,CAAAgB,SAAA,CAAAG,iBAAiB,GAAjB,UAAkBD,KAAa,EAAEiB,SAAiB;IAChD,IAAIjB,KAAK,GAAG,IAAI,CAACV,IAAI,EAAE;MACrB,IAAI,CAACA,IAAI,GAAGU,KAAK;;IAEnB,IAAIA,KAAK,GAAG,IAAI,CAACX,IAAI,EAAE;MACrB,IAAI,CAACA,IAAI,GAAGW,KAAK;;IAGnB,IAAI,CAACb,MAAM,IAAI8B,SAAS;IAExB,IAAIjB,KAAK,KAAK,CAAC,EAAE;MACf,IAAI,CAACZ,UAAU,IAAI6B,SAAS;MAC5B;;IAGF,IAAI,CAAC/B,IAAI,IAAIc,KAAK,GAAGiB,SAAS;IAE9B,IAAIjB,KAAK,GAAG,CAAC,EAAE;MACb,IAAI,CAACkB,cAAc,CAAC,IAAI,CAAC3B,SAAS,EAAES,KAAK,EAAEiB,SAAS,CAAC;KACtD,MAAM;MACL,IAAI,CAACC,cAAc,CAAC,IAAI,CAAC1B,SAAS,EAAE,CAACQ,KAAK,EAAEiB,SAAS,CAAC;;EAE1D,CAAC;EAED;;;;EAIAnC,gCAAA,CAAAgB,SAAA,CAAAqB,KAAK,GAAL,UAAMC,QAA0C;IAC9C,IAAI,IAAI,CAACjC,MAAM,KAAK,CAAC,EAAE;MACrB,IAAI,CAACE,IAAI,GAAG+B,QAAQ,CAAC3C,GAAG;MACxB,IAAI,CAACa,IAAI,GAAG8B,QAAQ,CAAC1C,GAAG;KACzB,MAAM,IAAI0C,QAAQ,CAACT,KAAK,KAAK,CAAC,EAAE;MAC/B,IAAIS,QAAQ,CAAC3C,GAAG,GAAG,IAAI,CAACA,GAAG,EAAE;QAC3B,IAAI,CAACY,IAAI,GAAG+B,QAAQ,CAAC3C,GAAG;;MAE1B,IAAI2C,QAAQ,CAAC1C,GAAG,GAAG,IAAI,CAACA,GAAG,EAAE;QAC3B,IAAI,CAACY,IAAI,GAAG8B,QAAQ,CAAC1C,GAAG;;;IAI5B,IAAI,CAACK,SAAS,GAAGqC,QAAQ,CAACrC,SAAS;IACnC,IAAI,CAACG,IAAI,IAAIkC,QAAQ,CAACf,GAAG;IACzB,IAAI,CAAClB,MAAM,IAAIiC,QAAQ,CAACT,KAAK;IAC7B,IAAI,CAACvB,UAAU,IAAIgC,QAAQ,CAACP,SAAS;IAErC,IAAMQ,QAAQ,GAAG,IAAI,CAACC,SAAS,CAACF,QAAQ,CAAC;IAEzC,IAAI,CAACG,UAAU,CAAC,IAAI,CAACX,KAAK,GAAGS,QAAQ,CAAC;IAEtC,IAAI,CAACG,aAAa,CAAC,IAAI,CAAClB,QAAQ,EAAEc,QAAQ,EAAEA,QAAQ,CAACd,QAAQ,EAAEe,QAAQ,CAAC;IACxE,IAAI,CAACG,aAAa,CAAC,IAAI,CAACd,QAAQ,EAAEU,QAAQ,EAAEA,QAAQ,CAACV,QAAQ,EAAEW,QAAQ,CAAC;EAC1E,CAAC;EAED;;;;EAIAvC,gCAAA,CAAAgB,SAAA,CAAA2B,IAAI,GAAJ,UAAKC,KAAuC;IAC1C,IAAI,CAACrC,IAAI,GAAGsC,QAAQ;IACpB,IAAI,CAACrC,IAAI,GAAG,CAACqC,QAAQ;IACrB,IAAI,CAACzC,IAAI,IAAIwC,KAAK,CAACrB,GAAG;IACtB,IAAI,CAAClB,MAAM,IAAIuC,KAAK,CAACf,KAAK;IAC1B,IAAI,CAACvB,UAAU,IAAIsC,KAAK,CAACb,SAAS;IAElC,IAAMQ,QAAQ,GAAG,IAAI,CAACC,SAAS,CAACI,KAAK,CAAC;IAEtC,IAAI,CAACH,UAAU,CAAC,IAAI,CAACX,KAAK,GAAGS,QAAQ,CAAC;IAEtC,IAAI,CAACO,YAAY,CAAC,IAAI,CAACtB,QAAQ,EAAEoB,KAAK,EAAEA,KAAK,CAACpB,QAAQ,EAAEe,QAAQ,CAAC;IACjE,IAAI,CAACO,YAAY,CAAC,IAAI,CAAClB,QAAQ,EAAEgB,KAAK,EAAEA,KAAK,CAAChB,QAAQ,EAAEW,QAAQ,CAAC;EACnE,CAAC;EAED;;;;EAIAvC,gCAAA,CAAAgB,SAAA,CAAA+B,KAAK,GAAL;IACE,OAAO,IAAI/C,gCAAgC,CACzC,IAAI,CAACC,SAAS,EACd,IAAI,CAACC,QAAQ,EACb,IAAI,CAACC,aAAa,EAClB,IAAI,CAACC,IAAI,EACT,IAAI,CAACC,MAAM,EACX,IAAI,CAACC,UAAU,EACf,IAAI,CAACC,IAAI,EACT,IAAI,CAACC,IAAI,EACT,IAAI,CAACgB,QAAQ,CAACuB,KAAK,EAAE,EACrB,IAAI,CAACnB,QAAQ,CAACmB,KAAK,EAAE,EACrB,IAAI,CAACpC,QAAQ,CACd;EACH,CAAC;EAED;;;;;EAKQX,gCAAA,CAAAgB,SAAA,CAAAoB,cAAc,GAAtB,UAAuBY,OAAgB,EAAE9B,KAAa,EAAEiB,SAAiB;IACvE,IAAIc,KAAK,GAAG,IAAI,CAACtC,QAAQ,CAACuC,UAAU,CAAChC,KAAK,CAAC;IAE3C;IACA,IAAIiC,eAAe,GAAG,KAAK;IAC3B,IAAI7D,IAAI,GAAG,CAAC;IACZ,IAAID,GAAG,GAAG,CAAC;IAEX,IAAI2D,OAAO,CAACI,MAAM,KAAK,CAAC,EAAE;MACxBJ,OAAO,CAACK,UAAU,GAAGJ,KAAK;MAC1BD,OAAO,CAACM,QAAQ,GAAGN,OAAO,CAACK,UAAU;MACrCL,OAAO,CAACO,SAAS,GAAGP,OAAO,CAACK,UAAU;KACvC,MAAM,IACLJ,KAAK,GAAGD,OAAO,CAACK,UAAU,IAC1BL,OAAO,CAACM,QAAQ,GAAGL,KAAK,IAAI,IAAI,CAAC/C,QAAQ,EACzC;MACAiD,eAAe,GAAG,IAAI;MACtB9D,GAAG,GAAG4D,KAAK;MACX3D,IAAI,GAAG0D,OAAO,CAACM,QAAQ;KACxB,MAAM,IACLL,KAAK,GAAGD,OAAO,CAACM,QAAQ,IACxBL,KAAK,GAAGD,OAAO,CAACK,UAAU,IAAI,IAAI,CAACnD,QAAQ,EAC3C;MACAiD,eAAe,GAAG,IAAI;MACtB9D,GAAG,GAAG2D,OAAO,CAACK,UAAU;MACxB/D,IAAI,GAAG2D,KAAK;;IAGd;IACA,IAAIE,eAAe,EAAE;MACnB,IAAMK,MAAM,GAAG,IAAI,CAACC,YAAY,CAACnE,IAAI,EAAED,GAAG,CAAC;MAC3C,IAAI,CAACoD,UAAU,CAACe,MAAM,CAAC;MACvBP,KAAK,GAAG,IAAI,CAACtC,QAAQ,CAACuC,UAAU,CAAChC,KAAK,CAAC;;IAGzC,IAAI,CAACwC,iBAAiB,CAACV,OAAO,EAAEC,KAAK,EAAEd,SAAS,CAAC;EACnD,CAAC;EAED;;;;;;EAMQnC,gCAAA,CAAAgB,SAAA,CAAA0C,iBAAiB,GAAzB,UACEV,OAAgB,EAChBC,KAAa,EACbd,SAAiB;IAEjB,IAAIA,SAAS,KAAK,CAAC,EAAE;MACnB;MACA;;IAGF,IAAIc,KAAK,GAAGD,OAAO,CAACK,UAAU,EAAE;MAC9B,IAAMM,IAAI,GAAGX,OAAO,CAACM,QAAQ,GAAGL,KAAK;MACrC,IAAIU,IAAI,IAAIX,OAAO,CAACY,OAAO,CAACR,MAAM,EAAE;QAClC,IAAI,CAACS,KAAK,CAACb,OAAO,EAAEW,IAAI,GAAG,CAAC,CAAC;;MAE/BX,OAAO,CAACK,UAAU,GAAGJ,KAAK;KAC3B,MAAM,IAAIA,KAAK,GAAGD,OAAO,CAACM,QAAQ,EAAE;MACnC,IAAMK,IAAI,GAAGV,KAAK,GAAGD,OAAO,CAACK,UAAU;MACvC,IAAIM,IAAI,IAAIX,OAAO,CAACY,OAAO,CAACR,MAAM,EAAE;QAClC,IAAI,CAACS,KAAK,CAACb,OAAO,EAAEW,IAAI,GAAG,CAAC,CAAC;;MAE/BX,OAAO,CAACM,QAAQ,GAAGL,KAAK;;IAG1B,IAAIa,WAAW,GAAGb,KAAK,GAAGD,OAAO,CAACO,SAAS;IAC3C,IAAIO,WAAW,GAAG,CAAC,EAAE;MACnBA,WAAW,IAAId,OAAO,CAACY,OAAO,CAACR,MAAM;;IAEvCJ,OAAO,CAACe,eAAe,CAACD,WAAW,EAAE3B,SAAS,CAAC;EACjD,CAAC;EAED;;;;;EAKQnC,gCAAA,CAAAgB,SAAA,CAAA6C,KAAK,GAAb,UAAcb,OAAgB,EAAEgB,MAAc;IAC5C,IAAMC,IAAI,GAAGjB,OAAO,CAACY,OAAO,CAACR,MAAM;IACnC,IAAMc,IAAI,GAAGlB,OAAO,CAACO,SAAS,GAAGP,OAAO,CAACK,UAAU;IACnD,IAAMc,gBAAgB,GAAGF,IAAI,GAAGC,IAAI;IACpC,IAAIE,OAAO,GAAGjF,iBAAiB,CAAC6E,MAAM,CAAC;IACvC,IAAII,OAAO,GAAG,IAAI,CAAClE,QAAQ,EAAE;MAC3BkE,OAAO,GAAG,IAAI,CAAClE,QAAQ;;IAEzB,IAAMmE,gBAAgB,GAAGD,OAAO,GAAGF,IAAI;IACvClB,OAAO,CAACY,OAAO,CAACU,MAAM,CAACF,OAAO,EAAED,gBAAgB,EAAEE,gBAAgB,CAAC;EACrE,CAAC;EAED;;;;EAIQrE,gCAAA,CAAAgB,SAAA,CAAAyC,YAAY,GAApB,UAAqBnE,IAAY,EAAED,GAAW;IAC5C,IAAImE,MAAM,GAAG,CAAC;IACd,OAAOlE,IAAI,GAAGD,GAAG,IAAI,IAAI,CAACa,QAAQ,EAAE;MAClCZ,IAAI,KAAK,CAAC;MACVD,GAAG,KAAK,CAAC;MACTmE,MAAM,EAAE;;IAEV,OAAOA,MAAM;EACf,CAAC;EAED;;;EAGQxD,gCAAA,CAAAgB,SAAA,CAAAyB,UAAU,GAAlB,UAAmBe,MAAc;IAC/B,IAAIA,MAAM,KAAK,CAAC,EAAE;MAChB;;IAEF,IAAIA,MAAM,GAAG,CAAC,EAAE;MACd;MACA;MACA,MAAM,IAAIe,KAAK,CAAC,iCAA+B,IAAI,CAACzC,KAAO,CAAC;;IAE9D,IAAM0C,QAAQ,GAAG,IAAI,CAAC7D,QAAQ,CAACmB,KAAK,GAAG0B,MAAM;IAE7C,IAAI,CAAC/C,SAAS,CAACgE,SAAS,CAACjB,MAAM,CAAC;IAChC,IAAI,CAAC9C,SAAS,CAAC+D,SAAS,CAACjB,MAAM,CAAC;IAEhC,IAAI,CAAC7C,QAAQ,GAAGzB,UAAU,CAACsF,QAAQ,CAAC;EACtC,CAAC;EAED;;;EAGQxE,gCAAA,CAAAgB,SAAA,CAAAwB,SAAS,GAAjB,UAAkBI,KAAuC;IACvD,IAAML,QAAQ,GAAG7C,IAAI,CAACC,GAAG,CAAC,IAAI,CAACmC,KAAK,EAAEc,KAAK,CAACd,KAAK,CAAC;IAElD,IAAM4C,UAAU,GAAGtF,OAAO,CAACG,OAAO,CAChC,IAAI,CAACoF,eAAe,CAAC,IAAI,CAACnD,QAAQ,EAAE,IAAI,CAACM,KAAK,EAAES,QAAQ,CAAC,EACzD,IAAI,CAACoC,eAAe,CAAC/B,KAAK,CAACpB,QAAQ,EAAEoB,KAAK,CAACd,KAAK,EAAES,QAAQ,CAAC,CAC5D;IAED,IAAMqC,UAAU,GAAGxF,OAAO,CAACG,OAAO,CAChC,IAAI,CAACoF,eAAe,CAAC,IAAI,CAAC/C,QAAQ,EAAE,IAAI,CAACE,KAAK,EAAES,QAAQ,CAAC,EACzD,IAAI,CAACoC,eAAe,CAAC/B,KAAK,CAAChB,QAAQ,EAAEgB,KAAK,CAACd,KAAK,EAAES,QAAQ,CAAC,CAC5D;IAED,OAAO7C,IAAI,CAACC,GAAG,CACb4C,QAAQ,GAAG,IAAI,CAACkB,YAAY,CAACiB,UAAU,CAACpF,IAAI,EAAEoF,UAAU,CAACrF,GAAG,CAAC,EAC7DkD,QAAQ,GAAG,IAAI,CAACkB,YAAY,CAACmB,UAAU,CAACtF,IAAI,EAAEsF,UAAU,CAACvF,GAAG,CAAC,CAC9D;EACH,CAAC;EAED;;;EAGQW,gCAAA,CAAAgB,SAAA,CAAA2D,eAAe,GAAvB,UACE3B,OAAgB,EAChB6B,YAAoB,EACpBL,QAAgB;IAEhB,IAAIxB,OAAO,CAACI,MAAM,KAAK,CAAC,EAAE;MACxB,OAAO,IAAIhE,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;;IAE3B,IAAM0F,KAAK,GAAGD,YAAY,GAAGL,QAAQ;IACrC,OAAO,IAAIpF,OAAO,CAAC4D,OAAO,CAACK,UAAU,IAAIyB,KAAK,EAAE9B,OAAO,CAACM,QAAQ,IAAIwB,KAAK,CAAC;EAC5E,CAAC;EAED;;;;EAIQ9E,gCAAA,CAAAgB,SAAA,CAAA0B,aAAa,GAArB,UACEqC,IAAa,EACbnC,KAAuC,EACvCoC,MAAe,EACflD,KAAa;IAEb,IAAMmD,WAAW,GAAGD,MAAM,CAACvD,MAAM;IACjC,IAAMyD,WAAW,GAAGtC,KAAK,CAACd,KAAK,GAAGA,KAAK;IAEvC,KAAK,IAAIqD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,CAAC5B,MAAM,EAAE+B,CAAC,EAAE,EAAE;MACtC,IAAI,CAACzB,iBAAiB,CACpBqB,IAAI,EACHE,WAAW,GAAGE,CAAC,IAAKD,WAAW,EAChCF,MAAM,CAACI,EAAE,CAACD,CAAC,CAAC,CACb;;EAEL,CAAC;EAED;;;;EAIQnF,gCAAA,CAAAgB,SAAA,CAAA8B,YAAY,GAApB,UACEiC,IAAa,EACbnC,KAAuC,EACvCoC,MAAe,EACflD,KAAa;IAEb,IAAMmD,WAAW,GAAGD,MAAM,CAACvD,MAAM;IACjC,IAAMyD,WAAW,GAAGtC,KAAK,CAACd,KAAK,GAAGA,KAAK;IAEvC,KAAK,IAAIqD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,CAAC5B,MAAM,EAAE+B,CAAC,EAAE,EAAE;MACtC,IAAME,QAAQ,GAAIJ,WAAW,GAAGE,CAAC,IAAKD,WAAW;MACjD,IAAIpB,WAAW,GAAGuB,QAAQ,GAAGN,IAAI,CAACxB,SAAS;MAC3C,IAAIO,WAAW,GAAG,CAAC,EAAE;QACnBA,WAAW,IAAIiB,IAAI,CAACnB,OAAO,CAACR,MAAM;;MAEpC2B,IAAI,CAACO,eAAe,CAACxB,WAAW,EAAEkB,MAAM,CAACI,EAAE,CAACD,CAAC,CAAC,CAAC;;IAGjDJ,IAAI,CAACQ,IAAI,EAAE;EACb,CAAC;EACH,OAAAvF,gCAAC;AAAD,CAAC,CApbD;;AAsbA;;;AAGA,IAAAwF,8BAAA;EAME;;;;;;EAMA,SAAAA,+BACWtF,QAAgB,EACRC,aAAsB;IAD9B,KAAAD,QAAQ,GAARA,QAAQ;IACA,KAAAC,aAAa,GAAbA,aAAa;IAXzB,KAAAsF,IAAI,GACT5G,cAAc,CAAC6G,qBAAqB;EAWnC;EAEHF,8BAAA,CAAAxE,SAAA,CAAA2E,kBAAkB,GAAlB,UAAmB1F,SAAiB;IAClC,OAAO,IAAID,gCAAgC,CACzCC,SAAS,EACT,IAAI,CAACC,QAAQ,EACb,IAAI,CAACC,aAAa,CACnB;EACH,CAAC;EAED;;;EAGAqF,8BAAA,CAAAxE,SAAA,CAAAqB,KAAK,GAAL,UACEC,QAA0C,EAC1CsD,KAAuC;IAEvC,IAAMC,MAAM,GAAGD,KAAK,CAAC7C,KAAK,EAAE;IAC5B8C,MAAM,CAACxD,KAAK,CAACC,QAAQ,CAAC;IAEtB,OAAOuD,MAAM;EACf,CAAC;EAED;;;EAGAL,8BAAA,CAAAxE,SAAA,CAAA2B,IAAI,GAAJ,UACEL,QAA0C,EAC1CwD,OAAyC;IAEzC,IAAMD,MAAM,GAAGC,OAAO,CAAC/C,KAAK,EAAE;IAC9B8C,MAAM,CAAClD,IAAI,CAACL,QAAQ,CAAC;IAErB,OAAOuD,MAAM;EACf,CAAC;EAEDL,8BAAA,CAAAxE,SAAA,CAAA+E,YAAY,GAAZ,UACEC,UAA4B,EAC5BC,sBAA8C,EAC9CC,wBAAgF,EAChFC,OAAe;IAEf,OAAO;MACLH,UAAU,EAAAA,UAAA;MACVC,sBAAsB,EAAAA,sBAAA;MACtBG,aAAa,EAAEtH,aAAa,CAAC4G,qBAAqB;MAClDW,UAAU,EAAEH,wBAAwB,CAACI,GAAG,CAAC,UAACC,EAA0B;YAA1BC,EAAA,GAAAC,MAAA,CAAAF,EAAA,IAA0B;UAAzBG,UAAU,GAAAF,EAAA;UAAEG,YAAY,GAAAH,EAAA;QACjE,IAAMI,UAAU,GAAGD,YAAY,CAACtF,YAAY,EAAE;QAE9C;QACA,IAAMwF,oBAAoB,GACxBb,UAAU,CAACc,IAAI,KAAK9H,cAAc,CAAC+H,eAAe,IAClDf,UAAU,CAACc,IAAI,KAAK9H,cAAc,CAACgI,gBAAgB,IACnDhB,UAAU,CAACc,IAAI,KAAK9H,cAAc,CAACiI,0BAA0B;QAE/D,OAAO;UACLP,UAAU,EAAAA,UAAA;UACVzG,SAAS,EAAE0G,YAAY,CAAC1G,SAAS;UACjCkG,OAAO,EAAAA,OAAA;UACPjF,KAAK,EAAE;YACLvB,GAAG,EAAEiH,UAAU,CAACtF,SAAS,GAAGsF,UAAU,CAACjH,GAAG,GAAGuH,SAAS;YACtDtH,GAAG,EAAEgH,UAAU,CAACtF,SAAS,GAAGsF,UAAU,CAAChH,GAAG,GAAGsH,SAAS;YACtD3F,GAAG,EAAE,CAACsF,oBAAoB,GAAGD,UAAU,CAACrF,GAAG,GAAG2F,SAAS;YACvD1F,QAAQ,EAAE;cACRC,MAAM,EAAEmF,UAAU,CAACpF,QAAQ,CAACC,MAAM;cAClCC,YAAY,EAAEkF,UAAU,CAACpF,QAAQ,CAACE;aACnC;YACDE,QAAQ,EAAE;cACRH,MAAM,EAAEmF,UAAU,CAAChF,QAAQ,CAACH,MAAM;cAClCC,YAAY,EAAEkF,UAAU,CAAChF,QAAQ,CAACF;aACnC;YACDG,KAAK,EAAE+E,UAAU,CAAC/E,KAAK;YACvBC,KAAK,EAAE8E,UAAU,CAAC9E,KAAK;YACvBC,SAAS,EAAE6E,UAAU,CAAC7E;;SAEzB;MACH,CAAC;KACF;EACH,CAAC;EACH,OAAAyD,8BAAC;AAAD,CAAC,CA9FD"},"metadata":{},"sourceType":"module","externalDependencies":[]}