{"ast":null,"code":"import { TransportItemType } from '../../transports';\nimport { deepEqual, defaultLogLevel, getCurrentTimestamp, isNull } from '../../utils';\nexport function initializeLogsAPI(_unpatchedConsole, internalLogger, config, metas, transports, tracesApi) {\n  internalLogger.debug('Initializing logs API');\n  let lastPayload = null;\n  const pushLog = function (args) {\n    let {\n      context,\n      level,\n      skipDedupe\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    try {\n      const item = {\n        type: TransportItemType.LOG,\n        payload: {\n          message: args.map(arg => {\n            try {\n              return String(arg);\n            } catch (err) {\n              return '';\n            }\n          }).join(' '),\n          level: level !== null && level !== void 0 ? level : defaultLogLevel,\n          context: context !== null && context !== void 0 ? context : {},\n          timestamp: getCurrentTimestamp(),\n          trace: tracesApi.getTraceContext()\n        },\n        meta: metas.value\n      };\n      const testingPayload = {\n        message: item.payload.message,\n        level: item.payload.level,\n        context: item.payload.context\n      };\n      if (!skipDedupe && config.dedupe && !isNull(lastPayload) && deepEqual(testingPayload, lastPayload)) {\n        internalLogger.debug('Skipping log push because it is the same as the last one\\n', item.payload);\n        return;\n      }\n      lastPayload = testingPayload;\n      internalLogger.debug('Pushing log\\n', item);\n      transports.execute(item);\n    } catch (err) {\n      internalLogger.error('Error pushing log\\n', err);\n    }\n  };\n  return {\n    pushLog\n  };\n}","map":{"version":3,"names":["TransportItemType","deepEqual","defaultLogLevel","getCurrentTimestamp","isNull","initializeLogsAPI","_unpatchedConsole","internalLogger","config","metas","transports","tracesApi","debug","lastPayload","pushLog","args","context","level","skipDedupe","arguments","length","undefined","item","type","LOG","payload","message","map","arg","String","err","join","timestamp","trace","getTraceContext","meta","value","testingPayload","dedupe","execute","error"],"sources":["/home/egor/node_modules/@grafana/faro-core/src/api/logs/initialize.ts"],"sourcesContent":["import type { Config } from '../../config';\nimport type { InternalLogger } from '../../internalLogger';\nimport type { Metas } from '../../metas';\nimport { TransportItem, TransportItemType } from '../../transports';\nimport type { Transports } from '../../transports';\nimport type { UnpatchedConsole } from '../../unpatchedConsole';\nimport { deepEqual, defaultLogLevel, getCurrentTimestamp, isNull } from '../../utils';\nimport type { TracesAPI } from '../traces';\n\nimport type { LogEvent, LogsAPI } from './types';\n\nexport function initializeLogsAPI(\n  _unpatchedConsole: UnpatchedConsole,\n  internalLogger: InternalLogger,\n  config: Config,\n  metas: Metas,\n  transports: Transports,\n  tracesApi: TracesAPI\n): LogsAPI {\n  internalLogger.debug('Initializing logs API');\n\n  let lastPayload: Pick<LogEvent, 'message' | 'level' | 'context'> | null = null;\n\n  const pushLog: LogsAPI['pushLog'] = (args, { context, level, skipDedupe } = {}) => {\n    try {\n      const item: TransportItem<LogEvent> = {\n        type: TransportItemType.LOG,\n        payload: {\n          message: args\n            .map((arg) => {\n              try {\n                return String(arg);\n              } catch (err) {\n                return '';\n              }\n            })\n            .join(' '),\n          level: level ?? defaultLogLevel,\n          context: context ?? {},\n          timestamp: getCurrentTimestamp(),\n          trace: tracesApi.getTraceContext(),\n        },\n        meta: metas.value,\n      };\n\n      const testingPayload = {\n        message: item.payload.message,\n        level: item.payload.level,\n        context: item.payload.context,\n      };\n\n      if (!skipDedupe && config.dedupe && !isNull(lastPayload) && deepEqual(testingPayload, lastPayload)) {\n        internalLogger.debug('Skipping log push because it is the same as the last one\\n', item.payload);\n\n        return;\n      }\n\n      lastPayload = testingPayload;\n\n      internalLogger.debug('Pushing log\\n', item);\n\n      transports.execute(item);\n    } catch (err) {\n      internalLogger.error('Error pushing log\\n', err);\n    }\n  };\n\n  return {\n    pushLog,\n  };\n}\n"],"mappings":"AAGA,SAAwBA,iBAAiB,QAAQ,kBAAkB;AAGnE,SAASC,SAAS,EAAEC,eAAe,EAAEC,mBAAmB,EAAEC,MAAM,QAAQ,aAAa;AAKrF,OAAM,SAAUC,iBAAiBA,CAC/BC,iBAAmC,EACnCC,cAA8B,EAC9BC,MAAc,EACdC,KAAY,EACZC,UAAsB,EACtBC,SAAoB;EAEpBJ,cAAc,CAACK,KAAK,CAAC,uBAAuB,CAAC;EAE7C,IAAIC,WAAW,GAA2D,IAAI;EAE9E,MAAMC,OAAO,GAAuB,SAAAA,CAACC,IAAI,EAAyC;IAAA,IAAvC;MAAEC,OAAO;MAAEC,KAAK;MAAEC;IAAU,CAAE,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;IAC5E,IAAI;MACF,MAAMG,IAAI,GAA4B;QACpCC,IAAI,EAAEvB,iBAAiB,CAACwB,GAAG;QAC3BC,OAAO,EAAE;UACPC,OAAO,EAAEX,IAAI,CACVY,GAAG,CAAEC,GAAG,IAAI;YACX,IAAI;cACF,OAAOC,MAAM,CAACD,GAAG,CAAC;aACnB,CAAC,OAAOE,GAAG,EAAE;cACZ,OAAO,EAAE;;UAEb,CAAC,CAAC,CACDC,IAAI,CAAC,GAAG,CAAC;UACZd,KAAK,EAAEA,KAAK,aAALA,KAAK,cAALA,KAAK,GAAIf,eAAe;UAC/Bc,OAAO,EAAEA,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI,EAAE;UACtBgB,SAAS,EAAE7B,mBAAmB,EAAE;UAChC8B,KAAK,EAAEtB,SAAS,CAACuB,eAAe;SACjC;QACDC,IAAI,EAAE1B,KAAK,CAAC2B;OACb;MAED,MAAMC,cAAc,GAAG;QACrBX,OAAO,EAAEJ,IAAI,CAACG,OAAO,CAACC,OAAO;QAC7BT,KAAK,EAAEK,IAAI,CAACG,OAAO,CAACR,KAAK;QACzBD,OAAO,EAAEM,IAAI,CAACG,OAAO,CAACT;OACvB;MAED,IAAI,CAACE,UAAU,IAAIV,MAAM,CAAC8B,MAAM,IAAI,CAAClC,MAAM,CAACS,WAAW,CAAC,IAAIZ,SAAS,CAACoC,cAAc,EAAExB,WAAW,CAAC,EAAE;QAClGN,cAAc,CAACK,KAAK,CAAC,4DAA4D,EAAEU,IAAI,CAACG,OAAO,CAAC;QAEhG;;MAGFZ,WAAW,GAAGwB,cAAc;MAE5B9B,cAAc,CAACK,KAAK,CAAC,eAAe,EAAEU,IAAI,CAAC;MAE3CZ,UAAU,CAAC6B,OAAO,CAACjB,IAAI,CAAC;KACzB,CAAC,OAAOQ,GAAG,EAAE;MACZvB,cAAc,CAACiC,KAAK,CAAC,qBAAqB,EAAEV,GAAG,CAAC;;EAEpD,CAAC;EAED,OAAO;IACLhB;GACD;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}