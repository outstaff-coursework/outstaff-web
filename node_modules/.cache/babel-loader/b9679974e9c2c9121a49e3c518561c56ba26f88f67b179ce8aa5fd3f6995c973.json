{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Allows synchronous collection of metrics. This processor should allow\n * allocation of new aggregation cells for metrics and convert cumulative\n * recording to delta data points.\n */\nvar DeltaMetricProcessor = /** @class */function () {\n  function DeltaMetricProcessor(_aggregator) {\n    this._aggregator = _aggregator;\n    this._activeCollectionStorage = new AttributeHashMap();\n    // TODO: find a reasonable mean to clean the memo;\n    // https://github.com/open-telemetry/opentelemetry-specification/pull/2208\n    this._cumulativeMemoStorage = new AttributeHashMap();\n  }\n  DeltaMetricProcessor.prototype.record = function (value, attributes, _context, collectionTime) {\n    var _this = this;\n    var accumulation = this._activeCollectionStorage.getOrDefault(attributes, function () {\n      return _this._aggregator.createAccumulation(collectionTime);\n    });\n    accumulation === null || accumulation === void 0 ? void 0 : accumulation.record(value);\n  };\n  DeltaMetricProcessor.prototype.batchCumulate = function (measurements, collectionTime) {\n    var _this = this;\n    Array.from(measurements.entries()).forEach(function (_a) {\n      var _b = __read(_a, 3),\n        attributes = _b[0],\n        value = _b[1],\n        hashCode = _b[2];\n      var accumulation = _this._aggregator.createAccumulation(collectionTime);\n      accumulation === null || accumulation === void 0 ? void 0 : accumulation.record(value);\n      var delta = accumulation;\n      // Diff with recorded cumulative memo.\n      if (_this._cumulativeMemoStorage.has(attributes, hashCode)) {\n        // has() returned true, previous is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        var previous = _this._cumulativeMemoStorage.get(attributes, hashCode);\n        delta = _this._aggregator.diff(previous, accumulation);\n      }\n      // Merge with uncollected active delta.\n      if (_this._activeCollectionStorage.has(attributes, hashCode)) {\n        // has() returned true, previous is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        var active = _this._activeCollectionStorage.get(attributes, hashCode);\n        delta = _this._aggregator.merge(active, delta);\n      }\n      // Save the current record and the delta record.\n      _this._cumulativeMemoStorage.set(attributes, accumulation, hashCode);\n      _this._activeCollectionStorage.set(attributes, delta, hashCode);\n    });\n  };\n  /**\n   * Returns a collection of delta metrics. Start time is the when first\n   * time event collected.\n   */\n  DeltaMetricProcessor.prototype.collect = function () {\n    var unreportedDelta = this._activeCollectionStorage;\n    this._activeCollectionStorage = new AttributeHashMap();\n    return unreportedDelta;\n  };\n  return DeltaMetricProcessor;\n}();\nexport { DeltaMetricProcessor };","map":{"version":3,"names":["AttributeHashMap","DeltaMetricProcessor","_aggregator","_activeCollectionStorage","_cumulativeMemoStorage","prototype","record","value","attributes","_context","collectionTime","_this","accumulation","getOrDefault","createAccumulation","batchCumulate","measurements","Array","from","entries","forEach","_a","_b","__read","hashCode","delta","has","previous","get","diff","active","merge","set","collect","unreportedDelta"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/state/DeltaMetricProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, HrTime, MetricAttributes } from '@opentelemetry/api';\nimport { Maybe } from '../utils';\nimport { Accumulation, Aggregator } from '../aggregator/types';\nimport { AttributeHashMap } from './HashMap';\n\n/**\n * Internal interface.\n *\n * Allows synchronous collection of metrics. This processor should allow\n * allocation of new aggregation cells for metrics and convert cumulative\n * recording to delta data points.\n */\nexport class DeltaMetricProcessor<T extends Maybe<Accumulation>> {\n  private _activeCollectionStorage = new AttributeHashMap<T>();\n  // TODO: find a reasonable mean to clean the memo;\n  // https://github.com/open-telemetry/opentelemetry-specification/pull/2208\n  private _cumulativeMemoStorage = new AttributeHashMap<T>();\n\n  constructor(private _aggregator: Aggregator<T>) {}\n\n  record(\n    value: number,\n    attributes: MetricAttributes,\n    _context: Context,\n    collectionTime: HrTime\n  ) {\n    const accumulation = this._activeCollectionStorage.getOrDefault(\n      attributes,\n      () => this._aggregator.createAccumulation(collectionTime)\n    );\n    accumulation?.record(value);\n  }\n\n  batchCumulate(\n    measurements: AttributeHashMap<number>,\n    collectionTime: HrTime\n  ) {\n    Array.from(measurements.entries()).forEach(\n      ([attributes, value, hashCode]) => {\n        const accumulation =\n          this._aggregator.createAccumulation(collectionTime);\n        accumulation?.record(value);\n        let delta = accumulation;\n        // Diff with recorded cumulative memo.\n        if (this._cumulativeMemoStorage.has(attributes, hashCode)) {\n          // has() returned true, previous is present.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const previous = this._cumulativeMemoStorage.get(\n            attributes,\n            hashCode\n          )!;\n          delta = this._aggregator.diff(previous, accumulation);\n        }\n        // Merge with uncollected active delta.\n        if (this._activeCollectionStorage.has(attributes, hashCode)) {\n          // has() returned true, previous is present.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const active = this._activeCollectionStorage.get(\n            attributes,\n            hashCode\n          )!;\n          delta = this._aggregator.merge(active, delta);\n        }\n\n        // Save the current record and the delta record.\n        this._cumulativeMemoStorage.set(attributes, accumulation, hashCode);\n        this._activeCollectionStorage.set(attributes, delta, hashCode);\n      }\n    );\n  }\n\n  /**\n   * Returns a collection of delta metrics. Start time is the when first\n   * time event collected.\n   */\n  collect() {\n    const unreportedDelta = this._activeCollectionStorage;\n    this._activeCollectionStorage = new AttributeHashMap();\n    return unreportedDelta;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA,SAASA,gBAAgB,QAAQ,WAAW;AAE5C;;;;;;;AAOA,IAAAC,oBAAA;EAME,SAAAA,qBAAoBC,WAA0B;IAA1B,KAAAA,WAAW,GAAXA,WAAW;IALvB,KAAAC,wBAAwB,GAAG,IAAIH,gBAAgB,EAAK;IAC5D;IACA;IACQ,KAAAI,sBAAsB,GAAG,IAAIJ,gBAAgB,EAAK;EAET;EAEjDC,oBAAA,CAAAI,SAAA,CAAAC,MAAM,GAAN,UACEC,KAAa,EACbC,UAA4B,EAC5BC,QAAiB,EACjBC,cAAsB;IAJxB,IAAAC,KAAA;IAME,IAAMC,YAAY,GAAG,IAAI,CAACT,wBAAwB,CAACU,YAAY,CAC7DL,UAAU,EACV;MAAM,OAAAG,KAAI,CAACT,WAAW,CAACY,kBAAkB,CAACJ,cAAc,CAAC;IAAnD,CAAmD,CAC1D;IACDE,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEN,MAAM,CAACC,KAAK,CAAC;EAC7B,CAAC;EAEDN,oBAAA,CAAAI,SAAA,CAAAU,aAAa,GAAb,UACEC,YAAsC,EACtCN,cAAsB;IAFxB,IAAAC,KAAA;IAIEM,KAAK,CAACC,IAAI,CAACF,YAAY,CAACG,OAAO,EAAE,CAAC,CAACC,OAAO,CACxC,UAACC,EAA6B;UAA7BC,EAAA,GAAAC,MAAA,CAAAF,EAAA,IAA6B;QAA5Bb,UAAU,GAAAc,EAAA;QAAEf,KAAK,GAAAe,EAAA;QAAEE,QAAQ,GAAAF,EAAA;MAC3B,IAAMV,YAAY,GAChBD,KAAI,CAACT,WAAW,CAACY,kBAAkB,CAACJ,cAAc,CAAC;MACrDE,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEN,MAAM,CAACC,KAAK,CAAC;MAC3B,IAAIkB,KAAK,GAAGb,YAAY;MACxB;MACA,IAAID,KAAI,CAACP,sBAAsB,CAACsB,GAAG,CAAClB,UAAU,EAAEgB,QAAQ,CAAC,EAAE;QACzD;QACA;QACA,IAAMG,QAAQ,GAAGhB,KAAI,CAACP,sBAAsB,CAACwB,GAAG,CAC9CpB,UAAU,EACVgB,QAAQ,CACR;QACFC,KAAK,GAAGd,KAAI,CAACT,WAAW,CAAC2B,IAAI,CAACF,QAAQ,EAAEf,YAAY,CAAC;;MAEvD;MACA,IAAID,KAAI,CAACR,wBAAwB,CAACuB,GAAG,CAAClB,UAAU,EAAEgB,QAAQ,CAAC,EAAE;QAC3D;QACA;QACA,IAAMM,MAAM,GAAGnB,KAAI,CAACR,wBAAwB,CAACyB,GAAG,CAC9CpB,UAAU,EACVgB,QAAQ,CACR;QACFC,KAAK,GAAGd,KAAI,CAACT,WAAW,CAAC6B,KAAK,CAACD,MAAM,EAAEL,KAAK,CAAC;;MAG/C;MACAd,KAAI,CAACP,sBAAsB,CAAC4B,GAAG,CAACxB,UAAU,EAAEI,YAAY,EAAEY,QAAQ,CAAC;MACnEb,KAAI,CAACR,wBAAwB,CAAC6B,GAAG,CAACxB,UAAU,EAAEiB,KAAK,EAAED,QAAQ,CAAC;IAChE,CAAC,CACF;EACH,CAAC;EAED;;;;EAIAvB,oBAAA,CAAAI,SAAA,CAAA4B,OAAO,GAAP;IACE,IAAMC,eAAe,GAAG,IAAI,CAAC/B,wBAAwB;IACrD,IAAI,CAACA,wBAAwB,GAAG,IAAIH,gBAAgB,EAAE;IACtD,OAAOkC,eAAe;EACxB,CAAC;EACH,OAAAjC,oBAAC;AAAD,CAAC,CApED"},"metadata":{},"sourceType":"module","externalDependencies":[]}