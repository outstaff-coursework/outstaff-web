{"ast":null,"code":"import { isString } from '../utils';\nimport { BatchExecutor } from './batchExecutor';\nimport { TransportItemType } from './const';\nexport function shouldIgnoreEvent(patterns, msg) {\n  return patterns.some(pattern => {\n    return isString(pattern) ? msg.includes(pattern) : !!msg.match(pattern);\n  });\n}\nexport function createBeforeSendHookFromIgnorePatterns(patterns) {\n  return item => {\n    if (item.type === TransportItemType.EXCEPTION && item.payload) {\n      const evt = item.payload;\n      const msg = `${evt.type}: ${evt.value}`;\n      if (shouldIgnoreEvent(patterns, msg)) {\n        return null;\n      }\n    }\n    return item;\n  };\n}\nexport function initializeTransports(unpatchedConsole, internalLogger, config, metas) {\n  var _a;\n  internalLogger.debug('Initializing transports');\n  const transports = [];\n  let paused = config.paused;\n  let beforeSendHooks = [];\n  const add = (...newTransports) => {\n    internalLogger.debug('Adding transports');\n    newTransports.forEach(newTransport => {\n      internalLogger.debug(`Adding \"${newTransport.name}\" transport`);\n      const exists = transports.some(existingTransport => existingTransport === newTransport);\n      if (exists) {\n        internalLogger.warn(`Transport ${newTransport.name} is already added`);\n        return;\n      }\n      newTransport.unpatchedConsole = unpatchedConsole;\n      newTransport.internalLogger = internalLogger;\n      newTransport.config = config;\n      newTransport.metas = metas;\n      transports.push(newTransport);\n    });\n  };\n  const addBeforeSendHooks = (...newBeforeSendHooks) => {\n    internalLogger.debug('Adding beforeSendHooks\\n', beforeSendHooks);\n    newBeforeSendHooks.forEach(beforeSendHook => {\n      if (beforeSendHook) {\n        beforeSendHooks.push(beforeSendHook);\n      }\n    });\n  };\n  const addIgnoreErrorsPatterns = (...ignoreErrorsPatterns) => {\n    internalLogger.debug('Adding ignoreErrorsPatterns\\n', ignoreErrorsPatterns);\n    ignoreErrorsPatterns.forEach(ignoreErrorsPattern => {\n      if (ignoreErrorsPattern) {\n        beforeSendHooks.push(createBeforeSendHookFromIgnorePatterns(ignoreErrorsPattern));\n      }\n    });\n  };\n  const applyBeforeSendHooks = items => {\n    let filteredItems = items;\n    for (const hook of beforeSendHooks) {\n      const modified = filteredItems.map(hook).filter(Boolean);\n      if (modified.length === 0) {\n        return [];\n      }\n      filteredItems = modified;\n    }\n    return filteredItems;\n  };\n  const batchedSend = items => {\n    const filteredItems = applyBeforeSendHooks(items);\n    if (filteredItems.length === 0) {\n      return;\n    }\n    for (const transport of transports) {\n      internalLogger.debug(`Transporting item using ${transport.name}\\n`, filteredItems);\n      if (transport.isBatched()) {\n        transport.send(filteredItems);\n      }\n    }\n  };\n  const instantSend = item => {\n    var _a, _b;\n    // prevent all beforeSend hooks being executed twice if batching is enabled.\n    if (((_a = config.batching) === null || _a === void 0 ? void 0 : _a.enabled) && transports.every(transport => transport.isBatched())) {\n      return;\n    }\n    const [filteredItem] = applyBeforeSendHooks([item]);\n    if (filteredItem === undefined) {\n      return;\n    }\n    for (const transport of transports) {\n      internalLogger.debug(`Transporting item using ${transport.name}\\n`, filteredItem);\n      if (!transport.isBatched()) {\n        transport.send(filteredItem);\n      } else if (!((_b = config.batching) === null || _b === void 0 ? void 0 : _b.enabled)) {\n        transport.send([filteredItem]);\n      }\n    }\n  };\n  let batchExecutor;\n  if ((_a = config.batching) === null || _a === void 0 ? void 0 : _a.enabled) {\n    batchExecutor = new BatchExecutor(batchedSend, {\n      sendTimeout: config.batching.sendTimeout,\n      itemLimit: config.batching.itemLimit,\n      paused\n    });\n  }\n  // Send a signal to the appropriate transports\n  //\n  // 1. If SDK is paused, early return\n  // 2. If batching is not enabled send the signal to all transports\n  //    instantly.\n  // 3i. If batching is enabled, enqueue the signal\n  // 3ii. Send the signal instantly to all un-batched transports\n  const execute = item => {\n    var _a;\n    if (paused) {\n      return;\n    }\n    if ((_a = config.batching) === null || _a === void 0 ? void 0 : _a.enabled) {\n      batchExecutor === null || batchExecutor === void 0 ? void 0 : batchExecutor.addItem(item);\n    }\n    instantSend(item);\n  };\n  const getBeforeSendHooks = () => [...beforeSendHooks];\n  const isPaused = () => paused;\n  const pause = () => {\n    internalLogger.debug('Pausing transports');\n    batchExecutor === null || batchExecutor === void 0 ? void 0 : batchExecutor.pause();\n    paused = true;\n  };\n  const remove = (...transportsToRemove) => {\n    internalLogger.debug('Removing transports');\n    transportsToRemove.forEach(transportToRemove => {\n      internalLogger.debug(`Removing \"${transportToRemove.name}\" transport`);\n      const existingTransportIndex = transports.indexOf(transportToRemove);\n      if (existingTransportIndex === -1) {\n        internalLogger.warn(`Transport \"${transportToRemove.name}\" is not added`);\n        return;\n      }\n      transports.splice(existingTransportIndex, 1);\n    });\n  };\n  const removeBeforeSendHooks = (...beforeSendHooksToRemove) => {\n    beforeSendHooks.filter(beforeSendHook => !beforeSendHooksToRemove.includes(beforeSendHook));\n  };\n  const unpause = () => {\n    internalLogger.debug('Unpausing transports');\n    batchExecutor === null || batchExecutor === void 0 ? void 0 : batchExecutor.start();\n    paused = false;\n  };\n  return {\n    add,\n    addBeforeSendHooks,\n    addIgnoreErrorsPatterns,\n    getBeforeSendHooks,\n    execute,\n    isPaused,\n    pause,\n    remove,\n    removeBeforeSendHooks,\n    get transports() {\n      return [...transports];\n    },\n    unpause\n  };\n}","map":{"version":3,"names":["isString","BatchExecutor","TransportItemType","shouldIgnoreEvent","patterns","msg","some","pattern","includes","match","createBeforeSendHookFromIgnorePatterns","item","type","EXCEPTION","payload","evt","value","initializeTransports","unpatchedConsole","internalLogger","config","metas","debug","transports","paused","beforeSendHooks","add","newTransports","forEach","newTransport","name","exists","existingTransport","warn","push","addBeforeSendHooks","newBeforeSendHooks","beforeSendHook","addIgnoreErrorsPatterns","ignoreErrorsPatterns","ignoreErrorsPattern","applyBeforeSendHooks","items","filteredItems","hook","modified","map","filter","Boolean","length","batchedSend","transport","isBatched","send","instantSend","_a","batching","enabled","every","filteredItem","undefined","_b","batchExecutor","sendTimeout","itemLimit","execute","addItem","getBeforeSendHooks","isPaused","pause","remove","transportsToRemove","transportToRemove","existingTransportIndex","indexOf","splice","removeBeforeSendHooks","beforeSendHooksToRemove","unpause","start"],"sources":["/home/egor/node_modules/@grafana/faro-core/src/transports/initialize.ts"],"sourcesContent":["import type { TransportItem } from '..';\nimport type { ExceptionEvent } from '../api';\nimport type { Config, Patterns } from '../config';\nimport type { InternalLogger } from '../internalLogger';\nimport type { Metas } from '../metas';\nimport type { UnpatchedConsole } from '../unpatchedConsole';\nimport { isString } from '../utils';\n\nimport { BatchExecutor } from './batchExecutor';\nimport { TransportItemType } from './const';\nimport type { BeforeSendHook, Transport, Transports } from './types';\n\nexport function shouldIgnoreEvent(patterns: Patterns, msg: string): boolean {\n  return patterns.some((pattern) => {\n    return isString(pattern) ? msg.includes(pattern) : !!msg.match(pattern);\n  });\n}\n\nexport function createBeforeSendHookFromIgnorePatterns(patterns: Patterns): BeforeSendHook {\n  return (item: TransportItem) => {\n    if (item.type === TransportItemType.EXCEPTION && item.payload) {\n      const evt = item.payload as ExceptionEvent;\n      const msg = `${evt.type}: ${evt.value}`;\n\n      if (shouldIgnoreEvent(patterns, msg)) {\n        return null;\n      }\n    }\n\n    return item;\n  };\n}\n\nexport function initializeTransports(\n  unpatchedConsole: UnpatchedConsole,\n  internalLogger: InternalLogger,\n  config: Config,\n  metas: Metas\n): Transports {\n  internalLogger.debug('Initializing transports');\n\n  const transports: Transport[] = [];\n\n  let paused = config.paused;\n\n  let beforeSendHooks: BeforeSendHook[] = [];\n\n  const add: Transports['add'] = (...newTransports) => {\n    internalLogger.debug('Adding transports');\n\n    newTransports.forEach((newTransport) => {\n      internalLogger.debug(`Adding \"${newTransport.name}\" transport`);\n\n      const exists = transports.some((existingTransport) => existingTransport === newTransport);\n\n      if (exists) {\n        internalLogger.warn(`Transport ${newTransport.name} is already added`);\n\n        return;\n      }\n\n      newTransport.unpatchedConsole = unpatchedConsole;\n      newTransport.internalLogger = internalLogger;\n      newTransport.config = config;\n      newTransport.metas = metas;\n\n      transports.push(newTransport);\n    });\n  };\n\n  const addBeforeSendHooks: Transports['addBeforeSendHooks'] = (...newBeforeSendHooks) => {\n    internalLogger.debug('Adding beforeSendHooks\\n', beforeSendHooks);\n\n    newBeforeSendHooks.forEach((beforeSendHook) => {\n      if (beforeSendHook) {\n        beforeSendHooks.push(beforeSendHook);\n      }\n    });\n  };\n\n  const addIgnoreErrorsPatterns: Transports['addIgnoreErrorsPatterns'] = (...ignoreErrorsPatterns) => {\n    internalLogger.debug('Adding ignoreErrorsPatterns\\n', ignoreErrorsPatterns);\n\n    ignoreErrorsPatterns.forEach((ignoreErrorsPattern) => {\n      if (ignoreErrorsPattern) {\n        beforeSendHooks.push(createBeforeSendHookFromIgnorePatterns(ignoreErrorsPattern));\n      }\n    });\n  };\n\n  const applyBeforeSendHooks = (items: TransportItem[]): TransportItem[] => {\n    let filteredItems = items;\n    for (const hook of beforeSendHooks) {\n      const modified = filteredItems.map(hook).filter(Boolean) as TransportItem[];\n\n      if (modified.length === 0) {\n        return [];\n      }\n\n      filteredItems = modified;\n    }\n    return filteredItems;\n  };\n\n  const batchedSend = (items: TransportItem[]) => {\n    const filteredItems = applyBeforeSendHooks(items);\n\n    if (filteredItems.length === 0) {\n      return;\n    }\n\n    for (const transport of transports) {\n      internalLogger.debug(`Transporting item using ${transport.name}\\n`, filteredItems);\n      if (transport.isBatched()) {\n        transport.send(filteredItems);\n      }\n    }\n  };\n\n  const instantSend = (item: TransportItem) => {\n    // prevent all beforeSend hooks being executed twice if batching is enabled.\n    if (config.batching?.enabled && transports.every((transport) => transport.isBatched())) {\n      return;\n    }\n\n    const [filteredItem] = applyBeforeSendHooks([item]);\n\n    if (filteredItem === undefined) {\n      return;\n    }\n\n    for (const transport of transports) {\n      internalLogger.debug(`Transporting item using ${transport.name}\\n`, filteredItem);\n      if (!transport.isBatched()) {\n        transport.send(filteredItem);\n      } else if (!config.batching?.enabled) {\n        transport.send([filteredItem]);\n      }\n    }\n  };\n\n  let batchExecutor: BatchExecutor | undefined;\n\n  if (config.batching?.enabled) {\n    batchExecutor = new BatchExecutor(batchedSend, {\n      sendTimeout: config.batching.sendTimeout,\n      itemLimit: config.batching.itemLimit,\n      paused,\n    });\n  }\n\n  // Send a signal to the appropriate transports\n  //\n  // 1. If SDK is paused, early return\n  // 2. If batching is not enabled send the signal to all transports\n  //    instantly.\n  // 3i. If batching is enabled, enqueue the signal\n  // 3ii. Send the signal instantly to all un-batched transports\n  const execute: Transports['execute'] = (item) => {\n    if (paused) {\n      return;\n    }\n\n    if (config.batching?.enabled) {\n      batchExecutor?.addItem(item);\n    }\n\n    instantSend(item);\n  };\n\n  const getBeforeSendHooks: Transports['getBeforeSendHooks'] = () => [...beforeSendHooks];\n\n  const isPaused: Transports['isPaused'] = () => paused;\n\n  const pause: Transports['pause'] = () => {\n    internalLogger.debug('Pausing transports');\n    batchExecutor?.pause();\n\n    paused = true;\n  };\n\n  const remove: Transports['remove'] = (...transportsToRemove) => {\n    internalLogger.debug('Removing transports');\n\n    transportsToRemove.forEach((transportToRemove) => {\n      internalLogger.debug(`Removing \"${transportToRemove.name}\" transport`);\n\n      const existingTransportIndex = transports.indexOf(transportToRemove);\n\n      if (existingTransportIndex === -1) {\n        internalLogger.warn(`Transport \"${transportToRemove.name}\" is not added`);\n\n        return;\n      }\n\n      transports.splice(existingTransportIndex, 1);\n    });\n  };\n\n  const removeBeforeSendHooks: Transports['removeBeforeSendHooks'] = (...beforeSendHooksToRemove) => {\n    beforeSendHooks.filter((beforeSendHook) => !beforeSendHooksToRemove.includes(beforeSendHook));\n  };\n\n  const unpause: Transports['unpause'] = () => {\n    internalLogger.debug('Unpausing transports');\n    batchExecutor?.start();\n\n    paused = false;\n  };\n\n  return {\n    add,\n    addBeforeSendHooks,\n    addIgnoreErrorsPatterns,\n    getBeforeSendHooks,\n    execute,\n    isPaused,\n    pause,\n    remove,\n    removeBeforeSendHooks,\n    get transports() {\n      return [...transports];\n    },\n    unpause,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}