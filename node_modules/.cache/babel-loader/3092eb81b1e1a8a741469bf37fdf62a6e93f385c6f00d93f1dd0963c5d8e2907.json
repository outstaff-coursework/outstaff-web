{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// https://tc39.es/proposal-regex-escaping\n// escape ^ $ \\ .  + ? ( ) [ ] { } |\n// do not need to escape * as we interpret it as wildcard\nvar ESCAPE = /[\\^$\\\\.+?()[\\]{}|]/g;\n/**\n * Wildcard pattern predicate, supports patterns like `*`, `foo*`, `*bar`.\n */\nvar PatternPredicate = /** @class */function () {\n  function PatternPredicate(pattern) {\n    if (pattern === '*') {\n      this._matchAll = true;\n      this._regexp = /.*/;\n    } else {\n      this._matchAll = false;\n      this._regexp = new RegExp(PatternPredicate.escapePattern(pattern));\n    }\n  }\n  PatternPredicate.prototype.match = function (str) {\n    if (this._matchAll) {\n      return true;\n    }\n    return this._regexp.test(str);\n  };\n  PatternPredicate.escapePattern = function (pattern) {\n    return \"^\" + pattern.replace(ESCAPE, '\\\\$&').replace('*', '.*') + \"$\";\n  };\n  PatternPredicate.hasWildcard = function (pattern) {\n    return pattern.includes('*');\n  };\n  return PatternPredicate;\n}();\nexport { PatternPredicate };\nvar ExactPredicate = /** @class */function () {\n  function ExactPredicate(pattern) {\n    this._matchAll = pattern === undefined;\n    this._pattern = pattern;\n  }\n  ExactPredicate.prototype.match = function (str) {\n    if (this._matchAll) {\n      return true;\n    }\n    if (str === this._pattern) {\n      return true;\n    }\n    return false;\n  };\n  return ExactPredicate;\n}();\nexport { ExactPredicate };","map":{"version":3,"names":["ESCAPE","PatternPredicate","pattern","_matchAll","_regexp","RegExp","escapePattern","prototype","match","str","test","replace","hasWildcard","includes","ExactPredicate","undefined","_pattern"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/view/Predicate.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// https://tc39.es/proposal-regex-escaping\n// escape ^ $ \\ .  + ? ( ) [ ] { } |\n// do not need to escape * as we interpret it as wildcard\nconst ESCAPE = /[\\^$\\\\.+?()[\\]{}|]/g;\n\nexport interface Predicate {\n  match(str: string): boolean;\n}\n\n/**\n * Wildcard pattern predicate, supports patterns like `*`, `foo*`, `*bar`.\n */\nexport class PatternPredicate implements Predicate {\n  private _matchAll: boolean;\n  private _regexp: RegExp;\n\n  constructor(pattern: string) {\n    if (pattern === '*') {\n      this._matchAll = true;\n      this._regexp = /.*/;\n    } else {\n      this._matchAll = false;\n      this._regexp = new RegExp(PatternPredicate.escapePattern(pattern));\n    }\n  }\n\n  match(str: string): boolean {\n    if (this._matchAll) {\n      return true;\n    }\n\n    return this._regexp.test(str);\n  }\n\n  static escapePattern(pattern: string): string {\n    return `^${pattern.replace(ESCAPE, '\\\\$&').replace('*', '.*')}$`;\n  }\n\n  static hasWildcard(pattern: string): boolean {\n    return pattern.includes('*');\n  }\n}\n\nexport class ExactPredicate implements Predicate {\n  private _matchAll: boolean;\n  private _pattern?: string;\n\n  constructor(pattern?: string) {\n    this._matchAll = pattern === undefined;\n    this._pattern = pattern;\n  }\n\n  match(str: string): boolean {\n    if (this._matchAll) {\n      return true;\n    }\n    if (str === this._pattern) {\n      return true;\n    }\n    return false;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA,IAAMA,MAAM,GAAG,qBAAqB;AAMpC;;;AAGA,IAAAC,gBAAA;EAIE,SAAAA,iBAAYC,OAAe;IACzB,IAAIA,OAAO,KAAK,GAAG,EAAE;MACnB,IAAI,CAACC,SAAS,GAAG,IAAI;MACrB,IAAI,CAACC,OAAO,GAAG,IAAI;KACpB,MAAM;MACL,IAAI,CAACD,SAAS,GAAG,KAAK;MACtB,IAAI,CAACC,OAAO,GAAG,IAAIC,MAAM,CAACJ,gBAAgB,CAACK,aAAa,CAACJ,OAAO,CAAC,CAAC;;EAEtE;EAEAD,gBAAA,CAAAM,SAAA,CAAAC,KAAK,GAAL,UAAMC,GAAW;IACf,IAAI,IAAI,CAACN,SAAS,EAAE;MAClB,OAAO,IAAI;;IAGb,OAAO,IAAI,CAACC,OAAO,CAACM,IAAI,CAACD,GAAG,CAAC;EAC/B,CAAC;EAEMR,gBAAA,CAAAK,aAAa,GAApB,UAAqBJ,OAAe;IAClC,OAAO,MAAIA,OAAO,CAACS,OAAO,CAACX,MAAM,EAAE,MAAM,CAAC,CAACW,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,MAAG;EAClE,CAAC;EAEMV,gBAAA,CAAAW,WAAW,GAAlB,UAAmBV,OAAe;IAChC,OAAOA,OAAO,CAACW,QAAQ,CAAC,GAAG,CAAC;EAC9B,CAAC;EACH,OAAAZ,gBAAC;AAAD,CAAC,CA7BD;;AA+BA,IAAAa,cAAA;EAIE,SAAAA,eAAYZ,OAAgB;IAC1B,IAAI,CAACC,SAAS,GAAGD,OAAO,KAAKa,SAAS;IACtC,IAAI,CAACC,QAAQ,GAAGd,OAAO;EACzB;EAEAY,cAAA,CAAAP,SAAA,CAAAC,KAAK,GAAL,UAAMC,GAAW;IACf,IAAI,IAAI,CAACN,SAAS,EAAE;MAClB,OAAO,IAAI;;IAEb,IAAIM,GAAG,KAAK,IAAI,CAACO,QAAQ,EAAE;MACzB,OAAO,IAAI;;IAEb,OAAO,KAAK;EACd,CAAC;EACH,OAAAF,cAAC;AAAD,CAAC,CAlBD"},"metadata":{},"sourceType":"module","externalDependencies":[]}