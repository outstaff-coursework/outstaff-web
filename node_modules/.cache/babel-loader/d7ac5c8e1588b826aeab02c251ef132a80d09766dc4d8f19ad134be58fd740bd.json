{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/// <reference types=\"zone.js\" />\nimport { ROOT_CONTEXT } from '@opentelemetry/api';\nimport { isListenerObject } from './util';\n/* Key name to be used to save a context reference in Zone */\nvar ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';\n/**\n * ZoneContextManager\n * This module provides an easy functionality for tracing action between asynchronous operations in web.\n * It was not possible with standard [StackContextManager]{@link https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-web/src/StackContextManager.ts}.\n * It heavily depends on [zone.js]{@link https://www.npmjs.com/package/zone.js}.\n * It stores the information about context in zone. Each Context will have always new Zone;\n * It also supports binding a certain Span to a target that has \"addEventListener\" and \"removeEventListener\".\n * When this happens a new zone is being created and the provided Span is being assigned to this zone.\n */\nvar ZoneContextManager = /** @class */function () {\n  function ZoneContextManager() {\n    /**\n     * whether the context manager is enabled or not\n     */\n    this._enabled = false;\n    /**\n     * Helps to create a unique name for the zones - part of zone name\n     */\n    this._zoneCounter = 0;\n  }\n  /**\n   * Returns the active context from certain zone name\n   * @param activeZone\n   */\n  ZoneContextManager.prototype._activeContextFromZone = function (activeZone) {\n    return activeZone && activeZone.get(ZONE_CONTEXT_KEY) || ROOT_CONTEXT;\n  };\n  /**\n   * @param context A context (span) to be executed within target function\n   * @param target Function to be executed within the context\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  ZoneContextManager.prototype._bindFunction = function (context, target) {\n    var manager = this;\n    var contextWrapper = function () {\n      var _this = this;\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return manager.with(context, function () {\n        return target.apply(_this, args);\n      });\n    };\n    Object.defineProperty(contextWrapper, 'length', {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: target.length\n    });\n    return contextWrapper;\n  };\n  /**\n   * @param context A context (span) to be bind to target\n   * @param obj target object on which the listeners will be patched\n   */\n  ZoneContextManager.prototype._bindListener = function (context, obj) {\n    var target = obj;\n    if (target.__ot_listeners !== undefined) {\n      return obj;\n    }\n    target.__ot_listeners = {};\n    if (typeof target.addEventListener === 'function') {\n      target.addEventListener = this._patchAddEventListener(target, target.addEventListener, context);\n    }\n    if (typeof target.removeEventListener === 'function') {\n      target.removeEventListener = this._patchRemoveEventListener(target, target.removeEventListener);\n    }\n    return obj;\n  };\n  /**\n   * Creates a new unique zone name\n   */\n  ZoneContextManager.prototype._createZoneName = function () {\n    this._zoneCounter++;\n    var random = Math.random();\n    return this._zoneCounter + \"-\" + random;\n  };\n  /**\n   * Creates a new zone\n   * @param zoneName zone name\n   * @param context A context (span) to be bind with Zone\n   */\n  ZoneContextManager.prototype._createZone = function (zoneName, context) {\n    var _a;\n    return Zone.current.fork({\n      name: zoneName,\n      properties: (_a = {}, _a[ZONE_CONTEXT_KEY] = context, _a)\n    });\n  };\n  /**\n   * Returns the active zone\n   */\n  ZoneContextManager.prototype._getActiveZone = function () {\n    return Zone.current;\n  };\n  /**\n   * Patches addEventListener method\n   * @param target any target that has \"addEventListener\" method\n   * @param original reference to the patched method\n   * @param [context] context to be bind to the listener\n   */\n  ZoneContextManager.prototype._patchAddEventListener = function (target, original, context) {\n    var contextManager = this;\n    return function (event, listener, opts) {\n      if (target.__ot_listeners === undefined) {\n        target.__ot_listeners = {};\n      }\n      var listeners = target.__ot_listeners[event];\n      if (listeners === undefined) {\n        listeners = new WeakMap();\n        target.__ot_listeners[event] = listeners;\n      }\n      var patchedListener = contextManager.bind(context, listener);\n      // store a weak reference of the user listener to ours\n      listeners.set(listener, patchedListener);\n      return original.call(this, event, patchedListener, opts);\n    };\n  };\n  /**\n   * Patches removeEventListener method\n   * @param target any target that has \"removeEventListener\" method\n   * @param original reference to the patched method\n   */\n  ZoneContextManager.prototype._patchRemoveEventListener = function (target, original) {\n    return function (event, listener) {\n      if (target.__ot_listeners === undefined || target.__ot_listeners[event] === undefined) {\n        return original.call(this, event, listener);\n      }\n      var events = target.__ot_listeners[event];\n      var patchedListener = events.get(listener);\n      events.delete(listener);\n      return original.call(this, event, patchedListener || listener);\n    };\n  };\n  /**\n   * Returns the active context\n   */\n  ZoneContextManager.prototype.active = function () {\n    if (!this._enabled) {\n      return ROOT_CONTEXT;\n    }\n    var activeZone = this._getActiveZone();\n    var active = this._activeContextFromZone(activeZone);\n    if (active) {\n      return active;\n    }\n    return ROOT_CONTEXT;\n  };\n  /**\n   * Binds a the certain context or the active one to the target function and then returns the target\n   * @param context A context (span) to be bind to target\n   * @param target a function or event emitter. When target or one of its callbacks is called,\n   *  the provided context will be used as the active context for the duration of the call.\n   */\n  ZoneContextManager.prototype.bind = function (context, target) {\n    // if no specific context to propagate is given, we use the current one\n    if (context === undefined) {\n      context = this.active();\n    }\n    if (typeof target === 'function') {\n      return this._bindFunction(context, target);\n    } else if (isListenerObject(target)) {\n      this._bindListener(context, target);\n    }\n    return target;\n  };\n  /**\n   * Disable the context manager (clears all the contexts)\n   */\n  ZoneContextManager.prototype.disable = function () {\n    this._enabled = false;\n    return this;\n  };\n  /**\n   * Enables the context manager and creates a default(root) context\n   */\n  ZoneContextManager.prototype.enable = function () {\n    this._enabled = true;\n    return this;\n  };\n  /**\n   * Calls the callback function [fn] with the provided [context].\n   *     If [context] is undefined then it will use the active context.\n   *     The context will be set as active\n   * @param context A context (span) to be called with provided callback\n   * @param fn Callback function\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  ZoneContextManager.prototype.with = function (context, fn, thisArg) {\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n      args[_i - 3] = arguments[_i];\n    }\n    var zoneName = this._createZoneName();\n    var newZone = this._createZone(zoneName, context);\n    return newZone.run(fn, thisArg, args);\n  };\n  return ZoneContextManager;\n}();\nexport { ZoneContextManager };","map":{"version":3,"names":["ROOT_CONTEXT","isListenerObject","ZONE_CONTEXT_KEY","ZoneContextManager","_enabled","_zoneCounter","prototype","_activeContextFromZone","activeZone","get","_bindFunction","context","target","manager","contextWrapper","_this","args","_i","arguments","length","with","apply","Object","defineProperty","enumerable","configurable","writable","value","_bindListener","obj","__ot_listeners","undefined","addEventListener","_patchAddEventListener","removeEventListener","_patchRemoveEventListener","_createZoneName","random","Math","_createZone","zoneName","Zone","current","fork","name","properties","_a","_getActiveZone","original","contextManager","event","listener","opts","listeners","WeakMap","patchedListener","bind","set","call","events","delete","active","disable","enable","fn","thisArg","newZone","run"],"sources":["/home/egor/node_modules/@opentelemetry/context-zone-peer-dep/src/ZoneContextManager.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/// <reference types=\"zone.js\" />\nimport { Context, ContextManager, ROOT_CONTEXT } from '@opentelemetry/api';\nimport { TargetWithEvents } from './types';\nimport { isListenerObject } from './util';\n\n/* Key name to be used to save a context reference in Zone */\nconst ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';\n\n/**\n * ZoneContextManager\n * This module provides an easy functionality for tracing action between asynchronous operations in web.\n * It was not possible with standard [StackContextManager]{@link https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-web/src/StackContextManager.ts}.\n * It heavily depends on [zone.js]{@link https://www.npmjs.com/package/zone.js}.\n * It stores the information about context in zone. Each Context will have always new Zone;\n * It also supports binding a certain Span to a target that has \"addEventListener\" and \"removeEventListener\".\n * When this happens a new zone is being created and the provided Span is being assigned to this zone.\n */\nexport class ZoneContextManager implements ContextManager {\n  /**\n   * whether the context manager is enabled or not\n   */\n  private _enabled = false;\n\n  /**\n   * Helps to create a unique name for the zones - part of zone name\n   */\n  private _zoneCounter = 0;\n\n  /**\n   * Returns the active context from certain zone name\n   * @param activeZone\n   */\n  private _activeContextFromZone(activeZone: Zone | undefined): Context {\n    return (activeZone && activeZone.get(ZONE_CONTEXT_KEY)) || ROOT_CONTEXT;\n  }\n\n  /**\n   * @param context A context (span) to be executed within target function\n   * @param target Function to be executed within the context\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  private _bindFunction<T extends Function>(context: Context, target: T): T {\n    const manager = this;\n    const contextWrapper = function (this: unknown, ...args: unknown[]) {\n      return manager.with(context, () => target.apply(this, args));\n    };\n    Object.defineProperty(contextWrapper, 'length', {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: target.length,\n    });\n    return contextWrapper as unknown as T;\n  }\n\n  /**\n   * @param context A context (span) to be bind to target\n   * @param obj target object on which the listeners will be patched\n   */\n  private _bindListener<T>(context: Context, obj: T): T {\n    const target = obj as unknown as TargetWithEvents;\n    if (target.__ot_listeners !== undefined) {\n      return obj;\n    }\n    target.__ot_listeners = {};\n\n    if (typeof target.addEventListener === 'function') {\n      target.addEventListener = this._patchAddEventListener(\n        target,\n        target.addEventListener,\n        context\n      );\n    }\n\n    if (typeof target.removeEventListener === 'function') {\n      target.removeEventListener = this._patchRemoveEventListener(\n        target,\n        target.removeEventListener\n      );\n    }\n\n    return obj;\n  }\n\n  /**\n   * Creates a new unique zone name\n   */\n  private _createZoneName() {\n    this._zoneCounter++;\n    const random = Math.random();\n    return `${this._zoneCounter}-${random}`;\n  }\n\n  /**\n   * Creates a new zone\n   * @param zoneName zone name\n   * @param context A context (span) to be bind with Zone\n   */\n  private _createZone(zoneName: string, context: unknown): Zone {\n    return Zone.current.fork({\n      name: zoneName,\n      properties: {\n        [ZONE_CONTEXT_KEY]: context,\n      },\n    });\n  }\n\n  /**\n   * Returns the active zone\n   */\n  private _getActiveZone(): Zone | undefined {\n    return Zone.current;\n  }\n\n  /**\n   * Patches addEventListener method\n   * @param target any target that has \"addEventListener\" method\n   * @param original reference to the patched method\n   * @param [context] context to be bind to the listener\n   */\n  private _patchAddEventListener(\n    target: TargetWithEvents,\n    original: NonNullable<TargetWithEvents['addEventListener']>,\n    context: Context\n  ) {\n    const contextManager = this;\n\n    return function (this: TargetWithEvents, event, listener, opts) {\n      if (target.__ot_listeners === undefined) {\n        target.__ot_listeners = {};\n      }\n      let listeners = target.__ot_listeners[event];\n      if (listeners === undefined) {\n        listeners = new WeakMap();\n        target.__ot_listeners[event] = listeners;\n      }\n      const patchedListener = contextManager.bind(context, listener);\n      // store a weak reference of the user listener to ours\n      listeners.set(listener, patchedListener);\n      return original.call(this, event, patchedListener, opts);\n    } as TargetWithEvents['addEventListener'];\n  }\n\n  /**\n   * Patches removeEventListener method\n   * @param target any target that has \"removeEventListener\" method\n   * @param original reference to the patched method\n   */\n  private _patchRemoveEventListener(\n    target: TargetWithEvents,\n    original: NonNullable<TargetWithEvents['removeEventListener']>\n  ) {\n    return function (this: TargetWithEvents, event, listener) {\n      if (\n        target.__ot_listeners === undefined ||\n        target.__ot_listeners[event] === undefined\n      ) {\n        return original.call(this, event, listener);\n      }\n      const events = target.__ot_listeners[event];\n      const patchedListener = events.get(listener);\n      events.delete(listener);\n      return original.call(this, event, patchedListener || listener);\n    } as TargetWithEvents['removeEventListener'];\n  }\n\n  /**\n   * Returns the active context\n   */\n  active(): Context {\n    if (!this._enabled) {\n      return ROOT_CONTEXT;\n    }\n    const activeZone = this._getActiveZone();\n\n    const active = this._activeContextFromZone(activeZone);\n    if (active) {\n      return active;\n    }\n\n    return ROOT_CONTEXT;\n  }\n\n  /**\n   * Binds a the certain context or the active one to the target function and then returns the target\n   * @param context A context (span) to be bind to target\n   * @param target a function or event emitter. When target or one of its callbacks is called,\n   *  the provided context will be used as the active context for the duration of the call.\n   */\n  bind<T>(context: Context, target: T | TargetWithEvents): T {\n    // if no specific context to propagate is given, we use the current one\n    if (context === undefined) {\n      context = this.active();\n    }\n    if (typeof target === 'function') {\n      return this._bindFunction(context, target);\n    } else if (isListenerObject(target)) {\n      this._bindListener(context, target);\n    }\n    return target as unknown as T;\n  }\n\n  /**\n   * Disable the context manager (clears all the contexts)\n   */\n  disable(): this {\n    this._enabled = false;\n    return this;\n  }\n\n  /**\n   * Enables the context manager and creates a default(root) context\n   */\n  enable(): this {\n    this._enabled = true;\n    return this;\n  }\n\n  /**\n   * Calls the callback function [fn] with the provided [context].\n   *     If [context] is undefined then it will use the active context.\n   *     The context will be set as active\n   * @param context A context (span) to be called with provided callback\n   * @param fn Callback function\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context | null,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    const zoneName = this._createZoneName();\n\n    const newZone = this._createZone(zoneName, context);\n\n    return newZone.run(fn, thisArg, args);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}