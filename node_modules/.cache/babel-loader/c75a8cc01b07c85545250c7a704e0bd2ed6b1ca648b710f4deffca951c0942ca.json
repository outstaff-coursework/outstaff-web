{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Buckets = /** @class */function () {\n  /**\n   * The term index refers to the number of the exponential histogram bucket\n   * used to determine its boundaries. The lower boundary of a bucket is\n   * determined by base ** index and the upper boundary of a bucket is\n   * determined by base ** (index + 1). index values are signed to account\n   * for values less than or equal to 1.\n   *\n   * indexBase is the index of the 0th position in the\n   * backing array, i.e., backing[0] is the count\n   * in the bucket with index `indexBase`.\n   *\n   * indexStart is the smallest index value represented\n   * in the backing array.\n   *\n   * indexEnd is the largest index value represented in\n   * the backing array.\n   */\n  function Buckets(backing, indexBase, indexStart, indexEnd) {\n    if (backing === void 0) {\n      backing = new BucketsBacking();\n    }\n    if (indexBase === void 0) {\n      indexBase = 0;\n    }\n    if (indexStart === void 0) {\n      indexStart = 0;\n    }\n    if (indexEnd === void 0) {\n      indexEnd = 0;\n    }\n    this.backing = backing;\n    this.indexBase = indexBase;\n    this.indexStart = indexStart;\n    this.indexEnd = indexEnd;\n  }\n  Object.defineProperty(Buckets.prototype, \"offset\", {\n    /**\n     * Offset is the bucket index of the smallest entry in the counts array\n     * @returns {number}\n     */\n    get: function () {\n      return this.indexStart;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Buckets.prototype, \"length\", {\n    /**\n     * Buckets is a view into the backing array.\n     * @returns {number}\n     */\n    get: function () {\n      if (this.backing.length === 0) {\n        return 0;\n      }\n      if (this.indexEnd === this.indexStart && this.at(0) === 0) {\n        return 0;\n      }\n      return this.indexEnd - this.indexStart + 1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * An array of counts, where count[i] carries the count\n   * of the bucket at index (offset+i).  count[i] is the count of\n   * values greater than base^(offset+i) and less than or equal to\n   * base^(offset+i+1).\n   * @returns {number} The logical counts based on the backing array\n   */\n  Buckets.prototype.counts = function () {\n    var _this = this;\n    return Array.from({\n      length: this.length\n    }, function (_, i) {\n      return _this.at(i);\n    });\n  };\n  /**\n   * At returns the count of the bucket at a position in the logical\n   * array of counts.\n   * @param position\n   * @returns {number}\n   */\n  Buckets.prototype.at = function (position) {\n    var bias = this.indexBase - this.indexStart;\n    if (position < bias) {\n      position += this.backing.length;\n    }\n    position -= bias;\n    return this.backing.countAt(position);\n  };\n  /**\n   * incrementBucket increments the backing array index by `increment`\n   * @param bucketIndex\n   * @param increment\n   */\n  Buckets.prototype.incrementBucket = function (bucketIndex, increment) {\n    this.backing.increment(bucketIndex, increment);\n  };\n  /**\n   * decrementBucket decrements the backing array index by `decrement`\n   * if decrement is greater than the current value, it's set to 0.\n   * @param bucketIndex\n   * @param decrement\n   */\n  Buckets.prototype.decrementBucket = function (bucketIndex, decrement) {\n    this.backing.decrement(bucketIndex, decrement);\n  };\n  /**\n   * trim removes leading and / or trailing zero buckets (which can occur\n   * after diffing two histos) and rotates the backing array so that the\n   * smallest non-zero index is in the 0th position of the backing array\n   */\n  Buckets.prototype.trim = function () {\n    for (var i = 0; i < this.length; i++) {\n      if (this.at(i) !== 0) {\n        this.indexStart += i;\n        break;\n      } else if (i === this.length - 1) {\n        //the entire array is zeroed out\n        this.indexStart = this.indexEnd = this.indexBase = 0;\n        return;\n      }\n    }\n    for (var i = this.length - 1; i >= 0; i--) {\n      if (this.at(i) !== 0) {\n        this.indexEnd -= this.length - i - 1;\n        break;\n      }\n    }\n    this._rotate();\n  };\n  /**\n   * downscale first rotates, then collapses 2**`by`-to-1 buckets.\n   * @param by\n   */\n  Buckets.prototype.downscale = function (by) {\n    this._rotate();\n    var size = 1 + this.indexEnd - this.indexStart;\n    var each = 1 << by;\n    var inpos = 0;\n    var outpos = 0;\n    for (var pos = this.indexStart; pos <= this.indexEnd;) {\n      var mod = pos % each;\n      if (mod < 0) {\n        mod += each;\n      }\n      for (var i = mod; i < each && inpos < size; i++) {\n        this._relocateBucket(outpos, inpos);\n        inpos++;\n        pos++;\n      }\n      outpos++;\n    }\n    this.indexStart >>= by;\n    this.indexEnd >>= by;\n    this.indexBase = this.indexStart;\n  };\n  /**\n   * Clone returns a deep copy of Buckets\n   * @returns {Buckets}\n   */\n  Buckets.prototype.clone = function () {\n    return new Buckets(this.backing.clone(), this.indexBase, this.indexStart, this.indexEnd);\n  };\n  /**\n   * _rotate shifts the backing array contents so that indexStart ==\n   * indexBase to simplify the downscale logic.\n   */\n  Buckets.prototype._rotate = function () {\n    var bias = this.indexBase - this.indexStart;\n    if (bias === 0) {\n      return;\n    } else if (bias > 0) {\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, bias);\n      this.backing.reverse(bias, this.backing.length);\n    } else {\n      // negative bias, this can happen when diffing two histograms\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, this.backing.length + bias);\n    }\n    this.indexBase = this.indexStart;\n  };\n  /**\n   * _relocateBucket adds the count in counts[src] to counts[dest] and\n   * resets count[src] to zero.\n   */\n  Buckets.prototype._relocateBucket = function (dest, src) {\n    if (dest === src) {\n      return;\n    }\n    this.incrementBucket(dest, this.backing.emptyBucket(src));\n  };\n  return Buckets;\n}();\nexport { Buckets };\n/**\n * BucketsBacking holds the raw buckets and some utility methods to\n * manage them.\n */\nvar BucketsBacking = /** @class */function () {\n  function BucketsBacking(_counts) {\n    if (_counts === void 0) {\n      _counts = [0];\n    }\n    this._counts = _counts;\n  }\n  Object.defineProperty(BucketsBacking.prototype, \"length\", {\n    /**\n     * length returns the physical size of the backing array, which\n     * is >= buckets.length()\n     */\n    get: function () {\n      return this._counts.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * countAt returns the count in a specific bucket\n   */\n  BucketsBacking.prototype.countAt = function (pos) {\n    return this._counts[pos];\n  };\n  /**\n   * growTo grows a backing array and copies old entries\n   * into their correct new positions.\n   */\n  BucketsBacking.prototype.growTo = function (newSize, oldPositiveLimit, newPositiveLimit) {\n    var tmp = new Array(newSize).fill(0);\n    tmp.splice.apply(tmp, __spreadArray([newPositiveLimit, this._counts.length - oldPositiveLimit], __read(this._counts.slice(oldPositiveLimit)), false));\n    tmp.splice.apply(tmp, __spreadArray([0, oldPositiveLimit], __read(this._counts.slice(0, oldPositiveLimit)), false));\n    this._counts = tmp;\n  };\n  /**\n   * reverse the items in the backing array in the range [from, limit).\n   */\n  BucketsBacking.prototype.reverse = function (from, limit) {\n    var num = Math.floor((from + limit) / 2) - from;\n    for (var i = 0; i < num; i++) {\n      var tmp = this._counts[from + i];\n      this._counts[from + i] = this._counts[limit - i - 1];\n      this._counts[limit - i - 1] = tmp;\n    }\n  };\n  /**\n   * emptyBucket empties the count from a bucket, for\n   * moving into another.\n   */\n  BucketsBacking.prototype.emptyBucket = function (src) {\n    var tmp = this._counts[src];\n    this._counts[src] = 0;\n    return tmp;\n  };\n  /**\n   * increments a bucket by `increment`\n   */\n  BucketsBacking.prototype.increment = function (bucketIndex, increment) {\n    this._counts[bucketIndex] += increment;\n  };\n  /**\n   * decrements a bucket by `decrement`\n   */\n  BucketsBacking.prototype.decrement = function (bucketIndex, decrement) {\n    if (this._counts[bucketIndex] >= decrement) {\n      this._counts[bucketIndex] -= decrement;\n    } else {\n      // this should not happen, but we're being defensive against\n      // negative counts.\n      this._counts[bucketIndex] = 0;\n    }\n  };\n  /**\n   * clone returns a deep copy of BucketsBacking\n   */\n  BucketsBacking.prototype.clone = function () {\n    return new BucketsBacking(__spreadArray([], __read(this._counts), false));\n  };\n  return BucketsBacking;\n}();","map":{"version":3,"names":["Buckets","backing","indexBase","indexStart","indexEnd","BucketsBacking","Object","defineProperty","prototype","get","length","at","counts","_this","Array","from","_","i","position","bias","countAt","incrementBucket","bucketIndex","increment","decrementBucket","decrement","trim","_rotate","downscale","by","size","each","inpos","outpos","pos","mod","_relocateBucket","clone","reverse","dest","src","emptyBucket","_counts","growTo","newSize","oldPositiveLimit","newPositiveLimit","tmp","fill","splice","apply","__spreadArray","__read","slice","limit","num","Math","floor"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/Buckets.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport class Buckets {\n  /**\n   * The term index refers to the number of the exponential histogram bucket\n   * used to determine its boundaries. The lower boundary of a bucket is\n   * determined by base ** index and the upper boundary of a bucket is\n   * determined by base ** (index + 1). index values are signed to account\n   * for values less than or equal to 1.\n   *\n   * indexBase is the index of the 0th position in the\n   * backing array, i.e., backing[0] is the count\n   * in the bucket with index `indexBase`.\n   *\n   * indexStart is the smallest index value represented\n   * in the backing array.\n   *\n   * indexEnd is the largest index value represented in\n   * the backing array.\n   */\n  constructor(\n    public backing = new BucketsBacking(),\n    public indexBase = 0,\n    public indexStart = 0,\n    public indexEnd = 0\n  ) {}\n\n  /**\n   * Offset is the bucket index of the smallest entry in the counts array\n   * @returns {number}\n   */\n  get offset(): number {\n    return this.indexStart;\n  }\n\n  /**\n   * Buckets is a view into the backing array.\n   * @returns {number}\n   */\n  get length(): number {\n    if (this.backing.length === 0) {\n      return 0;\n    }\n\n    if (this.indexEnd === this.indexStart && this.at(0) === 0) {\n      return 0;\n    }\n\n    return this.indexEnd - this.indexStart + 1;\n  }\n\n  /**\n   * An array of counts, where count[i] carries the count\n   * of the bucket at index (offset+i).  count[i] is the count of\n   * values greater than base^(offset+i) and less than or equal to\n   * base^(offset+i+1).\n   * @returns {number} The logical counts based on the backing array\n   */\n  counts(): number[] {\n    return Array.from({ length: this.length }, (_, i) => this.at(i));\n  }\n\n  /**\n   * At returns the count of the bucket at a position in the logical\n   * array of counts.\n   * @param position\n   * @returns {number}\n   */\n  at(position: number): number {\n    const bias = this.indexBase - this.indexStart;\n    if (position < bias) {\n      position += this.backing.length;\n    }\n\n    position -= bias;\n    return this.backing.countAt(position);\n  }\n\n  /**\n   * incrementBucket increments the backing array index by `increment`\n   * @param bucketIndex\n   * @param increment\n   */\n  incrementBucket(bucketIndex: number, increment: number) {\n    this.backing.increment(bucketIndex, increment);\n  }\n\n  /**\n   * decrementBucket decrements the backing array index by `decrement`\n   * if decrement is greater than the current value, it's set to 0.\n   * @param bucketIndex\n   * @param decrement\n   */\n  decrementBucket(bucketIndex: number, decrement: number) {\n    this.backing.decrement(bucketIndex, decrement);\n  }\n\n  /**\n   * trim removes leading and / or trailing zero buckets (which can occur\n   * after diffing two histos) and rotates the backing array so that the\n   * smallest non-zero index is in the 0th position of the backing array\n   */\n  trim() {\n    for (let i = 0; i < this.length; i++) {\n      if (this.at(i) !== 0) {\n        this.indexStart += i;\n        break;\n      } else if (i === this.length - 1) {\n        //the entire array is zeroed out\n        this.indexStart = this.indexEnd = this.indexBase = 0;\n        return;\n      }\n    }\n\n    for (let i = this.length - 1; i >= 0; i--) {\n      if (this.at(i) !== 0) {\n        this.indexEnd -= this.length - i - 1;\n        break;\n      }\n    }\n\n    this._rotate();\n  }\n\n  /**\n   * downscale first rotates, then collapses 2**`by`-to-1 buckets.\n   * @param by\n   */\n  downscale(by: number) {\n    this._rotate();\n\n    const size = 1 + this.indexEnd - this.indexStart;\n    const each = 1 << by;\n    let inpos = 0;\n    let outpos = 0;\n\n    for (let pos = this.indexStart; pos <= this.indexEnd; ) {\n      let mod = pos % each;\n      if (mod < 0) {\n        mod += each;\n      }\n      for (let i = mod; i < each && inpos < size; i++) {\n        this._relocateBucket(outpos, inpos);\n        inpos++;\n        pos++;\n      }\n      outpos++;\n    }\n\n    this.indexStart >>= by;\n    this.indexEnd >>= by;\n    this.indexBase = this.indexStart;\n  }\n\n  /**\n   * Clone returns a deep copy of Buckets\n   * @returns {Buckets}\n   */\n  clone(): Buckets {\n    return new Buckets(\n      this.backing.clone(),\n      this.indexBase,\n      this.indexStart,\n      this.indexEnd\n    );\n  }\n\n  /**\n   * _rotate shifts the backing array contents so that indexStart ==\n   * indexBase to simplify the downscale logic.\n   */\n  private _rotate() {\n    const bias = this.indexBase - this.indexStart;\n\n    if (bias === 0) {\n      return;\n    } else if (bias > 0) {\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, bias);\n      this.backing.reverse(bias, this.backing.length);\n    } else {\n      // negative bias, this can happen when diffing two histograms\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, this.backing.length + bias);\n    }\n    this.indexBase = this.indexStart;\n  }\n\n  /**\n   * _relocateBucket adds the count in counts[src] to counts[dest] and\n   * resets count[src] to zero.\n   */\n  private _relocateBucket(dest: number, src: number) {\n    if (dest === src) {\n      return;\n    }\n    this.incrementBucket(dest, this.backing.emptyBucket(src));\n  }\n}\n\n/**\n * BucketsBacking holds the raw buckets and some utility methods to\n * manage them.\n */\nclass BucketsBacking {\n  constructor(private _counts = [0]) {}\n\n  /**\n   * length returns the physical size of the backing array, which\n   * is >= buckets.length()\n   */\n  get length(): number {\n    return this._counts.length;\n  }\n\n  /**\n   * countAt returns the count in a specific bucket\n   */\n  countAt(pos: number): number {\n    return this._counts[pos];\n  }\n\n  /**\n   * growTo grows a backing array and copies old entries\n   * into their correct new positions.\n   */\n  growTo(newSize: number, oldPositiveLimit: number, newPositiveLimit: number) {\n    const tmp = new Array<number>(newSize).fill(0);\n    tmp.splice(\n      newPositiveLimit,\n      this._counts.length - oldPositiveLimit,\n      ...this._counts.slice(oldPositiveLimit)\n    );\n    tmp.splice(0, oldPositiveLimit, ...this._counts.slice(0, oldPositiveLimit));\n    this._counts = tmp;\n  }\n\n  /**\n   * reverse the items in the backing array in the range [from, limit).\n   */\n  reverse(from: number, limit: number) {\n    const num = Math.floor((from + limit) / 2) - from;\n    for (let i = 0; i < num; i++) {\n      const tmp = this._counts[from + i];\n      this._counts[from + i] = this._counts[limit - i - 1];\n      this._counts[limit - i - 1] = tmp;\n    }\n  }\n\n  /**\n   * emptyBucket empties the count from a bucket, for\n   * moving into another.\n   */\n  emptyBucket(src: number): number {\n    const tmp = this._counts[src];\n    this._counts[src] = 0;\n    return tmp;\n  }\n\n  /**\n   * increments a bucket by `increment`\n   */\n  increment(bucketIndex: number, increment: number) {\n    this._counts[bucketIndex] += increment;\n  }\n\n  /**\n   * decrements a bucket by `decrement`\n   */\n  decrement(bucketIndex: number, decrement: number) {\n    if (this._counts[bucketIndex] >= decrement) {\n      this._counts[bucketIndex] -= decrement;\n    } else {\n      // this should not happen, but we're being defensive against\n      // negative counts.\n      this._counts[bucketIndex] = 0;\n    }\n  }\n\n  /**\n   * clone returns a deep copy of BucketsBacking\n   */\n  clone(): BucketsBacking {\n    return new BucketsBacking([...this._counts]);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}