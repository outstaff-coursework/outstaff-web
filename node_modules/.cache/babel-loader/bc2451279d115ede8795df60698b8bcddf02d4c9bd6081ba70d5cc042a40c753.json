{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isSpanContextValid, trace, TraceFlags } from '@opentelemetry/api';\nimport { isTracingSuppressed } from './suppress-tracing';\nimport { TraceState } from './TraceState';\nexport var TRACE_PARENT_HEADER = 'traceparent';\nexport var TRACE_STATE_HEADER = 'tracestate';\nvar VERSION = '00';\nvar VERSION_PART = '(?!ff)[\\\\da-f]{2}';\nvar TRACE_ID_PART = '(?![0]{32})[\\\\da-f]{32}';\nvar PARENT_ID_PART = '(?![0]{16})[\\\\da-f]{16}';\nvar FLAGS_PART = '[\\\\da-f]{2}';\nvar TRACE_PARENT_REGEX = new RegExp(\"^\\\\s?(\" + VERSION_PART + \")-(\" + TRACE_ID_PART + \")-(\" + PARENT_ID_PART + \")-(\" + FLAGS_PART + \")(-.*)?\\\\s?$\");\n/**\n * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}\n * @param traceParent - A meta property that comes from server.\n *     It should be dynamically generated server side to have the server's request trace Id,\n *     a parent span Id that was set on the server's request span,\n *     and the trace flags to indicate the server's sampling decision\n *     (01 = sampled, 00 = not sampled).\n *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'\n *     For more information see {@link https://www.w3.org/TR/trace-context/}\n */\nexport function parseTraceParent(traceParent) {\n  var match = TRACE_PARENT_REGEX.exec(traceParent);\n  if (!match) return null;\n  // According to the specification the implementation should be compatible\n  // with future versions. If there are more parts, we only reject it if it's using version 00\n  // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent\n  if (match[1] === '00' && match[5]) return null;\n  return {\n    traceId: match[2],\n    spanId: match[3],\n    traceFlags: parseInt(match[4], 16)\n  };\n}\n/**\n * Propagates {@link SpanContext} through Trace Context format propagation.\n *\n * Based on the Trace Context specification:\n * https://www.w3.org/TR/trace-context/\n */\nvar W3CTraceContextPropagator = /** @class */function () {\n  function W3CTraceContextPropagator() {}\n  W3CTraceContextPropagator.prototype.inject = function (context, carrier, setter) {\n    var spanContext = trace.getSpanContext(context);\n    if (!spanContext || isTracingSuppressed(context) || !isSpanContextValid(spanContext)) return;\n    var traceParent = VERSION + \"-\" + spanContext.traceId + \"-\" + spanContext.spanId + \"-0\" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);\n    setter.set(carrier, TRACE_PARENT_HEADER, traceParent);\n    if (spanContext.traceState) {\n      setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());\n    }\n  };\n  W3CTraceContextPropagator.prototype.extract = function (context, carrier, getter) {\n    var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);\n    if (!traceParentHeader) return context;\n    var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;\n    if (typeof traceParent !== 'string') return context;\n    var spanContext = parseTraceParent(traceParent);\n    if (!spanContext) return context;\n    spanContext.isRemote = true;\n    var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);\n    if (traceStateHeader) {\n      // If more than one `tracestate` header is found, we merge them into a\n      // single header.\n      var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(',') : traceStateHeader;\n      spanContext.traceState = new TraceState(typeof state === 'string' ? state : undefined);\n    }\n    return trace.setSpanContext(context, spanContext);\n  };\n  W3CTraceContextPropagator.prototype.fields = function () {\n    return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];\n  };\n  return W3CTraceContextPropagator;\n}();\nexport { W3CTraceContextPropagator };","map":{"version":3,"names":["isSpanContextValid","trace","TraceFlags","isTracingSuppressed","TraceState","TRACE_PARENT_HEADER","TRACE_STATE_HEADER","VERSION","VERSION_PART","TRACE_ID_PART","PARENT_ID_PART","FLAGS_PART","TRACE_PARENT_REGEX","RegExp","parseTraceParent","traceParent","match","exec","traceId","spanId","traceFlags","parseInt","W3CTraceContextPropagator","prototype","inject","context","carrier","setter","spanContext","getSpanContext","Number","NONE","toString","set","traceState","serialize","extract","getter","traceParentHeader","get","Array","isArray","isRemote","traceStateHeader","state","join","undefined","setSpanContext","fields"],"sources":["/home/egor/node_modules/@opentelemetry/core/src/trace/W3CTraceContextPropagator.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  isSpanContextValid,\n  SpanContext,\n  TextMapGetter,\n  TextMapPropagator,\n  TextMapSetter,\n  trace,\n  TraceFlags,\n} from '@opentelemetry/api';\nimport { isTracingSuppressed } from './suppress-tracing';\nimport { TraceState } from './TraceState';\n\nexport const TRACE_PARENT_HEADER = 'traceparent';\nexport const TRACE_STATE_HEADER = 'tracestate';\n\nconst VERSION = '00';\nconst VERSION_PART = '(?!ff)[\\\\da-f]{2}';\nconst TRACE_ID_PART = '(?![0]{32})[\\\\da-f]{32}';\nconst PARENT_ID_PART = '(?![0]{16})[\\\\da-f]{16}';\nconst FLAGS_PART = '[\\\\da-f]{2}';\nconst TRACE_PARENT_REGEX = new RegExp(\n  `^\\\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\\\s?$`\n);\n\n/**\n * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}\n * @param traceParent - A meta property that comes from server.\n *     It should be dynamically generated server side to have the server's request trace Id,\n *     a parent span Id that was set on the server's request span,\n *     and the trace flags to indicate the server's sampling decision\n *     (01 = sampled, 00 = not sampled).\n *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'\n *     For more information see {@link https://www.w3.org/TR/trace-context/}\n */\nexport function parseTraceParent(traceParent: string): SpanContext | null {\n  const match = TRACE_PARENT_REGEX.exec(traceParent);\n  if (!match) return null;\n\n  // According to the specification the implementation should be compatible\n  // with future versions. If there are more parts, we only reject it if it's using version 00\n  // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent\n  if (match[1] === '00' && match[5]) return null;\n\n  return {\n    traceId: match[2],\n    spanId: match[3],\n    traceFlags: parseInt(match[4], 16),\n  };\n}\n\n/**\n * Propagates {@link SpanContext} through Trace Context format propagation.\n *\n * Based on the Trace Context specification:\n * https://www.w3.org/TR/trace-context/\n */\nexport class W3CTraceContextPropagator implements TextMapPropagator {\n  inject(context: Context, carrier: unknown, setter: TextMapSetter): void {\n    const spanContext = trace.getSpanContext(context);\n    if (\n      !spanContext ||\n      isTracingSuppressed(context) ||\n      !isSpanContextValid(spanContext)\n    )\n      return;\n\n    const traceParent = `${VERSION}-${spanContext.traceId}-${\n      spanContext.spanId\n    }-0${Number(spanContext.traceFlags || TraceFlags.NONE).toString(16)}`;\n\n    setter.set(carrier, TRACE_PARENT_HEADER, traceParent);\n    if (spanContext.traceState) {\n      setter.set(\n        carrier,\n        TRACE_STATE_HEADER,\n        spanContext.traceState.serialize()\n      );\n    }\n  }\n\n  extract(context: Context, carrier: unknown, getter: TextMapGetter): Context {\n    const traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);\n    if (!traceParentHeader) return context;\n    const traceParent = Array.isArray(traceParentHeader)\n      ? traceParentHeader[0]\n      : traceParentHeader;\n    if (typeof traceParent !== 'string') return context;\n    const spanContext = parseTraceParent(traceParent);\n    if (!spanContext) return context;\n\n    spanContext.isRemote = true;\n\n    const traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);\n    if (traceStateHeader) {\n      // If more than one `tracestate` header is found, we merge them into a\n      // single header.\n      const state = Array.isArray(traceStateHeader)\n        ? traceStateHeader.join(',')\n        : traceStateHeader;\n      spanContext.traceState = new TraceState(\n        typeof state === 'string' ? state : undefined\n      );\n    }\n    return trace.setSpanContext(context, spanContext);\n  }\n\n  fields(): string[] {\n    return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}