{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport * as api from '@opentelemetry/api';\nimport { SumAggregator, DropAggregator, LastValueAggregator, HistogramAggregator, ExponentialHistogramAggregator } from '../aggregator';\nimport { InstrumentType } from '../InstrumentDescriptor';\n/**\n * Configures how measurements are combined into metrics for views.\n *\n * Aggregation provides a set of built-in aggregations via static methods.\n */\nvar Aggregation = /** @class */function () {\n  function Aggregation() {}\n  Aggregation.Drop = function () {\n    return DROP_AGGREGATION;\n  };\n  Aggregation.Sum = function () {\n    return SUM_AGGREGATION;\n  };\n  Aggregation.LastValue = function () {\n    return LAST_VALUE_AGGREGATION;\n  };\n  Aggregation.Histogram = function () {\n    return HISTOGRAM_AGGREGATION;\n  };\n  Aggregation.ExponentialHistogram = function () {\n    return EXPONENTIAL_HISTOGRAM_AGGREGATION;\n  };\n  Aggregation.Default = function () {\n    return DEFAULT_AGGREGATION;\n  };\n  return Aggregation;\n}();\nexport { Aggregation };\n/**\n * The default drop aggregation.\n */\nvar DropAggregation = /** @class */function (_super) {\n  __extends(DropAggregation, _super);\n  function DropAggregation() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DropAggregation.prototype.createAggregator = function (_instrument) {\n    return DropAggregation.DEFAULT_INSTANCE;\n  };\n  DropAggregation.DEFAULT_INSTANCE = new DropAggregator();\n  return DropAggregation;\n}(Aggregation);\nexport { DropAggregation };\n/**\n * The default sum aggregation.\n */\nvar SumAggregation = /** @class */function (_super) {\n  __extends(SumAggregation, _super);\n  function SumAggregation() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  SumAggregation.prototype.createAggregator = function (instrument) {\n    switch (instrument.type) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.HISTOGRAM:\n        {\n          return SumAggregation.MONOTONIC_INSTANCE;\n        }\n      default:\n        {\n          return SumAggregation.NON_MONOTONIC_INSTANCE;\n        }\n    }\n  };\n  SumAggregation.MONOTONIC_INSTANCE = new SumAggregator(true);\n  SumAggregation.NON_MONOTONIC_INSTANCE = new SumAggregator(false);\n  return SumAggregation;\n}(Aggregation);\nexport { SumAggregation };\n/**\n * The default last value aggregation.\n */\nvar LastValueAggregation = /** @class */function (_super) {\n  __extends(LastValueAggregation, _super);\n  function LastValueAggregation() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  LastValueAggregation.prototype.createAggregator = function (_instrument) {\n    return LastValueAggregation.DEFAULT_INSTANCE;\n  };\n  LastValueAggregation.DEFAULT_INSTANCE = new LastValueAggregator();\n  return LastValueAggregation;\n}(Aggregation);\nexport { LastValueAggregation };\n/**\n * The default histogram aggregation.\n */\nvar HistogramAggregation = /** @class */function (_super) {\n  __extends(HistogramAggregation, _super);\n  function HistogramAggregation() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  HistogramAggregation.prototype.createAggregator = function (_instrument) {\n    return HistogramAggregation.DEFAULT_INSTANCE;\n  };\n  HistogramAggregation.DEFAULT_INSTANCE = new HistogramAggregator([0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1000, 2500, 5000, 7500, 10000], true);\n  return HistogramAggregation;\n}(Aggregation);\nexport { HistogramAggregation };\n/**\n * The explicit bucket histogram aggregation.\n */\nvar ExplicitBucketHistogramAggregation = /** @class */function (_super) {\n  __extends(ExplicitBucketHistogramAggregation, _super);\n  /**\n   * @param boundaries the bucket boundaries of the histogram aggregation\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  function ExplicitBucketHistogramAggregation(boundaries, _recordMinMax) {\n    if (_recordMinMax === void 0) {\n      _recordMinMax = true;\n    }\n    var _this = _super.call(this) || this;\n    _this._recordMinMax = _recordMinMax;\n    if (boundaries === undefined || boundaries.length === 0) {\n      throw new Error('HistogramAggregator should be created with boundaries.');\n    }\n    // Copy the boundaries array for modification.\n    boundaries = boundaries.concat();\n    // We need to an ordered set to be able to correctly compute count for each\n    // boundary since we'll iterate on each in order.\n    boundaries = boundaries.sort(function (a, b) {\n      return a - b;\n    });\n    // Remove all Infinity from the boundaries.\n    var minusInfinityIndex = boundaries.lastIndexOf(-Infinity);\n    var infinityIndex = boundaries.indexOf(Infinity);\n    if (infinityIndex === -1) {\n      infinityIndex = undefined;\n    }\n    _this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);\n    return _this;\n  }\n  ExplicitBucketHistogramAggregation.prototype.createAggregator = function (_instrument) {\n    return new HistogramAggregator(this._boundaries, this._recordMinMax);\n  };\n  return ExplicitBucketHistogramAggregation;\n}(Aggregation);\nexport { ExplicitBucketHistogramAggregation };\nvar ExponentialHistogramAggregation = /** @class */function (_super) {\n  __extends(ExponentialHistogramAggregation, _super);\n  function ExponentialHistogramAggregation(_maxSize, _recordMinMax) {\n    if (_maxSize === void 0) {\n      _maxSize = 160;\n    }\n    if (_recordMinMax === void 0) {\n      _recordMinMax = true;\n    }\n    var _this = _super.call(this) || this;\n    _this._maxSize = _maxSize;\n    _this._recordMinMax = _recordMinMax;\n    return _this;\n  }\n  ExponentialHistogramAggregation.prototype.createAggregator = function (_instrument) {\n    return new ExponentialHistogramAggregator(this._maxSize, this._recordMinMax);\n  };\n  return ExponentialHistogramAggregation;\n}(Aggregation);\nexport { ExponentialHistogramAggregation };\n/**\n * The default aggregation.\n */\nvar DefaultAggregation = /** @class */function (_super) {\n  __extends(DefaultAggregation, _super);\n  function DefaultAggregation() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DefaultAggregation.prototype._resolve = function (instrument) {\n    // cast to unknown to disable complaints on the (unreachable) fallback.\n    switch (instrument.type) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.UP_DOWN_COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:\n        {\n          return SUM_AGGREGATION;\n        }\n      case InstrumentType.OBSERVABLE_GAUGE:\n        {\n          return LAST_VALUE_AGGREGATION;\n        }\n      case InstrumentType.HISTOGRAM:\n        {\n          if (instrument.advice.explicitBucketBoundaries) {\n            return new ExplicitBucketHistogramAggregation(instrument.advice.explicitBucketBoundaries);\n          }\n          return HISTOGRAM_AGGREGATION;\n        }\n    }\n    api.diag.warn(\"Unable to recognize instrument type: \" + instrument.type);\n    return DROP_AGGREGATION;\n  };\n  DefaultAggregation.prototype.createAggregator = function (instrument) {\n    return this._resolve(instrument).createAggregator(instrument);\n  };\n  return DefaultAggregation;\n}(Aggregation);\nexport { DefaultAggregation };\nvar DROP_AGGREGATION = new DropAggregation();\nvar SUM_AGGREGATION = new SumAggregation();\nvar LAST_VALUE_AGGREGATION = new LastValueAggregation();\nvar HISTOGRAM_AGGREGATION = new HistogramAggregation();\nvar EXPONENTIAL_HISTOGRAM_AGGREGATION = new ExponentialHistogramAggregation();\nvar DEFAULT_AGGREGATION = new DefaultAggregation();","map":{"version":3,"names":["api","SumAggregator","DropAggregator","LastValueAggregator","HistogramAggregator","ExponentialHistogramAggregator","InstrumentType","Aggregation","Drop","DROP_AGGREGATION","Sum","SUM_AGGREGATION","LastValue","LAST_VALUE_AGGREGATION","Histogram","HISTOGRAM_AGGREGATION","ExponentialHistogram","EXPONENTIAL_HISTOGRAM_AGGREGATION","Default","DEFAULT_AGGREGATION","DropAggregation","_super","__extends","prototype","createAggregator","_instrument","DEFAULT_INSTANCE","SumAggregation","instrument","type","COUNTER","OBSERVABLE_COUNTER","HISTOGRAM","MONOTONIC_INSTANCE","NON_MONOTONIC_INSTANCE","LastValueAggregation","HistogramAggregation","ExplicitBucketHistogramAggregation","boundaries","_recordMinMax","_this","call","undefined","length","Error","concat","sort","a","b","minusInfinityIndex","lastIndexOf","Infinity","infinityIndex","indexOf","_boundaries","slice","ExponentialHistogramAggregation","_maxSize","DefaultAggregation","_resolve","UP_DOWN_COUNTER","OBSERVABLE_UP_DOWN_COUNTER","OBSERVABLE_GAUGE","advice","explicitBucketBoundaries","diag","warn"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/view/Aggregation.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  Aggregator,\n  SumAggregator,\n  DropAggregator,\n  LastValueAggregator,\n  HistogramAggregator,\n  ExponentialHistogramAggregator,\n} from '../aggregator';\nimport { Accumulation } from '../aggregator/types';\nimport { InstrumentDescriptor, InstrumentType } from '../InstrumentDescriptor';\nimport { Maybe } from '../utils';\n\n/**\n * Configures how measurements are combined into metrics for views.\n *\n * Aggregation provides a set of built-in aggregations via static methods.\n */\nexport abstract class Aggregation {\n  abstract createAggregator(\n    instrument: InstrumentDescriptor\n  ): Aggregator<Maybe<Accumulation>>;\n\n  static Drop(): Aggregation {\n    return DROP_AGGREGATION;\n  }\n\n  static Sum(): Aggregation {\n    return SUM_AGGREGATION;\n  }\n\n  static LastValue(): Aggregation {\n    return LAST_VALUE_AGGREGATION;\n  }\n\n  static Histogram(): Aggregation {\n    return HISTOGRAM_AGGREGATION;\n  }\n\n  static ExponentialHistogram(): Aggregation {\n    return EXPONENTIAL_HISTOGRAM_AGGREGATION;\n  }\n\n  static Default(): Aggregation {\n    return DEFAULT_AGGREGATION;\n  }\n}\n\n/**\n * The default drop aggregation.\n */\nexport class DropAggregation extends Aggregation {\n  private static DEFAULT_INSTANCE = new DropAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return DropAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default sum aggregation.\n */\nexport class SumAggregation extends Aggregation {\n  private static MONOTONIC_INSTANCE = new SumAggregator(true);\n  private static NON_MONOTONIC_INSTANCE = new SumAggregator(false);\n  createAggregator(instrument: InstrumentDescriptor) {\n    switch (instrument.type) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.HISTOGRAM: {\n        return SumAggregation.MONOTONIC_INSTANCE;\n      }\n      default: {\n        return SumAggregation.NON_MONOTONIC_INSTANCE;\n      }\n    }\n  }\n}\n\n/**\n * The default last value aggregation.\n */\nexport class LastValueAggregation extends Aggregation {\n  private static DEFAULT_INSTANCE = new LastValueAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return LastValueAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default histogram aggregation.\n */\nexport class HistogramAggregation extends Aggregation {\n  private static DEFAULT_INSTANCE = new HistogramAggregator(\n    [0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1000, 2500, 5000, 7500, 10000],\n    true\n  );\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return HistogramAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The explicit bucket histogram aggregation.\n */\nexport class ExplicitBucketHistogramAggregation extends Aggregation {\n  private _boundaries: number[];\n\n  /**\n   * @param boundaries the bucket boundaries of the histogram aggregation\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    boundaries: number[],\n    private readonly _recordMinMax = true\n  ) {\n    super();\n    if (boundaries === undefined || boundaries.length === 0) {\n      throw new Error('HistogramAggregator should be created with boundaries.');\n    }\n    // Copy the boundaries array for modification.\n    boundaries = boundaries.concat();\n    // We need to an ordered set to be able to correctly compute count for each\n    // boundary since we'll iterate on each in order.\n    boundaries = boundaries.sort((a, b) => a - b);\n    // Remove all Infinity from the boundaries.\n    const minusInfinityIndex = boundaries.lastIndexOf(-Infinity);\n    let infinityIndex: number | undefined = boundaries.indexOf(Infinity);\n    if (infinityIndex === -1) {\n      infinityIndex = undefined;\n    }\n    this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);\n  }\n\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return new HistogramAggregator(this._boundaries, this._recordMinMax);\n  }\n}\n\nexport class ExponentialHistogramAggregation extends Aggregation {\n  constructor(\n    private readonly _maxSize: number = 160,\n    private readonly _recordMinMax = true\n  ) {\n    super();\n  }\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return new ExponentialHistogramAggregator(\n      this._maxSize,\n      this._recordMinMax\n    );\n  }\n}\n\n/**\n * The default aggregation.\n */\nexport class DefaultAggregation extends Aggregation {\n  private _resolve(instrument: InstrumentDescriptor): Aggregation {\n    // cast to unknown to disable complaints on the (unreachable) fallback.\n    switch (instrument.type as unknown) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.UP_DOWN_COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER: {\n        return SUM_AGGREGATION;\n      }\n      case InstrumentType.OBSERVABLE_GAUGE: {\n        return LAST_VALUE_AGGREGATION;\n      }\n      case InstrumentType.HISTOGRAM: {\n        if (instrument.advice.explicitBucketBoundaries) {\n          return new ExplicitBucketHistogramAggregation(\n            instrument.advice.explicitBucketBoundaries\n          );\n        }\n        return HISTOGRAM_AGGREGATION;\n      }\n    }\n    api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`);\n    return DROP_AGGREGATION;\n  }\n\n  createAggregator(\n    instrument: InstrumentDescriptor\n  ): Aggregator<Maybe<Accumulation>> {\n    return this._resolve(instrument).createAggregator(instrument);\n  }\n}\n\nconst DROP_AGGREGATION = new DropAggregation();\nconst SUM_AGGREGATION = new SumAggregation();\nconst LAST_VALUE_AGGREGATION = new LastValueAggregation();\nconst HISTOGRAM_AGGREGATION = new HistogramAggregation();\nconst EXPONENTIAL_HISTOGRAM_AGGREGATION = new ExponentialHistogramAggregation();\nconst DEFAULT_AGGREGATION = new DefaultAggregation();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}