{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { baggageEntryMetadataFromString } from '@opentelemetry/api';\nimport { BAGGAGE_ITEMS_SEPARATOR, BAGGAGE_PROPERTIES_SEPARATOR, BAGGAGE_KEY_PAIR_SEPARATOR, BAGGAGE_MAX_TOTAL_LENGTH } from './constants';\nexport function serializeKeyPairs(keyPairs) {\n  return keyPairs.reduce(function (hValue, current) {\n    var value = \"\" + hValue + (hValue !== '' ? BAGGAGE_ITEMS_SEPARATOR : '') + current;\n    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;\n  }, '');\n}\nexport function getKeyPairs(baggage) {\n  return baggage.getAllEntries().map(function (_a) {\n    var _b = __read(_a, 2),\n      key = _b[0],\n      value = _b[1];\n    var entry = encodeURIComponent(key) + \"=\" + encodeURIComponent(value.value);\n    // include opaque metadata if provided\n    // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation\n    if (value.metadata !== undefined) {\n      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();\n    }\n    return entry;\n  });\n}\nexport function parsePairKeyValue(entry) {\n  var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);\n  if (valueProps.length <= 0) return;\n  var keyPairPart = valueProps.shift();\n  if (!keyPairPart) return;\n  var separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);\n  if (separatorIndex <= 0) return;\n  var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());\n  var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());\n  var metadata;\n  if (valueProps.length > 0) {\n    metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));\n  }\n  return {\n    key: key,\n    value: value,\n    metadata: metadata\n  };\n}\n/**\n * Parse a string serialized in the baggage HTTP Format (without metadata):\n * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md\n */\nexport function parseKeyPairsIntoRecord(value) {\n  if (typeof value !== 'string' || value.length === 0) return {};\n  return value.split(BAGGAGE_ITEMS_SEPARATOR).map(function (entry) {\n    return parsePairKeyValue(entry);\n  }).filter(function (keyPair) {\n    return keyPair !== undefined && keyPair.value.length > 0;\n  }).reduce(function (headers, keyPair) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    headers[keyPair.key] = keyPair.value;\n    return headers;\n  }, {});\n}","map":{"version":3,"names":["baggageEntryMetadataFromString","BAGGAGE_ITEMS_SEPARATOR","BAGGAGE_PROPERTIES_SEPARATOR","BAGGAGE_KEY_PAIR_SEPARATOR","BAGGAGE_MAX_TOTAL_LENGTH","serializeKeyPairs","keyPairs","reduce","hValue","current","value","length","getKeyPairs","baggage","getAllEntries","map","_a","_b","__read","key","entry","encodeURIComponent","metadata","undefined","toString","parsePairKeyValue","valueProps","split","keyPairPart","shift","separatorIndex","indexOf","decodeURIComponent","substring","trim","join","parseKeyPairsIntoRecord","filter","keyPair","headers"],"sources":["/home/egor/node_modules/@opentelemetry/core/src/baggage/utils.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  Baggage,\n  BaggageEntryMetadata,\n  baggageEntryMetadataFromString,\n} from '@opentelemetry/api';\nimport {\n  BAGGAGE_ITEMS_SEPARATOR,\n  BAGGAGE_PROPERTIES_SEPARATOR,\n  BAGGAGE_KEY_PAIR_SEPARATOR,\n  BAGGAGE_MAX_TOTAL_LENGTH,\n} from './constants';\n\ntype ParsedBaggageKeyValue = {\n  key: string;\n  value: string;\n  metadata: BaggageEntryMetadata | undefined;\n};\n\nexport function serializeKeyPairs(keyPairs: string[]): string {\n  return keyPairs.reduce((hValue: string, current: string) => {\n    const value = `${hValue}${\n      hValue !== '' ? BAGGAGE_ITEMS_SEPARATOR : ''\n    }${current}`;\n    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;\n  }, '');\n}\n\nexport function getKeyPairs(baggage: Baggage): string[] {\n  return baggage.getAllEntries().map(([key, value]) => {\n    let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;\n\n    // include opaque metadata if provided\n    // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation\n    if (value.metadata !== undefined) {\n      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();\n    }\n\n    return entry;\n  });\n}\n\nexport function parsePairKeyValue(\n  entry: string\n): ParsedBaggageKeyValue | undefined {\n  const valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);\n  if (valueProps.length <= 0) return;\n  const keyPairPart = valueProps.shift();\n  if (!keyPairPart) return;\n  const separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);\n  if (separatorIndex <= 0) return;\n  const key = decodeURIComponent(\n    keyPairPart.substring(0, separatorIndex).trim()\n  );\n  const value = decodeURIComponent(\n    keyPairPart.substring(separatorIndex + 1).trim()\n  );\n  let metadata;\n  if (valueProps.length > 0) {\n    metadata = baggageEntryMetadataFromString(\n      valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR)\n    );\n  }\n  return { key, value, metadata };\n}\n\n/**\n * Parse a string serialized in the baggage HTTP Format (without metadata):\n * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md\n */\nexport function parseKeyPairsIntoRecord(\n  value?: string\n): Record<string, string> {\n  if (typeof value !== 'string' || value.length === 0) return {};\n  return value\n    .split(BAGGAGE_ITEMS_SEPARATOR)\n    .map(entry => {\n      return parsePairKeyValue(entry);\n    })\n    .filter(keyPair => keyPair !== undefined && keyPair.value.length > 0)\n    .reduce<Record<string, string>>((headers, keyPair) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      headers[keyPair!.key] = keyPair!.value;\n      return headers;\n    }, {});\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}