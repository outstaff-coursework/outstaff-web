{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { diag, createNoopMeter } from '@opentelemetry/api';\nimport { Resource } from '@opentelemetry/resources';\nimport { MeterProviderSharedState } from './state/MeterProviderSharedState';\nimport { MetricCollector } from './state/MetricCollector';\n/**\n * This class implements the {@link MeterProvider} interface.\n */\nvar MeterProvider = /** @class */function () {\n  function MeterProvider(options) {\n    var e_1, _a, e_2, _b;\n    var _c;\n    this._shutdown = false;\n    var resource = Resource.default().merge((_c = options === null || options === void 0 ? void 0 : options.resource) !== null && _c !== void 0 ? _c : Resource.empty());\n    this._sharedState = new MeterProviderSharedState(resource);\n    if ((options === null || options === void 0 ? void 0 : options.views) != null && options.views.length > 0) {\n      try {\n        for (var _d = __values(options.views), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var view = _e.value;\n          this._sharedState.viewRegistry.addView(view);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n    if ((options === null || options === void 0 ? void 0 : options.readers) != null && options.readers.length > 0) {\n      try {\n        for (var _f = __values(options.readers), _g = _f.next(); !_g.done; _g = _f.next()) {\n          var metricReader = _g.value;\n          this.addMetricReader(metricReader);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n  }\n  /**\n   * Get a meter with the configuration of the MeterProvider.\n   */\n  MeterProvider.prototype.getMeter = function (name, version, options) {\n    if (version === void 0) {\n      version = '';\n    }\n    if (options === void 0) {\n      options = {};\n    }\n    // https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#meter-creation\n    if (this._shutdown) {\n      diag.warn('A shutdown MeterProvider cannot provide a Meter');\n      return createNoopMeter();\n    }\n    return this._sharedState.getMeterSharedState({\n      name: name,\n      version: version,\n      schemaUrl: options.schemaUrl\n    }).meter;\n  };\n  /**\n   * Register a {@link MetricReader} to the meter provider. After the\n   * registration, the MetricReader can start metrics collection.\n   *\n   * <p> NOTE: {@link MetricReader} instances MUST be added before creating any instruments.\n   * A {@link MetricReader} instance registered later may receive no or incomplete metric data.\n   *\n   * @param metricReader the metric reader to be registered.\n   *\n   * @deprecated This method will be removed in SDK 2.0. Please use\n   * {@link MeterProviderOptions.readers} via the {@link MeterProvider} constructor instead\n   */\n  MeterProvider.prototype.addMetricReader = function (metricReader) {\n    var collector = new MetricCollector(this._sharedState, metricReader);\n    metricReader.setMetricProducer(collector);\n    this._sharedState.metricCollectors.push(collector);\n  };\n  /**\n   * Flush all buffered data and shut down the MeterProvider and all registered\n   * MetricReaders.\n   *\n   * Returns a promise which is resolved when all flushes are complete.\n   */\n  MeterProvider.prototype.shutdown = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this._shutdown) {\n              diag.warn('shutdown may only be called once per MeterProvider');\n              return [2 /*return*/];\n            }\n\n            this._shutdown = true;\n            return [4 /*yield*/, Promise.all(this._sharedState.metricCollectors.map(function (collector) {\n              return collector.shutdown(options);\n            }))];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Notifies all registered MetricReaders to flush any buffered data.\n   *\n   * Returns a promise which is resolved when all flushes are complete.\n   */\n  MeterProvider.prototype.forceFlush = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // do not flush after shutdown\n            if (this._shutdown) {\n              diag.warn('invalid attempt to force flush after MeterProvider shutdown');\n              return [2 /*return*/];\n            }\n\n            return [4 /*yield*/, Promise.all(this._sharedState.metricCollectors.map(function (collector) {\n              return collector.forceFlush(options);\n            }))];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return MeterProvider;\n}();\nexport { MeterProvider };","map":{"version":3,"names":["diag","createNoopMeter","Resource","MeterProviderSharedState","MetricCollector","MeterProvider","options","_shutdown","resource","default","merge","_c","empty","_sharedState","views","length","_d","__values","_e","next","done","view","value","viewRegistry","addView","readers","_f","_g","metricReader","addMetricReader","prototype","getMeter","name","version","warn","getMeterSharedState","schemaUrl","meter","collector","setMetricProducer","metricCollectors","push","shutdown","Promise","all","map","_a","sent","forceFlush"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/MeterProvider.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  diag,\n  MeterProvider as IMeterProvider,\n  Meter as IMeter,\n  MeterOptions,\n  createNoopMeter,\n} from '@opentelemetry/api';\nimport { IResource, Resource } from '@opentelemetry/resources';\nimport { MetricReader } from './export/MetricReader';\nimport { MeterProviderSharedState } from './state/MeterProviderSharedState';\nimport { MetricCollector } from './state/MetricCollector';\nimport { ForceFlushOptions, ShutdownOptions } from './types';\nimport { View } from './view/View';\n\n/**\n * MeterProviderOptions provides an interface for configuring a MeterProvider.\n */\nexport interface MeterProviderOptions {\n  /** Resource associated with metric telemetry  */\n  resource?: IResource;\n  views?: View[];\n  readers?: MetricReader[];\n}\n\n/**\n * This class implements the {@link MeterProvider} interface.\n */\nexport class MeterProvider implements IMeterProvider {\n  private _sharedState: MeterProviderSharedState;\n  private _shutdown = false;\n\n  constructor(options?: MeterProviderOptions) {\n    const resource = Resource.default().merge(\n      options?.resource ?? Resource.empty()\n    );\n    this._sharedState = new MeterProviderSharedState(resource);\n    if (options?.views != null && options.views.length > 0) {\n      for (const view of options.views) {\n        this._sharedState.viewRegistry.addView(view);\n      }\n    }\n\n    if (options?.readers != null && options.readers.length > 0) {\n      for (const metricReader of options.readers) {\n        this.addMetricReader(metricReader);\n      }\n    }\n  }\n\n  /**\n   * Get a meter with the configuration of the MeterProvider.\n   */\n  getMeter(name: string, version = '', options: MeterOptions = {}): IMeter {\n    // https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#meter-creation\n    if (this._shutdown) {\n      diag.warn('A shutdown MeterProvider cannot provide a Meter');\n      return createNoopMeter();\n    }\n\n    return this._sharedState.getMeterSharedState({\n      name,\n      version,\n      schemaUrl: options.schemaUrl,\n    }).meter;\n  }\n\n  /**\n   * Register a {@link MetricReader} to the meter provider. After the\n   * registration, the MetricReader can start metrics collection.\n   *\n   * <p> NOTE: {@link MetricReader} instances MUST be added before creating any instruments.\n   * A {@link MetricReader} instance registered later may receive no or incomplete metric data.\n   *\n   * @param metricReader the metric reader to be registered.\n   *\n   * @deprecated This method will be removed in SDK 2.0. Please use\n   * {@link MeterProviderOptions.readers} via the {@link MeterProvider} constructor instead\n   */\n  addMetricReader(metricReader: MetricReader) {\n    const collector = new MetricCollector(this._sharedState, metricReader);\n    metricReader.setMetricProducer(collector);\n    this._sharedState.metricCollectors.push(collector);\n  }\n\n  /**\n   * Flush all buffered data and shut down the MeterProvider and all registered\n   * MetricReaders.\n   *\n   * Returns a promise which is resolved when all flushes are complete.\n   */\n  async shutdown(options?: ShutdownOptions): Promise<void> {\n    if (this._shutdown) {\n      diag.warn('shutdown may only be called once per MeterProvider');\n      return;\n    }\n\n    this._shutdown = true;\n\n    await Promise.all(\n      this._sharedState.metricCollectors.map(collector => {\n        return collector.shutdown(options);\n      })\n    );\n  }\n\n  /**\n   * Notifies all registered MetricReaders to flush any buffered data.\n   *\n   * Returns a promise which is resolved when all flushes are complete.\n   */\n  async forceFlush(options?: ForceFlushOptions): Promise<void> {\n    // do not flush after shutdown\n    if (this._shutdown) {\n      diag.warn('invalid attempt to force flush after MeterProvider shutdown');\n      return;\n    }\n\n    await Promise.all(\n      this._sharedState.metricCollectors.map(collector => {\n        return collector.forceFlush(options);\n      })\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}