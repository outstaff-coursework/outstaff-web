{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AggregatorKind } from './types';\nimport { millisToHrTime, hrTimeToMicroseconds } from '@opentelemetry/core';\nimport { DataPointType } from '../export/MetricData';\nvar LastValueAccumulation = /** @class */function () {\n  function LastValueAccumulation(startTime, _current, sampleTime) {\n    if (_current === void 0) {\n      _current = 0;\n    }\n    if (sampleTime === void 0) {\n      sampleTime = [0, 0];\n    }\n    this.startTime = startTime;\n    this._current = _current;\n    this.sampleTime = sampleTime;\n  }\n  LastValueAccumulation.prototype.record = function (value) {\n    this._current = value;\n    this.sampleTime = millisToHrTime(Date.now());\n  };\n  LastValueAccumulation.prototype.setStartTime = function (startTime) {\n    this.startTime = startTime;\n  };\n  LastValueAccumulation.prototype.toPointValue = function () {\n    return this._current;\n  };\n  return LastValueAccumulation;\n}();\nexport { LastValueAccumulation };\n/** Basic aggregator which calculates a LastValue from individual measurements. */\nvar LastValueAggregator = /** @class */function () {\n  function LastValueAggregator() {\n    this.kind = AggregatorKind.LAST_VALUE;\n  }\n  LastValueAggregator.prototype.createAccumulation = function (startTime) {\n    return new LastValueAccumulation(startTime);\n  };\n  /**\n   * Returns the result of the merge of the given accumulations.\n   *\n   * Return the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  LastValueAggregator.prototype.merge = function (previous, delta) {\n    // nanoseconds may lose precisions.\n    var latestAccumulation = hrTimeToMicroseconds(delta.sampleTime) >= hrTimeToMicroseconds(previous.sampleTime) ? delta : previous;\n    return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);\n  };\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   *\n   * A delta aggregation is not meaningful to LastValueAggregator, just return\n   * the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  LastValueAggregator.prototype.diff = function (previous, current) {\n    // nanoseconds may lose precisions.\n    var latestAccumulation = hrTimeToMicroseconds(current.sampleTime) >= hrTimeToMicroseconds(previous.sampleTime) ? current : previous;\n    return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);\n  };\n  LastValueAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor: descriptor,\n      aggregationTemporality: aggregationTemporality,\n      dataPointType: DataPointType.GAUGE,\n      dataPoints: accumulationByAttributes.map(function (_a) {\n        var _b = __read(_a, 2),\n          attributes = _b[0],\n          accumulation = _b[1];\n        return {\n          attributes: attributes,\n          startTime: accumulation.startTime,\n          endTime: endTime,\n          value: accumulation.toPointValue()\n        };\n      })\n    };\n  };\n  return LastValueAggregator;\n}();\nexport { LastValueAggregator };","map":{"version":3,"names":["AggregatorKind","millisToHrTime","hrTimeToMicroseconds","DataPointType","LastValueAccumulation","startTime","_current","sampleTime","prototype","record","value","Date","now","setStartTime","toPointValue","LastValueAggregator","kind","LAST_VALUE","createAccumulation","merge","previous","delta","latestAccumulation","diff","current","toMetricData","descriptor","aggregationTemporality","accumulationByAttributes","endTime","dataPointType","GAUGE","dataPoints","map","_a","_b","__read","attributes","accumulation"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/aggregator/LastValue.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n  LastValue,\n} from './types';\nimport { HrTime } from '@opentelemetry/api';\nimport { millisToHrTime, hrTimeToMicroseconds } from '@opentelemetry/core';\nimport {\n  DataPointType,\n  GaugeMetricData,\n  MetricDescriptor,\n} from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\n\nexport class LastValueAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    private _current: number = 0,\n    public sampleTime: HrTime = [0, 0]\n  ) {}\n\n  record(value: number): void {\n    this._current = value;\n    this.sampleTime = millisToHrTime(Date.now());\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): LastValue {\n    return this._current;\n  }\n}\n\n/** Basic aggregator which calculates a LastValue from individual measurements. */\nexport class LastValueAggregator implements Aggregator<LastValueAccumulation> {\n  public kind: AggregatorKind.LAST_VALUE = AggregatorKind.LAST_VALUE;\n\n  createAccumulation(startTime: HrTime) {\n    return new LastValueAccumulation(startTime);\n  }\n\n  /**\n   * Returns the result of the merge of the given accumulations.\n   *\n   * Return the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  merge(\n    previous: LastValueAccumulation,\n    delta: LastValueAccumulation\n  ): LastValueAccumulation {\n    // nanoseconds may lose precisions.\n    const latestAccumulation =\n      hrTimeToMicroseconds(delta.sampleTime) >=\n      hrTimeToMicroseconds(previous.sampleTime)\n        ? delta\n        : previous;\n    return new LastValueAccumulation(\n      previous.startTime,\n      latestAccumulation.toPointValue(),\n      latestAccumulation.sampleTime\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   *\n   * A delta aggregation is not meaningful to LastValueAggregator, just return\n   * the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  diff(\n    previous: LastValueAccumulation,\n    current: LastValueAccumulation\n  ): LastValueAccumulation {\n    // nanoseconds may lose precisions.\n    const latestAccumulation =\n      hrTimeToMicroseconds(current.sampleTime) >=\n      hrTimeToMicroseconds(previous.sampleTime)\n        ? current\n        : previous;\n    return new LastValueAccumulation(\n      current.startTime,\n      latestAccumulation.toPointValue(),\n      latestAccumulation.sampleTime\n    );\n  }\n\n  toMetricData(\n    descriptor: MetricDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<LastValueAccumulation>[],\n    endTime: HrTime\n  ): Maybe<GaugeMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.GAUGE,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: accumulation.toPointValue(),\n        };\n      }),\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}