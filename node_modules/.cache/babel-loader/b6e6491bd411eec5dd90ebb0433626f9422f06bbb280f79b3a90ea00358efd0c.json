{"ast":null,"code":"import { isString } from '../utils';\nimport { BatchExecutor } from './batchExecutor';\nimport { TransportItemType } from './const';\nexport function shouldIgnoreEvent(patterns, msg) {\n  return patterns.some(pattern => {\n    return isString(pattern) ? msg.includes(pattern) : !!msg.match(pattern);\n  });\n}\nexport function createBeforeSendHookFromIgnorePatterns(patterns) {\n  return item => {\n    if (item.type === TransportItemType.EXCEPTION && item.payload) {\n      const evt = item.payload;\n      const msg = \"\".concat(evt.type, \": \").concat(evt.value);\n      if (shouldIgnoreEvent(patterns, msg)) {\n        return null;\n      }\n    }\n    return item;\n  };\n}\nexport function initializeTransports(unpatchedConsole, internalLogger, config, metas) {\n  var _a;\n  internalLogger.debug('Initializing transports');\n  const transports = [];\n  let paused = config.paused;\n  let beforeSendHooks = [];\n  const add = function () {\n    internalLogger.debug('Adding transports');\n    for (var _len = arguments.length, newTransports = new Array(_len), _key = 0; _key < _len; _key++) {\n      newTransports[_key] = arguments[_key];\n    }\n    newTransports.forEach(newTransport => {\n      internalLogger.debug(\"Adding \\\"\".concat(newTransport.name, \"\\\" transport\"));\n      const exists = transports.some(existingTransport => existingTransport === newTransport);\n      if (exists) {\n        internalLogger.warn(\"Transport \".concat(newTransport.name, \" is already added\"));\n        return;\n      }\n      newTransport.unpatchedConsole = unpatchedConsole;\n      newTransport.internalLogger = internalLogger;\n      newTransport.config = config;\n      newTransport.metas = metas;\n      transports.push(newTransport);\n    });\n  };\n  const addBeforeSendHooks = function () {\n    internalLogger.debug('Adding beforeSendHooks\\n', beforeSendHooks);\n    for (var _len2 = arguments.length, newBeforeSendHooks = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      newBeforeSendHooks[_key2] = arguments[_key2];\n    }\n    newBeforeSendHooks.forEach(beforeSendHook => {\n      if (beforeSendHook) {\n        beforeSendHooks.push(beforeSendHook);\n      }\n    });\n  };\n  const addIgnoreErrorsPatterns = function () {\n    for (var _len3 = arguments.length, ignoreErrorsPatterns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      ignoreErrorsPatterns[_key3] = arguments[_key3];\n    }\n    internalLogger.debug('Adding ignoreErrorsPatterns\\n', ignoreErrorsPatterns);\n    ignoreErrorsPatterns.forEach(ignoreErrorsPattern => {\n      if (ignoreErrorsPattern) {\n        beforeSendHooks.push(createBeforeSendHookFromIgnorePatterns(ignoreErrorsPattern));\n      }\n    });\n  };\n  const applyBeforeSendHooks = items => {\n    let filteredItems = items;\n    for (const hook of beforeSendHooks) {\n      const modified = filteredItems.map(hook).filter(Boolean);\n      if (modified.length === 0) {\n        return [];\n      }\n      filteredItems = modified;\n    }\n    return filteredItems;\n  };\n  const batchedSend = items => {\n    const filteredItems = applyBeforeSendHooks(items);\n    if (filteredItems.length === 0) {\n      return;\n    }\n    for (const transport of transports) {\n      internalLogger.debug(\"Transporting item using \".concat(transport.name, \"\\n\"), filteredItems);\n      if (transport.isBatched()) {\n        transport.send(filteredItems);\n      }\n    }\n  };\n  const instantSend = item => {\n    var _a, _b;\n    // prevent all beforeSend hooks being executed twice if batching is enabled.\n    if (((_a = config.batching) === null || _a === void 0 ? void 0 : _a.enabled) && transports.every(transport => transport.isBatched())) {\n      return;\n    }\n    const [filteredItem] = applyBeforeSendHooks([item]);\n    if (filteredItem === undefined) {\n      return;\n    }\n    for (const transport of transports) {\n      internalLogger.debug(\"Transporting item using \".concat(transport.name, \"\\n\"), filteredItem);\n      if (!transport.isBatched()) {\n        transport.send(filteredItem);\n      } else if (!((_b = config.batching) === null || _b === void 0 ? void 0 : _b.enabled)) {\n        transport.send([filteredItem]);\n      }\n    }\n  };\n  let batchExecutor;\n  if ((_a = config.batching) === null || _a === void 0 ? void 0 : _a.enabled) {\n    batchExecutor = new BatchExecutor(batchedSend, {\n      sendTimeout: config.batching.sendTimeout,\n      itemLimit: config.batching.itemLimit,\n      paused\n    });\n  }\n  // Send a signal to the appropriate transports\n  //\n  // 1. If SDK is paused, early return\n  // 2. If batching is not enabled send the signal to all transports\n  //    instantly.\n  // 3i. If batching is enabled, enqueue the signal\n  // 3ii. Send the signal instantly to all un-batched transports\n  const execute = item => {\n    var _a;\n    if (paused) {\n      return;\n    }\n    if ((_a = config.batching) === null || _a === void 0 ? void 0 : _a.enabled) {\n      batchExecutor === null || batchExecutor === void 0 ? void 0 : batchExecutor.addItem(item);\n    }\n    instantSend(item);\n  };\n  const getBeforeSendHooks = () => [...beforeSendHooks];\n  const isPaused = () => paused;\n  const pause = () => {\n    internalLogger.debug('Pausing transports');\n    batchExecutor === null || batchExecutor === void 0 ? void 0 : batchExecutor.pause();\n    paused = true;\n  };\n  const remove = function () {\n    internalLogger.debug('Removing transports');\n    for (var _len4 = arguments.length, transportsToRemove = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      transportsToRemove[_key4] = arguments[_key4];\n    }\n    transportsToRemove.forEach(transportToRemove => {\n      internalLogger.debug(\"Removing \\\"\".concat(transportToRemove.name, \"\\\" transport\"));\n      const existingTransportIndex = transports.indexOf(transportToRemove);\n      if (existingTransportIndex === -1) {\n        internalLogger.warn(\"Transport \\\"\".concat(transportToRemove.name, \"\\\" is not added\"));\n        return;\n      }\n      transports.splice(existingTransportIndex, 1);\n    });\n  };\n  const removeBeforeSendHooks = function () {\n    for (var _len5 = arguments.length, beforeSendHooksToRemove = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      beforeSendHooksToRemove[_key5] = arguments[_key5];\n    }\n    beforeSendHooks.filter(beforeSendHook => !beforeSendHooksToRemove.includes(beforeSendHook));\n  };\n  const unpause = () => {\n    internalLogger.debug('Unpausing transports');\n    batchExecutor === null || batchExecutor === void 0 ? void 0 : batchExecutor.start();\n    paused = false;\n  };\n  return {\n    add,\n    addBeforeSendHooks,\n    addIgnoreErrorsPatterns,\n    getBeforeSendHooks,\n    execute,\n    isPaused,\n    pause,\n    remove,\n    removeBeforeSendHooks,\n    get transports() {\n      return [...transports];\n    },\n    unpause\n  };\n}","map":{"version":3,"names":["isString","BatchExecutor","TransportItemType","shouldIgnoreEvent","patterns","msg","some","pattern","includes","match","createBeforeSendHookFromIgnorePatterns","item","type","EXCEPTION","payload","evt","concat","value","initializeTransports","unpatchedConsole","internalLogger","config","metas","debug","transports","paused","beforeSendHooks","add","_len","arguments","length","newTransports","Array","_key","forEach","newTransport","name","exists","existingTransport","warn","push","addBeforeSendHooks","_len2","newBeforeSendHooks","_key2","beforeSendHook","addIgnoreErrorsPatterns","_len3","ignoreErrorsPatterns","_key3","ignoreErrorsPattern","applyBeforeSendHooks","items","filteredItems","hook","modified","map","filter","Boolean","batchedSend","transport","isBatched","send","instantSend","_a","batching","enabled","every","filteredItem","undefined","_b","batchExecutor","sendTimeout","itemLimit","execute","addItem","getBeforeSendHooks","isPaused","pause","remove","_len4","transportsToRemove","_key4","transportToRemove","existingTransportIndex","indexOf","splice","removeBeforeSendHooks","_len5","beforeSendHooksToRemove","_key5","unpause","start"],"sources":["/home/egor/node_modules/@grafana/faro-core/src/transports/initialize.ts"],"sourcesContent":["import type { TransportItem } from '..';\nimport type { ExceptionEvent } from '../api';\nimport type { Config, Patterns } from '../config';\nimport type { InternalLogger } from '../internalLogger';\nimport type { Metas } from '../metas';\nimport type { UnpatchedConsole } from '../unpatchedConsole';\nimport { isString } from '../utils';\n\nimport { BatchExecutor } from './batchExecutor';\nimport { TransportItemType } from './const';\nimport type { BeforeSendHook, Transport, Transports } from './types';\n\nexport function shouldIgnoreEvent(patterns: Patterns, msg: string): boolean {\n  return patterns.some((pattern) => {\n    return isString(pattern) ? msg.includes(pattern) : !!msg.match(pattern);\n  });\n}\n\nexport function createBeforeSendHookFromIgnorePatterns(patterns: Patterns): BeforeSendHook {\n  return (item: TransportItem) => {\n    if (item.type === TransportItemType.EXCEPTION && item.payload) {\n      const evt = item.payload as ExceptionEvent;\n      const msg = `${evt.type}: ${evt.value}`;\n\n      if (shouldIgnoreEvent(patterns, msg)) {\n        return null;\n      }\n    }\n\n    return item;\n  };\n}\n\nexport function initializeTransports(\n  unpatchedConsole: UnpatchedConsole,\n  internalLogger: InternalLogger,\n  config: Config,\n  metas: Metas\n): Transports {\n  internalLogger.debug('Initializing transports');\n\n  const transports: Transport[] = [];\n\n  let paused = config.paused;\n\n  let beforeSendHooks: BeforeSendHook[] = [];\n\n  const add: Transports['add'] = (...newTransports) => {\n    internalLogger.debug('Adding transports');\n\n    newTransports.forEach((newTransport) => {\n      internalLogger.debug(`Adding \"${newTransport.name}\" transport`);\n\n      const exists = transports.some((existingTransport) => existingTransport === newTransport);\n\n      if (exists) {\n        internalLogger.warn(`Transport ${newTransport.name} is already added`);\n\n        return;\n      }\n\n      newTransport.unpatchedConsole = unpatchedConsole;\n      newTransport.internalLogger = internalLogger;\n      newTransport.config = config;\n      newTransport.metas = metas;\n\n      transports.push(newTransport);\n    });\n  };\n\n  const addBeforeSendHooks: Transports['addBeforeSendHooks'] = (...newBeforeSendHooks) => {\n    internalLogger.debug('Adding beforeSendHooks\\n', beforeSendHooks);\n\n    newBeforeSendHooks.forEach((beforeSendHook) => {\n      if (beforeSendHook) {\n        beforeSendHooks.push(beforeSendHook);\n      }\n    });\n  };\n\n  const addIgnoreErrorsPatterns: Transports['addIgnoreErrorsPatterns'] = (...ignoreErrorsPatterns) => {\n    internalLogger.debug('Adding ignoreErrorsPatterns\\n', ignoreErrorsPatterns);\n\n    ignoreErrorsPatterns.forEach((ignoreErrorsPattern) => {\n      if (ignoreErrorsPattern) {\n        beforeSendHooks.push(createBeforeSendHookFromIgnorePatterns(ignoreErrorsPattern));\n      }\n    });\n  };\n\n  const applyBeforeSendHooks = (items: TransportItem[]): TransportItem[] => {\n    let filteredItems = items;\n    for (const hook of beforeSendHooks) {\n      const modified = filteredItems.map(hook).filter(Boolean) as TransportItem[];\n\n      if (modified.length === 0) {\n        return [];\n      }\n\n      filteredItems = modified;\n    }\n    return filteredItems;\n  };\n\n  const batchedSend = (items: TransportItem[]) => {\n    const filteredItems = applyBeforeSendHooks(items);\n\n    if (filteredItems.length === 0) {\n      return;\n    }\n\n    for (const transport of transports) {\n      internalLogger.debug(`Transporting item using ${transport.name}\\n`, filteredItems);\n      if (transport.isBatched()) {\n        transport.send(filteredItems);\n      }\n    }\n  };\n\n  const instantSend = (item: TransportItem) => {\n    // prevent all beforeSend hooks being executed twice if batching is enabled.\n    if (config.batching?.enabled && transports.every((transport) => transport.isBatched())) {\n      return;\n    }\n\n    const [filteredItem] = applyBeforeSendHooks([item]);\n\n    if (filteredItem === undefined) {\n      return;\n    }\n\n    for (const transport of transports) {\n      internalLogger.debug(`Transporting item using ${transport.name}\\n`, filteredItem);\n      if (!transport.isBatched()) {\n        transport.send(filteredItem);\n      } else if (!config.batching?.enabled) {\n        transport.send([filteredItem]);\n      }\n    }\n  };\n\n  let batchExecutor: BatchExecutor | undefined;\n\n  if (config.batching?.enabled) {\n    batchExecutor = new BatchExecutor(batchedSend, {\n      sendTimeout: config.batching.sendTimeout,\n      itemLimit: config.batching.itemLimit,\n      paused,\n    });\n  }\n\n  // Send a signal to the appropriate transports\n  //\n  // 1. If SDK is paused, early return\n  // 2. If batching is not enabled send the signal to all transports\n  //    instantly.\n  // 3i. If batching is enabled, enqueue the signal\n  // 3ii. Send the signal instantly to all un-batched transports\n  const execute: Transports['execute'] = (item) => {\n    if (paused) {\n      return;\n    }\n\n    if (config.batching?.enabled) {\n      batchExecutor?.addItem(item);\n    }\n\n    instantSend(item);\n  };\n\n  const getBeforeSendHooks: Transports['getBeforeSendHooks'] = () => [...beforeSendHooks];\n\n  const isPaused: Transports['isPaused'] = () => paused;\n\n  const pause: Transports['pause'] = () => {\n    internalLogger.debug('Pausing transports');\n    batchExecutor?.pause();\n\n    paused = true;\n  };\n\n  const remove: Transports['remove'] = (...transportsToRemove) => {\n    internalLogger.debug('Removing transports');\n\n    transportsToRemove.forEach((transportToRemove) => {\n      internalLogger.debug(`Removing \"${transportToRemove.name}\" transport`);\n\n      const existingTransportIndex = transports.indexOf(transportToRemove);\n\n      if (existingTransportIndex === -1) {\n        internalLogger.warn(`Transport \"${transportToRemove.name}\" is not added`);\n\n        return;\n      }\n\n      transports.splice(existingTransportIndex, 1);\n    });\n  };\n\n  const removeBeforeSendHooks: Transports['removeBeforeSendHooks'] = (...beforeSendHooksToRemove) => {\n    beforeSendHooks.filter((beforeSendHook) => !beforeSendHooksToRemove.includes(beforeSendHook));\n  };\n\n  const unpause: Transports['unpause'] = () => {\n    internalLogger.debug('Unpausing transports');\n    batchExecutor?.start();\n\n    paused = false;\n  };\n\n  return {\n    add,\n    addBeforeSendHooks,\n    addIgnoreErrorsPatterns,\n    getBeforeSendHooks,\n    execute,\n    isPaused,\n    pause,\n    remove,\n    removeBeforeSendHooks,\n    get transports() {\n      return [...transports];\n    },\n    unpause,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}