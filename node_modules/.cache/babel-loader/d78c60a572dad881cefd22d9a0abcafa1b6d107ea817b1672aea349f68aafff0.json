{"ast":null,"code":"'use strict';\n\nfunction isFunction(funktion) {\n  return typeof funktion === 'function';\n}\n\n// Default to complaining loudly when things don't go according to plan.\nvar logger = console.error.bind(console);\n\n// Sets a property on an object, preserving its enumerability.\n// This function assumes that the property is already writable.\nfunction defineProperty(obj, name, value) {\n  var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable: enumerable,\n    writable: true,\n    value: value\n  });\n}\n\n// Keep initialization idempotent.\nfunction shimmer(options) {\n  if (options && options.logger) {\n    if (!isFunction(options.logger)) logger(\"new logger isn't a function, not replacing\");else logger = options.logger;\n  }\n}\nfunction wrap(nodule, name, wrapper) {\n  if (!nodule || !nodule[name]) {\n    logger('no original function ' + name + ' to wrap');\n    return;\n  }\n  if (!wrapper) {\n    logger('no wrapper function');\n    logger(new Error().stack);\n    return;\n  }\n  if (!isFunction(nodule[name]) || !isFunction(wrapper)) {\n    logger('original object and wrapper must be functions');\n    return;\n  }\n  var original = nodule[name];\n  var wrapped = wrapper(original, name);\n  defineProperty(wrapped, '__original', original);\n  defineProperty(wrapped, '__unwrap', function () {\n    if (nodule[name] === wrapped) defineProperty(nodule, name, original);\n  });\n  defineProperty(wrapped, '__wrapped', true);\n  defineProperty(nodule, name, wrapped);\n  return wrapped;\n}\nfunction massWrap(nodules, names, wrapper) {\n  if (!nodules) {\n    logger('must provide one or more modules to patch');\n    logger(new Error().stack);\n    return;\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules];\n  }\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to wrap on modules');\n    return;\n  }\n  nodules.forEach(function (nodule) {\n    names.forEach(function (name) {\n      wrap(nodule, name, wrapper);\n    });\n  });\n}\nfunction unwrap(nodule, name) {\n  if (!nodule || !nodule[name]) {\n    logger('no function to unwrap.');\n    logger(new Error().stack);\n    return;\n  }\n  if (!nodule[name].__unwrap) {\n    logger('no original to unwrap to -- has ' + name + ' already been unwrapped?');\n  } else {\n    return nodule[name].__unwrap();\n  }\n}\nfunction massUnwrap(nodules, names) {\n  if (!nodules) {\n    logger('must provide one or more modules to patch');\n    logger(new Error().stack);\n    return;\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules];\n  }\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to unwrap on modules');\n    return;\n  }\n  nodules.forEach(function (nodule) {\n    names.forEach(function (name) {\n      unwrap(nodule, name);\n    });\n  });\n}\nshimmer.wrap = wrap;\nshimmer.massWrap = massWrap;\nshimmer.unwrap = unwrap;\nshimmer.massUnwrap = massUnwrap;\nmodule.exports = shimmer;","map":{"version":3,"names":["isFunction","funktion","logger","console","error","bind","defineProperty","obj","name","value","enumerable","propertyIsEnumerable","Object","configurable","writable","shimmer","options","wrap","nodule","wrapper","Error","stack","original","wrapped","massWrap","nodules","names","Array","isArray","forEach","unwrap","__unwrap","massUnwrap","module","exports"],"sources":["/home/egor/node_modules/shimmer/index.js"],"sourcesContent":["'use strict'\n\nfunction isFunction (funktion) {\n  return typeof funktion === 'function'\n}\n\n// Default to complaining loudly when things don't go according to plan.\nvar logger = console.error.bind(console)\n\n// Sets a property on an object, preserving its enumerability.\n// This function assumes that the property is already writable.\nfunction defineProperty (obj, name, value) {\n  var enumerable = !!obj[name] && obj.propertyIsEnumerable(name)\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable: enumerable,\n    writable: true,\n    value: value\n  })\n}\n\n// Keep initialization idempotent.\nfunction shimmer (options) {\n  if (options && options.logger) {\n    if (!isFunction(options.logger)) logger(\"new logger isn't a function, not replacing\")\n    else logger = options.logger\n  }\n}\n\nfunction wrap (nodule, name, wrapper) {\n  if (!nodule || !nodule[name]) {\n    logger('no original function ' + name + ' to wrap')\n    return\n  }\n\n  if (!wrapper) {\n    logger('no wrapper function')\n    logger((new Error()).stack)\n    return\n  }\n\n  if (!isFunction(nodule[name]) || !isFunction(wrapper)) {\n    logger('original object and wrapper must be functions')\n    return\n  }\n\n  var original = nodule[name]\n  var wrapped = wrapper(original, name)\n\n  defineProperty(wrapped, '__original', original)\n  defineProperty(wrapped, '__unwrap', function () {\n    if (nodule[name] === wrapped) defineProperty(nodule, name, original)\n  })\n  defineProperty(wrapped, '__wrapped', true)\n\n  defineProperty(nodule, name, wrapped)\n  return wrapped\n}\n\nfunction massWrap (nodules, names, wrapper) {\n  if (!nodules) {\n    logger('must provide one or more modules to patch')\n    logger((new Error()).stack)\n    return\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules]\n  }\n\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to wrap on modules')\n    return\n  }\n\n  nodules.forEach(function (nodule) {\n    names.forEach(function (name) {\n      wrap(nodule, name, wrapper)\n    })\n  })\n}\n\nfunction unwrap (nodule, name) {\n  if (!nodule || !nodule[name]) {\n    logger('no function to unwrap.')\n    logger((new Error()).stack)\n    return\n  }\n\n  if (!nodule[name].__unwrap) {\n    logger('no original to unwrap to -- has ' + name + ' already been unwrapped?')\n  } else {\n    return nodule[name].__unwrap()\n  }\n}\n\nfunction massUnwrap (nodules, names) {\n  if (!nodules) {\n    logger('must provide one or more modules to patch')\n    logger((new Error()).stack)\n    return\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules]\n  }\n\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to unwrap on modules')\n    return\n  }\n\n  nodules.forEach(function (nodule) {\n    names.forEach(function (name) {\n      unwrap(nodule, name)\n    })\n  })\n}\n\nshimmer.wrap = wrap\nshimmer.massWrap = massWrap\nshimmer.unwrap = unwrap\nshimmer.massUnwrap = massUnwrap\n\nmodule.exports = shimmer\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}