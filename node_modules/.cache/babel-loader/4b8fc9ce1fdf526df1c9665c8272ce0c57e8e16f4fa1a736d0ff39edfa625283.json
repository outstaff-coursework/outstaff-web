{"ast":null,"code":"var __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { toAttributes } from '../common/internal';\nimport { sdkSpanToOtlpSpan } from './internal';\nimport { getOtlpEncoder } from '../common';\nexport function createExportTraceServiceRequest(spans, options) {\n  var encoder = getOtlpEncoder(options);\n  return {\n    resourceSpans: spanRecordsToResourceSpans(spans, encoder)\n  };\n}\nfunction createResourceMap(readableSpans) {\n  var e_1, _a;\n  var resourceMap = new Map();\n  try {\n    for (var readableSpans_1 = __values(readableSpans), readableSpans_1_1 = readableSpans_1.next(); !readableSpans_1_1.done; readableSpans_1_1 = readableSpans_1.next()) {\n      var record = readableSpans_1_1.value;\n      var ilmMap = resourceMap.get(record.resource);\n      if (!ilmMap) {\n        ilmMap = new Map();\n        resourceMap.set(record.resource, ilmMap);\n      }\n      // TODO this is duplicated in basic tracer. Consolidate on a common helper in core\n      var instrumentationLibraryKey = record.instrumentationLibrary.name + \"@\" + (record.instrumentationLibrary.version || '') + \":\" + (record.instrumentationLibrary.schemaUrl || '');\n      var records = ilmMap.get(instrumentationLibraryKey);\n      if (!records) {\n        records = [];\n        ilmMap.set(instrumentationLibraryKey, records);\n      }\n      records.push(record);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (readableSpans_1_1 && !readableSpans_1_1.done && (_a = readableSpans_1.return)) _a.call(readableSpans_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return resourceMap;\n}\nfunction spanRecordsToResourceSpans(readableSpans, encoder) {\n  var resourceMap = createResourceMap(readableSpans);\n  var out = [];\n  var entryIterator = resourceMap.entries();\n  var entry = entryIterator.next();\n  while (!entry.done) {\n    var _a = __read(entry.value, 2),\n      resource = _a[0],\n      ilmMap = _a[1];\n    var scopeResourceSpans = [];\n    var ilmIterator = ilmMap.values();\n    var ilmEntry = ilmIterator.next();\n    while (!ilmEntry.done) {\n      var scopeSpans = ilmEntry.value;\n      if (scopeSpans.length > 0) {\n        var _b = scopeSpans[0].instrumentationLibrary,\n          name_1 = _b.name,\n          version = _b.version,\n          schemaUrl = _b.schemaUrl;\n        var spans = scopeSpans.map(function (readableSpan) {\n          return sdkSpanToOtlpSpan(readableSpan, encoder);\n        });\n        scopeResourceSpans.push({\n          scope: {\n            name: name_1,\n            version: version\n          },\n          spans: spans,\n          schemaUrl: schemaUrl\n        });\n      }\n      ilmEntry = ilmIterator.next();\n    }\n    // TODO SDK types don't provide resource schema URL at this time\n    var transformedSpans = {\n      resource: {\n        attributes: toAttributes(resource.attributes),\n        droppedAttributesCount: 0\n      },\n      scopeSpans: scopeResourceSpans,\n      schemaUrl: undefined\n    };\n    out.push(transformedSpans);\n    entry = entryIterator.next();\n  }\n  return out;\n}","map":{"version":3,"names":["toAttributes","sdkSpanToOtlpSpan","getOtlpEncoder","createExportTraceServiceRequest","spans","options","encoder","resourceSpans","spanRecordsToResourceSpans","createResourceMap","readableSpans","resourceMap","Map","readableSpans_1","__values","readableSpans_1_1","next","done","record","value","ilmMap","get","resource","set","instrumentationLibraryKey","instrumentationLibrary","name","version","schemaUrl","records","push","out","entryIterator","entries","entry","_a","__read","scopeResourceSpans","ilmIterator","values","ilmEntry","scopeSpans","length","_b","name_1","map","readableSpan","scope","transformedSpans","attributes","droppedAttributesCount","undefined"],"sources":["/home/egor/node_modules/@opentelemetry/otlp-transformer/src/trace/index.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { IResource } from '@opentelemetry/resources';\nimport type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport type { OtlpEncodingOptions } from '../common/types';\nimport { toAttributes } from '../common/internal';\nimport { sdkSpanToOtlpSpan } from './internal';\nimport {\n  IExportTraceServiceRequest,\n  IResourceSpans,\n  IScopeSpans,\n} from './types';\nimport { Encoder, getOtlpEncoder } from '../common';\n\nexport function createExportTraceServiceRequest(\n  spans: ReadableSpan[],\n  options?: OtlpEncodingOptions\n): IExportTraceServiceRequest {\n  const encoder = getOtlpEncoder(options);\n  return {\n    resourceSpans: spanRecordsToResourceSpans(spans, encoder),\n  };\n}\n\nfunction createResourceMap(readableSpans: ReadableSpan[]) {\n  const resourceMap: Map<IResource, Map<string, ReadableSpan[]>> = new Map();\n  for (const record of readableSpans) {\n    let ilmMap = resourceMap.get(record.resource);\n\n    if (!ilmMap) {\n      ilmMap = new Map();\n      resourceMap.set(record.resource, ilmMap);\n    }\n\n    // TODO this is duplicated in basic tracer. Consolidate on a common helper in core\n    const instrumentationLibraryKey = `${record.instrumentationLibrary.name}@${\n      record.instrumentationLibrary.version || ''\n    }:${record.instrumentationLibrary.schemaUrl || ''}`;\n    let records = ilmMap.get(instrumentationLibraryKey);\n\n    if (!records) {\n      records = [];\n      ilmMap.set(instrumentationLibraryKey, records);\n    }\n\n    records.push(record);\n  }\n\n  return resourceMap;\n}\n\nfunction spanRecordsToResourceSpans(\n  readableSpans: ReadableSpan[],\n  encoder: Encoder\n): IResourceSpans[] {\n  const resourceMap = createResourceMap(readableSpans);\n  const out: IResourceSpans[] = [];\n\n  const entryIterator = resourceMap.entries();\n  let entry = entryIterator.next();\n  while (!entry.done) {\n    const [resource, ilmMap] = entry.value;\n    const scopeResourceSpans: IScopeSpans[] = [];\n    const ilmIterator = ilmMap.values();\n    let ilmEntry = ilmIterator.next();\n    while (!ilmEntry.done) {\n      const scopeSpans = ilmEntry.value;\n      if (scopeSpans.length > 0) {\n        const { name, version, schemaUrl } =\n          scopeSpans[0].instrumentationLibrary;\n        const spans = scopeSpans.map(readableSpan =>\n          sdkSpanToOtlpSpan(readableSpan, encoder)\n        );\n\n        scopeResourceSpans.push({\n          scope: { name, version },\n          spans: spans,\n          schemaUrl: schemaUrl,\n        });\n      }\n      ilmEntry = ilmIterator.next();\n    }\n    // TODO SDK types don't provide resource schema URL at this time\n    const transformedSpans: IResourceSpans = {\n      resource: {\n        attributes: toAttributes(resource.attributes),\n        droppedAttributesCount: 0,\n      },\n      scopeSpans: scopeResourceSpans,\n      schemaUrl: undefined,\n    };\n\n    out.push(transformedSpans);\n    entry = entryIterator.next();\n  }\n\n  return out;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}