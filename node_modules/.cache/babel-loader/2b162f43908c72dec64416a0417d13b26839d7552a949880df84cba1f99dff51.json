{"ast":null,"code":"import { BaseInstrumentation, dateNow, EVENT_SESSION_EXTEND, EVENT_SESSION_RESUME, EVENT_SESSION_START, VERSION } from '@grafana/faro-core';\nimport { createSession } from '../../metas';\nimport { isSampled } from './sessionManager';\nimport { PersistentSessionsManager } from './sessionManager/PersistentSessionsManager';\nimport { createUserSessionObject, isUserSessionValid } from './sessionManager/sessionManagerUtils';\nimport { VolatileSessionsManager } from './sessionManager/VolatileSessionManager';\nexport class SessionInstrumentation extends BaseInstrumentation {\n  constructor() {\n    super(...arguments);\n    this.name = '@grafana/faro-web-sdk:instrumentation-session';\n    this.version = VERSION;\n  }\n  sendSessionStartEvent(meta) {\n    var _a, _b;\n    const session = meta.session;\n    if (session && session.id !== ((_a = this.notifiedSession) === null || _a === void 0 ? void 0 : _a.id)) {\n      if (this.notifiedSession && this.notifiedSession.id === ((_b = session.attributes) === null || _b === void 0 ? void 0 : _b['previousSession'])) {\n        this.api.pushEvent(EVENT_SESSION_EXTEND, {}, undefined, {\n          skipDedupe: true\n        });\n        this.notifiedSession = session;\n        return;\n      }\n      this.notifiedSession = session;\n      // no need to add attributes and session id, they are included as part of meta\n      // automatically\n      this.api.pushEvent(EVENT_SESSION_START, {}, undefined, {\n        skipDedupe: true\n      });\n    }\n  }\n  createInitialSessionMeta(sessionsConfig) {\n    var _a, _b, _c;\n    const sessionManager = sessionsConfig.persistent ? PersistentSessionsManager : VolatileSessionsManager;\n    let userSession = sessionManager.fetchUserSession();\n    if (sessionsConfig.persistent && sessionsConfig.maxSessionPersistenceTime && userSession) {\n      const now = dateNow();\n      const shouldClearPersistentSession = userSession.lastActivity < now - sessionsConfig.maxSessionPersistenceTime;\n      if (shouldClearPersistentSession) {\n        PersistentSessionsManager.removeUserSession();\n        userSession = null;\n      }\n    }\n    let sessionId = (_a = sessionsConfig.session) === null || _a === void 0 ? void 0 : _a.id;\n    let sessionAttributes = (_b = sessionsConfig.session) === null || _b === void 0 ? void 0 : _b.attributes;\n    let lifecycleType;\n    if (isUserSessionValid(userSession)) {\n      sessionId = userSession === null || userSession === void 0 ? void 0 : userSession.sessionId;\n      sessionAttributes = Object.assign(Object.assign(Object.assign({}, sessionAttributes), (_c = userSession === null || userSession === void 0 ? void 0 : userSession.sessionMeta) === null || _c === void 0 ? void 0 : _c.attributes), {\n        isSampled: (userSession.isSampled || false).toString()\n      });\n      lifecycleType = EVENT_SESSION_RESUME;\n    } else {\n      sessionId = sessionId !== null && sessionId !== void 0 ? sessionId : createSession().id;\n      lifecycleType = EVENT_SESSION_START;\n    }\n    const sessionMeta = {\n      id: sessionId,\n      attributes: Object.assign({\n        isSampled: isSampled().toString()\n      }, sessionAttributes)\n    };\n    return {\n      sessionMeta,\n      lifecycleType\n    };\n  }\n  registerBeforeSendHook(SessionManager) {\n    var _a;\n    const {\n      updateSession\n    } = new SessionManager();\n    (_a = this.transports) === null || _a === void 0 ? void 0 : _a.addBeforeSendHooks(item => {\n      var _a, _b, _c;\n      updateSession();\n      const attributes = (_a = item.meta.session) === null || _a === void 0 ? void 0 : _a.attributes;\n      if (attributes && (attributes === null || attributes === void 0 ? void 0 : attributes['isSampled']) === 'true') {\n        let newItem;\n        // Structured clone is supported in all major browsers\n        // but for old browsers we need a fallback\n        if ('structuredClone' in window) {\n          newItem = structuredClone(item);\n        } else {\n          newItem = JSON.parse(JSON.stringify(item));\n        }\n        const newAttributes = (_b = newItem.meta.session) === null || _b === void 0 ? void 0 : _b.attributes;\n        newAttributes === null || newAttributes === void 0 ? true : delete newAttributes['isSampled'];\n        if (Object.keys(newAttributes !== null && newAttributes !== void 0 ? newAttributes : {}).length === 0) {\n          (_c = newItem.meta.session) === null || _c === void 0 ? true : delete _c.attributes;\n        }\n        return newItem;\n      }\n      return null;\n    });\n  }\n  initialize() {\n    var _a, _b;\n    this.logDebug('init session instrumentation');\n    const sessionTracking = this.config.sessionTracking;\n    if (sessionTracking === null || sessionTracking === void 0 ? void 0 : sessionTracking.enabled) {\n      const SessionManager = ((_a = this.config.sessionTracking) === null || _a === void 0 ? void 0 : _a.persistent) ? PersistentSessionsManager : VolatileSessionsManager;\n      this.registerBeforeSendHook(SessionManager);\n      const {\n        sessionMeta: initialSessionMeta,\n        lifecycleType\n      } = this.createInitialSessionMeta(sessionTracking);\n      SessionManager.storeUserSession(Object.assign(Object.assign({}, createUserSessionObject({\n        sessionId: initialSessionMeta.id,\n        isSampled: ((_b = initialSessionMeta.attributes) === null || _b === void 0 ? void 0 : _b['isSampled']) === 'true'\n      })), {\n        sessionMeta: initialSessionMeta\n      }));\n      this.notifiedSession = initialSessionMeta;\n      this.api.setSession(initialSessionMeta);\n      if (lifecycleType === EVENT_SESSION_START) {\n        this.api.pushEvent(EVENT_SESSION_START, {}, undefined, {\n          skipDedupe: true\n        });\n      }\n      if (lifecycleType === EVENT_SESSION_RESUME) {\n        this.api.pushEvent(EVENT_SESSION_RESUME, {}, undefined, {\n          skipDedupe: true\n        });\n      }\n    }\n    this.metas.addListener(this.sendSessionStartEvent.bind(this));\n  }\n}","map":{"version":3,"names":["BaseInstrumentation","dateNow","EVENT_SESSION_EXTEND","EVENT_SESSION_RESUME","EVENT_SESSION_START","VERSION","createSession","isSampled","PersistentSessionsManager","createUserSessionObject","isUserSessionValid","VolatileSessionsManager","SessionInstrumentation","constructor","name","version","sendSessionStartEvent","meta","session","id","_a","notifiedSession","_b","attributes","api","pushEvent","undefined","skipDedupe","createInitialSessionMeta","sessionsConfig","sessionManager","persistent","userSession","fetchUserSession","maxSessionPersistenceTime","now","shouldClearPersistentSession","lastActivity","removeUserSession","sessionId","sessionAttributes","lifecycleType","Object","assign","_c","sessionMeta","toString","registerBeforeSendHook","SessionManager","updateSession","transports","addBeforeSendHooks","item","newItem","window","structuredClone","JSON","parse","stringify","newAttributes","keys","length","initialize","logDebug","sessionTracking","config","enabled","initialSessionMeta","storeUserSession","setSession","metas","addListener","bind"],"sources":["/home/egor/node_modules/@grafana/faro-web-sdk/src/instrumentations/session/instrumentation.ts"],"sourcesContent":["import {\n  BaseInstrumentation,\n  dateNow,\n  EVENT_SESSION_EXTEND,\n  EVENT_SESSION_RESUME,\n  EVENT_SESSION_START,\n  Meta,\n  MetaSession,\n  VERSION,\n} from '@grafana/faro-core';\nimport type { Config } from '@grafana/faro-core';\n\nimport type { TransportItem } from '../..';\nimport { createSession } from '../../metas';\n\nimport { type FaroUserSession, isSampled } from './sessionManager';\nimport { PersistentSessionsManager } from './sessionManager/PersistentSessionsManager';\nimport { createUserSessionObject, isUserSessionValid } from './sessionManager/sessionManagerUtils';\nimport { VolatileSessionsManager } from './sessionManager/VolatileSessionManager';\n\ntype LifecycleType = typeof EVENT_SESSION_RESUME | typeof EVENT_SESSION_START;\n\nexport class SessionInstrumentation extends BaseInstrumentation {\n  readonly name = '@grafana/faro-web-sdk:instrumentation-session';\n  readonly version = VERSION;\n\n  // previously notified session, to ensure we don't send session start\n  // event twice for the same session\n  private notifiedSession: MetaSession | undefined;\n\n  private sendSessionStartEvent(meta: Meta): void {\n    const session = meta.session;\n\n    if (session && session.id !== this.notifiedSession?.id) {\n      if (this.notifiedSession && this.notifiedSession.id === session.attributes?.['previousSession']) {\n        this.api.pushEvent(EVENT_SESSION_EXTEND, {}, undefined, { skipDedupe: true });\n        this.notifiedSession = session;\n        return;\n      }\n\n      this.notifiedSession = session;\n      // no need to add attributes and session id, they are included as part of meta\n      // automatically\n      this.api.pushEvent(EVENT_SESSION_START, {}, undefined, { skipDedupe: true });\n    }\n  }\n\n  private createInitialSessionMeta(sessionsConfig: Required<Config>['sessionTracking']): {\n    sessionMeta: MetaSession;\n    lifecycleType: LifecycleType;\n  } {\n    const sessionManager = sessionsConfig.persistent ? PersistentSessionsManager : VolatileSessionsManager;\n\n    let userSession: FaroUserSession | null = sessionManager.fetchUserSession();\n\n    if (sessionsConfig.persistent && sessionsConfig.maxSessionPersistenceTime && userSession) {\n      const now = dateNow();\n      const shouldClearPersistentSession = userSession.lastActivity < now - sessionsConfig.maxSessionPersistenceTime;\n\n      if (shouldClearPersistentSession) {\n        PersistentSessionsManager.removeUserSession();\n        userSession = null;\n      }\n    }\n\n    let sessionId = sessionsConfig.session?.id;\n    let sessionAttributes = sessionsConfig.session?.attributes;\n\n    let lifecycleType: LifecycleType;\n\n    if (isUserSessionValid(userSession)) {\n      sessionId = userSession?.sessionId;\n      sessionAttributes = {\n        ...sessionAttributes,\n        ...userSession?.sessionMeta?.attributes,\n        isSampled: (userSession!.isSampled || false).toString(),\n      };\n\n      lifecycleType = EVENT_SESSION_RESUME;\n    } else {\n      sessionId = sessionId ?? createSession().id;\n      lifecycleType = EVENT_SESSION_START;\n    }\n\n    const sessionMeta: MetaSession = {\n      id: sessionId,\n      attributes: {\n        isSampled: isSampled().toString(),\n        // We do not want to recalculate the sampling decision on each init phase.\n        // If session from web-storage has a isSampled attribute we will use that instead.\n        ...sessionAttributes,\n      },\n    };\n\n    return { sessionMeta, lifecycleType };\n  }\n\n  private registerBeforeSendHook(SessionManager: typeof VolatileSessionsManager | typeof PersistentSessionsManager) {\n    const { updateSession } = new SessionManager();\n\n    this.transports?.addBeforeSendHooks((item) => {\n      updateSession();\n\n      const attributes = item.meta.session?.attributes;\n\n      if (attributes && attributes?.['isSampled'] === 'true') {\n        let newItem: TransportItem;\n\n        // Structured clone is supported in all major browsers\n        // but for old browsers we need a fallback\n        if ('structuredClone' in window) {\n          newItem = structuredClone(item);\n        } else {\n          newItem = JSON.parse(JSON.stringify(item));\n        }\n\n        const newAttributes = newItem.meta.session?.attributes;\n        delete newAttributes?.['isSampled'];\n\n        if (Object.keys(newAttributes ?? {}).length === 0) {\n          delete newItem.meta.session?.attributes;\n        }\n\n        return newItem;\n      }\n\n      return null;\n    });\n  }\n\n  initialize() {\n    this.logDebug('init session instrumentation');\n\n    const sessionTracking = this.config.sessionTracking;\n\n    if (sessionTracking?.enabled) {\n      const SessionManager = this.config.sessionTracking?.persistent\n        ? PersistentSessionsManager\n        : VolatileSessionsManager;\n\n      this.registerBeforeSendHook(SessionManager);\n\n      const { sessionMeta: initialSessionMeta, lifecycleType } = this.createInitialSessionMeta(sessionTracking);\n\n      SessionManager.storeUserSession({\n        ...createUserSessionObject({\n          sessionId: initialSessionMeta.id,\n          isSampled: initialSessionMeta.attributes?.['isSampled'] === 'true',\n        }),\n        sessionMeta: initialSessionMeta,\n      });\n\n      this.notifiedSession = initialSessionMeta;\n      this.api.setSession(initialSessionMeta);\n\n      if (lifecycleType === EVENT_SESSION_START) {\n        this.api.pushEvent(EVENT_SESSION_START, {}, undefined, { skipDedupe: true });\n      }\n\n      if (lifecycleType === EVENT_SESSION_RESUME) {\n        this.api.pushEvent(EVENT_SESSION_RESUME, {}, undefined, { skipDedupe: true });\n      }\n    }\n\n    this.metas.addListener(this.sendSessionStartEvent.bind(this));\n  }\n}\n"],"mappings":"AAAA,SACEA,mBAAmB,EACnBC,OAAO,EACPC,oBAAoB,EACpBC,oBAAoB,EACpBC,mBAAmB,EAGnBC,OAAO,QACF,oBAAoB;AAI3B,SAASC,aAAa,QAAQ,aAAa;AAE3C,SAA+BC,SAAS,QAAQ,kBAAkB;AAClE,SAASC,yBAAyB,QAAQ,4CAA4C;AACtF,SAASC,uBAAuB,EAAEC,kBAAkB,QAAQ,sCAAsC;AAClG,SAASC,uBAAuB,QAAQ,yCAAyC;AAIjF,OAAM,MAAOC,sBAAuB,SAAQZ,mBAAmB;EAA/Da,YAAA;;IACW,KAAAC,IAAI,GAAG,+CAA+C;IACtD,KAAAC,OAAO,GAAGV,OAAO;EA8I5B;EAxIUW,qBAAqBA,CAACC,IAAU;;IACtC,MAAMC,OAAO,GAAGD,IAAI,CAACC,OAAO;IAE5B,IAAIA,OAAO,IAAIA,OAAO,CAACC,EAAE,MAAK,CAAAC,EAAA,OAAI,CAACC,eAAe,cAAAD,EAAA,uBAAAA,EAAA,CAAED,EAAE,GAAE;MACtD,IAAI,IAAI,CAACE,eAAe,IAAI,IAAI,CAACA,eAAe,CAACF,EAAE,MAAK,CAAAG,EAAA,GAAAJ,OAAO,CAACK,UAAU,cAAAD,EAAA,uBAAAA,EAAA,CAAG,iBAAiB,CAAC,GAAE;QAC/F,IAAI,CAACE,GAAG,CAACC,SAAS,CAACvB,oBAAoB,EAAE,EAAE,EAAEwB,SAAS,EAAE;UAAEC,UAAU,EAAE;QAAI,CAAE,CAAC;QAC7E,IAAI,CAACN,eAAe,GAAGH,OAAO;QAC9B;;MAGF,IAAI,CAACG,eAAe,GAAGH,OAAO;MAC9B;MACA;MACA,IAAI,CAACM,GAAG,CAACC,SAAS,CAACrB,mBAAmB,EAAE,EAAE,EAAEsB,SAAS,EAAE;QAAEC,UAAU,EAAE;MAAI,CAAE,CAAC;;EAEhF;EAEQC,wBAAwBA,CAACC,cAAmD;;IAIlF,MAAMC,cAAc,GAAGD,cAAc,CAACE,UAAU,GAAGvB,yBAAyB,GAAGG,uBAAuB;IAEtG,IAAIqB,WAAW,GAA2BF,cAAc,CAACG,gBAAgB,EAAE;IAE3E,IAAIJ,cAAc,CAACE,UAAU,IAAIF,cAAc,CAACK,yBAAyB,IAAIF,WAAW,EAAE;MACxF,MAAMG,GAAG,GAAGlC,OAAO,EAAE;MACrB,MAAMmC,4BAA4B,GAAGJ,WAAW,CAACK,YAAY,GAAGF,GAAG,GAAGN,cAAc,CAACK,yBAAyB;MAE9G,IAAIE,4BAA4B,EAAE;QAChC5B,yBAAyB,CAAC8B,iBAAiB,EAAE;QAC7CN,WAAW,GAAG,IAAI;;;IAItB,IAAIO,SAAS,GAAG,CAAAnB,EAAA,GAAAS,cAAc,CAACX,OAAO,cAAAE,EAAA,uBAAAA,EAAA,CAAED,EAAE;IAC1C,IAAIqB,iBAAiB,GAAG,CAAAlB,EAAA,GAAAO,cAAc,CAACX,OAAO,cAAAI,EAAA,uBAAAA,EAAA,CAAEC,UAAU;IAE1D,IAAIkB,aAA4B;IAEhC,IAAI/B,kBAAkB,CAACsB,WAAW,CAAC,EAAE;MACnCO,SAAS,GAAGP,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEO,SAAS;MAClCC,iBAAiB,GAAAE,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACZH,iBAAiB,GACjB,CAAAI,EAAA,GAAAZ,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEa,WAAW,cAAAD,EAAA,uBAAAA,EAAA,CAAErB,UAAU;QACvChB,SAAS,EAAE,CAACyB,WAAY,CAACzB,SAAS,IAAI,KAAK,EAAEuC,QAAQ;MAAE,EACxD;MAEDL,aAAa,GAAGtC,oBAAoB;KACrC,MAAM;MACLoC,SAAS,GAAGA,SAAS,aAATA,SAAS,cAATA,SAAS,GAAIjC,aAAa,EAAE,CAACa,EAAE;MAC3CsB,aAAa,GAAGrC,mBAAmB;;IAGrC,MAAMyC,WAAW,GAAgB;MAC/B1B,EAAE,EAAEoB,SAAS;MACbhB,UAAU,EAAAmB,MAAA,CAAAC,MAAA;QACRpC,SAAS,EAAEA,SAAS,EAAE,CAACuC,QAAQ;MAAE,GAG9BN,iBAAiB;KAEvB;IAED,OAAO;MAAEK,WAAW;MAAEJ;IAAa,CAAE;EACvC;EAEQM,sBAAsBA,CAACC,cAAiF;;IAC9G,MAAM;MAAEC;IAAa,CAAE,GAAG,IAAID,cAAc,EAAE;IAE9C,CAAA5B,EAAA,OAAI,CAAC8B,UAAU,cAAA9B,EAAA,uBAAAA,EAAA,CAAE+B,kBAAkB,CAAEC,IAAI,IAAI;;MAC3CH,aAAa,EAAE;MAEf,MAAM1B,UAAU,GAAG,CAAAH,EAAA,GAAAgC,IAAI,CAACnC,IAAI,CAACC,OAAO,cAAAE,EAAA,uBAAAA,EAAA,CAAEG,UAAU;MAEhD,IAAIA,UAAU,IAAI,CAAAA,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAG,WAAW,CAAC,MAAK,MAAM,EAAE;QACtD,IAAI8B,OAAsB;QAE1B;QACA;QACA,IAAI,iBAAiB,IAAIC,MAAM,EAAE;UAC/BD,OAAO,GAAGE,eAAe,CAACH,IAAI,CAAC;SAChC,MAAM;UACLC,OAAO,GAAGG,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACN,IAAI,CAAC,CAAC;;QAG5C,MAAMO,aAAa,GAAG,CAAArC,EAAA,GAAA+B,OAAO,CAACpC,IAAI,CAACC,OAAO,cAAAI,EAAA,uBAAAA,EAAA,CAAEC,UAAU;QAC/CoC,aAAa,aAAbA,aAAa,4BAAbA,aAAa,CAAG,WAAW,CAAC;QAEnC,IAAIjB,MAAM,CAACkB,IAAI,CAACD,aAAa,aAAbA,aAAa,cAAbA,aAAa,GAAI,EAAE,CAAC,CAACE,MAAM,KAAK,CAAC,EAAE;UAC1C,CAAAjB,EAAA,GAAAS,OAAO,CAACpC,IAAI,CAACC,OAAO,cAAA0B,EAAA,4BAAAA,EAAA,CAAErB,UAAU;;QAGzC,OAAO8B,OAAO;;MAGhB,OAAO,IAAI;IACb,CAAC,CAAC;EACJ;EAEAS,UAAUA,CAAA;;IACR,IAAI,CAACC,QAAQ,CAAC,8BAA8B,CAAC;IAE7C,MAAMC,eAAe,GAAG,IAAI,CAACC,MAAM,CAACD,eAAe;IAEnD,IAAIA,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEE,OAAO,EAAE;MAC5B,MAAMlB,cAAc,GAAG,EAAA5B,EAAA,OAAI,CAAC6C,MAAM,CAACD,eAAe,cAAA5C,EAAA,uBAAAA,EAAA,CAAEW,UAAU,IAC1DvB,yBAAyB,GACzBG,uBAAuB;MAE3B,IAAI,CAACoC,sBAAsB,CAACC,cAAc,CAAC;MAE3C,MAAM;QAAEH,WAAW,EAAEsB,kBAAkB;QAAE1B;MAAa,CAAE,GAAG,IAAI,CAACb,wBAAwB,CAACoC,eAAe,CAAC;MAEzGhB,cAAc,CAACoB,gBAAgB,CAAA1B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAC1BlC,uBAAuB,CAAC;QACzB8B,SAAS,EAAE4B,kBAAkB,CAAChD,EAAE;QAChCZ,SAAS,EAAE,EAAAe,EAAA,GAAA6C,kBAAkB,CAAC5C,UAAU,cAAAD,EAAA,uBAAAA,EAAA,CAAG,WAAW,CAAC,MAAK;OAC7D,CAAC;QACFuB,WAAW,EAAEsB;MAAkB,GAC/B;MAEF,IAAI,CAAC9C,eAAe,GAAG8C,kBAAkB;MACzC,IAAI,CAAC3C,GAAG,CAAC6C,UAAU,CAACF,kBAAkB,CAAC;MAEvC,IAAI1B,aAAa,KAAKrC,mBAAmB,EAAE;QACzC,IAAI,CAACoB,GAAG,CAACC,SAAS,CAACrB,mBAAmB,EAAE,EAAE,EAAEsB,SAAS,EAAE;UAAEC,UAAU,EAAE;QAAI,CAAE,CAAC;;MAG9E,IAAIc,aAAa,KAAKtC,oBAAoB,EAAE;QAC1C,IAAI,CAACqB,GAAG,CAACC,SAAS,CAACtB,oBAAoB,EAAE,EAAE,EAAEuB,SAAS,EAAE;UAAEC,UAAU,EAAE;QAAI,CAAE,CAAC;;;IAIjF,IAAI,CAAC2C,KAAK,CAACC,WAAW,CAAC,IAAI,CAACvD,qBAAqB,CAACwD,IAAI,CAAC,IAAI,CAAC,CAAC;EAC/D"},"metadata":{},"sourceType":"module","externalDependencies":[]}