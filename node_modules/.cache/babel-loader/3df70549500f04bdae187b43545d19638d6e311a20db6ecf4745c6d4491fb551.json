{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createInstrumentDescriptor, InstrumentType } from './InstrumentDescriptor';\nimport { CounterInstrument, HistogramInstrument, ObservableCounterInstrument, ObservableGaugeInstrument, ObservableUpDownCounterInstrument, UpDownCounterInstrument } from './Instruments';\n/**\n * This class implements the {@link IMeter} interface.\n */\nvar Meter = /** @class */function () {\n  function Meter(_meterSharedState) {\n    this._meterSharedState = _meterSharedState;\n  }\n  /**\n   * Create a {@link Histogram} instrument.\n   */\n  Meter.prototype.createHistogram = function (name, options) {\n    var descriptor = createInstrumentDescriptor(name, InstrumentType.HISTOGRAM, options);\n    var storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new HistogramInstrument(storage, descriptor);\n  };\n  /**\n   * Create a {@link Counter} instrument.\n   */\n  Meter.prototype.createCounter = function (name, options) {\n    var descriptor = createInstrumentDescriptor(name, InstrumentType.COUNTER, options);\n    var storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new CounterInstrument(storage, descriptor);\n  };\n  /**\n   * Create a {@link UpDownCounter} instrument.\n   */\n  Meter.prototype.createUpDownCounter = function (name, options) {\n    var descriptor = createInstrumentDescriptor(name, InstrumentType.UP_DOWN_COUNTER, options);\n    var storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new UpDownCounterInstrument(storage, descriptor);\n  };\n  /**\n   * Create a {@link ObservableGauge} instrument.\n   */\n  Meter.prototype.createObservableGauge = function (name, options) {\n    var descriptor = createInstrumentDescriptor(name, InstrumentType.OBSERVABLE_GAUGE, options);\n    var storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);\n    return new ObservableGaugeInstrument(descriptor, storages, this._meterSharedState.observableRegistry);\n  };\n  /**\n   * Create a {@link ObservableCounter} instrument.\n   */\n  Meter.prototype.createObservableCounter = function (name, options) {\n    var descriptor = createInstrumentDescriptor(name, InstrumentType.OBSERVABLE_COUNTER, options);\n    var storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);\n    return new ObservableCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);\n  };\n  /**\n   * Create a {@link ObservableUpDownCounter} instrument.\n   */\n  Meter.prototype.createObservableUpDownCounter = function (name, options) {\n    var descriptor = createInstrumentDescriptor(name, InstrumentType.OBSERVABLE_UP_DOWN_COUNTER, options);\n    var storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);\n    return new ObservableUpDownCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);\n  };\n  /**\n   * @see {@link Meter.addBatchObservableCallback}\n   */\n  Meter.prototype.addBatchObservableCallback = function (callback, observables) {\n    this._meterSharedState.observableRegistry.addBatchCallback(callback, observables);\n  };\n  /**\n   * @see {@link Meter.removeBatchObservableCallback}\n   */\n  Meter.prototype.removeBatchObservableCallback = function (callback, observables) {\n    this._meterSharedState.observableRegistry.removeBatchCallback(callback, observables);\n  };\n  return Meter;\n}();\nexport { Meter };","map":{"version":3,"names":["createInstrumentDescriptor","InstrumentType","CounterInstrument","HistogramInstrument","ObservableCounterInstrument","ObservableGaugeInstrument","ObservableUpDownCounterInstrument","UpDownCounterInstrument","Meter","_meterSharedState","prototype","createHistogram","name","options","descriptor","HISTOGRAM","storage","registerMetricStorage","createCounter","COUNTER","createUpDownCounter","UP_DOWN_COUNTER","createObservableGauge","OBSERVABLE_GAUGE","storages","registerAsyncMetricStorage","observableRegistry","createObservableCounter","OBSERVABLE_COUNTER","createObservableUpDownCounter","OBSERVABLE_UP_DOWN_COUNTER","addBatchObservableCallback","callback","observables","addBatchCallback","removeBatchObservableCallback","removeBatchCallback"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/Meter.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Meter as IMeter,\n  MetricOptions,\n  Histogram,\n  Counter,\n  UpDownCounter,\n  ObservableGauge,\n  ObservableCounter,\n  ObservableUpDownCounter,\n  BatchObservableCallback,\n  Observable,\n} from '@opentelemetry/api';\nimport {\n  createInstrumentDescriptor,\n  InstrumentType,\n} from './InstrumentDescriptor';\nimport {\n  CounterInstrument,\n  HistogramInstrument,\n  ObservableCounterInstrument,\n  ObservableGaugeInstrument,\n  ObservableUpDownCounterInstrument,\n  UpDownCounterInstrument,\n} from './Instruments';\nimport { MeterSharedState } from './state/MeterSharedState';\n\n/**\n * This class implements the {@link IMeter} interface.\n */\nexport class Meter implements IMeter {\n  constructor(private _meterSharedState: MeterSharedState) {}\n\n  /**\n   * Create a {@link Histogram} instrument.\n   */\n  createHistogram(name: string, options?: MetricOptions): Histogram {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.HISTOGRAM,\n      options\n    );\n    const storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new HistogramInstrument(storage, descriptor);\n  }\n\n  /**\n   * Create a {@link Counter} instrument.\n   */\n  createCounter(name: string, options?: MetricOptions): Counter {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.COUNTER,\n      options\n    );\n    const storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new CounterInstrument(storage, descriptor);\n  }\n\n  /**\n   * Create a {@link UpDownCounter} instrument.\n   */\n  createUpDownCounter(name: string, options?: MetricOptions): UpDownCounter {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.UP_DOWN_COUNTER,\n      options\n    );\n    const storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new UpDownCounterInstrument(storage, descriptor);\n  }\n\n  /**\n   * Create a {@link ObservableGauge} instrument.\n   */\n  createObservableGauge(\n    name: string,\n    options?: MetricOptions\n  ): ObservableGauge {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.OBSERVABLE_GAUGE,\n      options\n    );\n    const storages =\n      this._meterSharedState.registerAsyncMetricStorage(descriptor);\n    return new ObservableGaugeInstrument(\n      descriptor,\n      storages,\n      this._meterSharedState.observableRegistry\n    );\n  }\n\n  /**\n   * Create a {@link ObservableCounter} instrument.\n   */\n  createObservableCounter(\n    name: string,\n    options?: MetricOptions\n  ): ObservableCounter {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.OBSERVABLE_COUNTER,\n      options\n    );\n    const storages =\n      this._meterSharedState.registerAsyncMetricStorage(descriptor);\n    return new ObservableCounterInstrument(\n      descriptor,\n      storages,\n      this._meterSharedState.observableRegistry\n    );\n  }\n\n  /**\n   * Create a {@link ObservableUpDownCounter} instrument.\n   */\n  createObservableUpDownCounter(\n    name: string,\n    options?: MetricOptions\n  ): ObservableUpDownCounter {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.OBSERVABLE_UP_DOWN_COUNTER,\n      options\n    );\n    const storages =\n      this._meterSharedState.registerAsyncMetricStorage(descriptor);\n    return new ObservableUpDownCounterInstrument(\n      descriptor,\n      storages,\n      this._meterSharedState.observableRegistry\n    );\n  }\n\n  /**\n   * @see {@link Meter.addBatchObservableCallback}\n   */\n  addBatchObservableCallback(\n    callback: BatchObservableCallback,\n    observables: Observable[]\n  ) {\n    this._meterSharedState.observableRegistry.addBatchCallback(\n      callback,\n      observables\n    );\n  }\n\n  /**\n   * @see {@link Meter.removeBatchObservableCallback}\n   */\n  removeBatchObservableCallback(\n    callback: BatchObservableCallback,\n    observables: Observable[]\n  ) {\n    this._meterSharedState.observableRegistry.removeBatchCallback(\n      callback,\n      observables\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}