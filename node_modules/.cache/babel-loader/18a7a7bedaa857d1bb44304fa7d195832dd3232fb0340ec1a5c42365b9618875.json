{"ast":null,"code":"import { TransportItemType } from '../../transports';\nimport { deepEqual, getCurrentTimestamp, isNull } from '../../utils';\nimport { defaultExceptionType } from './const';\nlet stacktraceParser;\nexport function initializeExceptionsAPI(_unpatchedConsole, internalLogger, config, metas, transports, tracesApi) {\n  var _a;\n  internalLogger.debug('Initializing exceptions API');\n  let lastPayload = null;\n  stacktraceParser = (_a = config.parseStacktrace) !== null && _a !== void 0 ? _a : stacktraceParser;\n  const changeStacktraceParser = newStacktraceParser => {\n    internalLogger.debug('Changing stacktrace parser');\n    stacktraceParser = newStacktraceParser !== null && newStacktraceParser !== void 0 ? newStacktraceParser : stacktraceParser;\n  };\n  const getStacktraceParser = () => stacktraceParser;\n  const pushError = function (error) {\n    let {\n      skipDedupe,\n      stackFrames,\n      type,\n      context\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    type = type || error.name || defaultExceptionType;\n    const item = {\n      meta: metas.value,\n      payload: {\n        type,\n        value: error.message,\n        timestamp: getCurrentTimestamp(),\n        trace: tracesApi.getTraceContext(),\n        context: context !== null && context !== void 0 ? context : {}\n      },\n      type: TransportItemType.EXCEPTION\n    };\n    stackFrames = stackFrames !== null && stackFrames !== void 0 ? stackFrames : error.stack ? stacktraceParser === null || stacktraceParser === void 0 ? void 0 : stacktraceParser(error).frames : undefined;\n    if (stackFrames === null || stackFrames === void 0 ? void 0 : stackFrames.length) {\n      item.payload.stacktrace = {\n        frames: stackFrames\n      };\n    }\n    const testingPayload = {\n      type: item.payload.type,\n      value: item.payload.value,\n      stackTrace: item.payload.stacktrace,\n      context: item.payload.context\n    };\n    if (!skipDedupe && config.dedupe && !isNull(lastPayload) && deepEqual(testingPayload, lastPayload)) {\n      internalLogger.debug('Skipping error push because it is the same as the last one\\n', item.payload);\n      return;\n    }\n    lastPayload = testingPayload;\n    internalLogger.debug('Pushing exception\\n', item);\n    transports.execute(item);\n  };\n  changeStacktraceParser(config.parseStacktrace);\n  return {\n    changeStacktraceParser,\n    getStacktraceParser,\n    pushError\n  };\n}","map":{"version":3,"names":["TransportItemType","deepEqual","getCurrentTimestamp","isNull","defaultExceptionType","stacktraceParser","initializeExceptionsAPI","_unpatchedConsole","internalLogger","config","metas","transports","tracesApi","debug","lastPayload","_a","parseStacktrace","changeStacktraceParser","newStacktraceParser","getStacktraceParser","pushError","error","skipDedupe","stackFrames","type","context","arguments","length","undefined","name","item","meta","value","payload","message","timestamp","trace","getTraceContext","EXCEPTION","stack","frames","stacktrace","testingPayload","stackTrace","dedupe","execute"],"sources":["/home/egor/node_modules/@grafana/faro-core/src/api/exceptions/initialize.ts"],"sourcesContent":["import type { Config } from '../../config';\nimport type { InternalLogger } from '../../internalLogger';\nimport type { Metas } from '../../metas';\nimport { TransportItemType } from '../../transports';\nimport type { TransportItem, Transports } from '../../transports';\nimport type { UnpatchedConsole } from '../../unpatchedConsole';\nimport { deepEqual, getCurrentTimestamp, isNull } from '../../utils';\nimport type { TracesAPI } from '../traces';\n\nimport { defaultExceptionType } from './const';\nimport type { ExceptionEvent, ExceptionsAPI, StacktraceParser } from './types';\n\nlet stacktraceParser: StacktraceParser | undefined;\n\nexport function initializeExceptionsAPI(\n  _unpatchedConsole: UnpatchedConsole,\n  internalLogger: InternalLogger,\n  config: Config,\n  metas: Metas,\n  transports: Transports,\n  tracesApi: TracesAPI\n): ExceptionsAPI {\n  internalLogger.debug('Initializing exceptions API');\n\n  let lastPayload: Pick<ExceptionEvent, 'type' | 'value' | 'stacktrace' | 'context'> | null = null;\n\n  stacktraceParser = config.parseStacktrace ?? stacktraceParser;\n\n  const changeStacktraceParser: ExceptionsAPI['changeStacktraceParser'] = (newStacktraceParser) => {\n    internalLogger.debug('Changing stacktrace parser');\n\n    stacktraceParser = newStacktraceParser ?? stacktraceParser;\n  };\n\n  const getStacktraceParser: ExceptionsAPI['getStacktraceParser'] = () => stacktraceParser;\n\n  const pushError: ExceptionsAPI['pushError'] = (error, { skipDedupe, stackFrames, type, context } = {}) => {\n    type = type || error.name || defaultExceptionType;\n\n    const item: TransportItem<ExceptionEvent> = {\n      meta: metas.value,\n      payload: {\n        type,\n        value: error.message,\n        timestamp: getCurrentTimestamp(),\n        trace: tracesApi.getTraceContext(),\n        context: context ?? {},\n      },\n      type: TransportItemType.EXCEPTION,\n    };\n\n    stackFrames = stackFrames ?? (error.stack ? stacktraceParser?.(error).frames : undefined);\n\n    if (stackFrames?.length) {\n      item.payload.stacktrace = {\n        frames: stackFrames,\n      };\n    }\n\n    const testingPayload = {\n      type: item.payload.type,\n      value: item.payload.value,\n      stackTrace: item.payload.stacktrace,\n      context: item.payload.context,\n    };\n\n    if (!skipDedupe && config.dedupe && !isNull(lastPayload) && deepEqual(testingPayload, lastPayload)) {\n      internalLogger.debug('Skipping error push because it is the same as the last one\\n', item.payload);\n\n      return;\n    }\n\n    lastPayload = testingPayload;\n\n    internalLogger.debug('Pushing exception\\n', item);\n\n    transports.execute(item);\n  };\n\n  changeStacktraceParser(config.parseStacktrace);\n\n  return {\n    changeStacktraceParser,\n    getStacktraceParser,\n    pushError,\n  };\n}\n"],"mappings":"AAGA,SAASA,iBAAiB,QAAQ,kBAAkB;AAGpD,SAASC,SAAS,EAAEC,mBAAmB,EAAEC,MAAM,QAAQ,aAAa;AAGpE,SAASC,oBAAoB,QAAQ,SAAS;AAG9C,IAAIC,gBAA8C;AAElD,OAAM,SAAUC,uBAAuBA,CACrCC,iBAAmC,EACnCC,cAA8B,EAC9BC,MAAc,EACdC,KAAY,EACZC,UAAsB,EACtBC,SAAoB;;EAEpBJ,cAAc,CAACK,KAAK,CAAC,6BAA6B,CAAC;EAEnD,IAAIC,WAAW,GAA6E,IAAI;EAEhGT,gBAAgB,GAAG,CAAAU,EAAA,GAAAN,MAAM,CAACO,eAAe,cAAAD,EAAA,cAAAA,EAAA,GAAIV,gBAAgB;EAE7D,MAAMY,sBAAsB,GAA6CC,mBAAmB,IAAI;IAC9FV,cAAc,CAACK,KAAK,CAAC,4BAA4B,CAAC;IAElDR,gBAAgB,GAAGa,mBAAmB,aAAnBA,mBAAmB,cAAnBA,mBAAmB,GAAIb,gBAAgB;EAC5D,CAAC;EAED,MAAMc,mBAAmB,GAAyCA,CAAA,KAAMd,gBAAgB;EAExF,MAAMe,SAAS,GAA+B,SAAAA,CAACC,KAAK,EAAqD;IAAA,IAAnD;MAAEC,UAAU;MAAEC,WAAW;MAAEC,IAAI;MAAEC;IAAO,CAAE,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;IACnGF,IAAI,GAAGA,IAAI,IAAIH,KAAK,CAACQ,IAAI,IAAIzB,oBAAoB;IAEjD,MAAM0B,IAAI,GAAkC;MAC1CC,IAAI,EAAErB,KAAK,CAACsB,KAAK;MACjBC,OAAO,EAAE;QACPT,IAAI;QACJQ,KAAK,EAAEX,KAAK,CAACa,OAAO;QACpBC,SAAS,EAAEjC,mBAAmB,EAAE;QAChCkC,KAAK,EAAExB,SAAS,CAACyB,eAAe,EAAE;QAClCZ,OAAO,EAAEA,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI;OACrB;MACDD,IAAI,EAAExB,iBAAiB,CAACsC;KACzB;IAEDf,WAAW,GAAGA,WAAW,aAAXA,WAAW,cAAXA,WAAW,GAAKF,KAAK,CAACkB,KAAK,GAAGlC,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAGgB,KAAK,EAAEmB,MAAM,GAAGZ,SAAU;IAEzF,IAAIL,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEI,MAAM,EAAE;MACvBG,IAAI,CAACG,OAAO,CAACQ,UAAU,GAAG;QACxBD,MAAM,EAAEjB;OACT;;IAGH,MAAMmB,cAAc,GAAG;MACrBlB,IAAI,EAAEM,IAAI,CAACG,OAAO,CAACT,IAAI;MACvBQ,KAAK,EAAEF,IAAI,CAACG,OAAO,CAACD,KAAK;MACzBW,UAAU,EAAEb,IAAI,CAACG,OAAO,CAACQ,UAAU;MACnChB,OAAO,EAAEK,IAAI,CAACG,OAAO,CAACR;KACvB;IAED,IAAI,CAACH,UAAU,IAAIb,MAAM,CAACmC,MAAM,IAAI,CAACzC,MAAM,CAACW,WAAW,CAAC,IAAIb,SAAS,CAACyC,cAAc,EAAE5B,WAAW,CAAC,EAAE;MAClGN,cAAc,CAACK,KAAK,CAAC,8DAA8D,EAAEiB,IAAI,CAACG,OAAO,CAAC;MAElG;;IAGFnB,WAAW,GAAG4B,cAAc;IAE5BlC,cAAc,CAACK,KAAK,CAAC,qBAAqB,EAAEiB,IAAI,CAAC;IAEjDnB,UAAU,CAACkC,OAAO,CAACf,IAAI,CAAC;EAC1B,CAAC;EAEDb,sBAAsB,CAACR,MAAM,CAACO,eAAe,CAAC;EAE9C,OAAO;IACLC,sBAAsB;IACtBE,mBAAmB;IACnBC;GACD;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}