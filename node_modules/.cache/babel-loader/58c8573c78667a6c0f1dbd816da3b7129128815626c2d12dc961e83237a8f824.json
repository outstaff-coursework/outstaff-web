{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { hexToBinary, hrTimeToNanoseconds } from '@opentelemetry/core';\nvar NANOSECONDS = BigInt(1000000000);\nexport function hrTimeToNanos(hrTime) {\n  return BigInt(hrTime[0]) * NANOSECONDS + BigInt(hrTime[1]);\n}\nexport function toLongBits(value) {\n  var low = Number(BigInt.asUintN(32, value));\n  var high = Number(BigInt.asUintN(32, value >> BigInt(32)));\n  return {\n    low: low,\n    high: high\n  };\n}\nexport function encodeAsLongBits(hrTime) {\n  var nanos = hrTimeToNanos(hrTime);\n  return toLongBits(nanos);\n}\nexport function encodeAsString(hrTime) {\n  var nanos = hrTimeToNanos(hrTime);\n  return nanos.toString();\n}\nvar encodeTimestamp = typeof BigInt !== 'undefined' ? encodeAsString : hrTimeToNanoseconds;\nfunction identity(value) {\n  return value;\n}\nfunction optionalHexToBinary(str) {\n  if (str === undefined) return undefined;\n  return hexToBinary(str);\n}\nvar DEFAULT_ENCODER = {\n  encodeHrTime: encodeAsLongBits,\n  encodeSpanContext: hexToBinary,\n  encodeOptionalSpanContext: optionalHexToBinary\n};\nexport function getOtlpEncoder(options) {\n  var _a, _b;\n  if (options === undefined) {\n    return DEFAULT_ENCODER;\n  }\n  var useLongBits = (_a = options.useLongBits) !== null && _a !== void 0 ? _a : true;\n  var useHex = (_b = options.useHex) !== null && _b !== void 0 ? _b : false;\n  return {\n    encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,\n    encodeSpanContext: useHex ? identity : hexToBinary,\n    encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary\n  };\n}","map":{"version":3,"names":["hexToBinary","hrTimeToNanoseconds","NANOSECONDS","BigInt","hrTimeToNanos","hrTime","toLongBits","value","low","Number","asUintN","high","encodeAsLongBits","nanos","encodeAsString","toString","encodeTimestamp","identity","optionalHexToBinary","str","undefined","DEFAULT_ENCODER","encodeHrTime","encodeSpanContext","encodeOptionalSpanContext","getOtlpEncoder","options","useLongBits","_a","useHex","_b"],"sources":["/home/egor/node_modules/@opentelemetry/otlp-transformer/src/common/index.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { OtlpEncodingOptions, Fixed64, LongBits } from './types';\nimport { HrTime } from '@opentelemetry/api';\nimport { hexToBinary, hrTimeToNanoseconds } from '@opentelemetry/core';\n\nconst NANOSECONDS = BigInt(1_000_000_000);\n\nexport function hrTimeToNanos(hrTime: HrTime): bigint {\n  return BigInt(hrTime[0]) * NANOSECONDS + BigInt(hrTime[1]);\n}\n\nexport function toLongBits(value: bigint): LongBits {\n  const low = Number(BigInt.asUintN(32, value));\n  const high = Number(BigInt.asUintN(32, value >> BigInt(32)));\n  return { low, high };\n}\n\nexport function encodeAsLongBits(hrTime: HrTime): LongBits {\n  const nanos = hrTimeToNanos(hrTime);\n  return toLongBits(nanos);\n}\n\nexport function encodeAsString(hrTime: HrTime): string {\n  const nanos = hrTimeToNanos(hrTime);\n  return nanos.toString();\n}\n\nconst encodeTimestamp =\n  typeof BigInt !== 'undefined' ? encodeAsString : hrTimeToNanoseconds;\n\nexport type HrTimeEncodeFunction = (hrTime: HrTime) => Fixed64;\nexport type SpanContextEncodeFunction = (\n  spanContext: string\n) => string | Uint8Array;\nexport type OptionalSpanContextEncodeFunction = (\n  spanContext: string | undefined\n) => string | Uint8Array | undefined;\n\nexport interface Encoder {\n  encodeHrTime: HrTimeEncodeFunction;\n  encodeSpanContext: SpanContextEncodeFunction;\n  encodeOptionalSpanContext: OptionalSpanContextEncodeFunction;\n}\n\nfunction identity<T>(value: T): T {\n  return value;\n}\n\nfunction optionalHexToBinary(str: string | undefined): Uint8Array | undefined {\n  if (str === undefined) return undefined;\n  return hexToBinary(str);\n}\n\nconst DEFAULT_ENCODER: Encoder = {\n  encodeHrTime: encodeAsLongBits,\n  encodeSpanContext: hexToBinary,\n  encodeOptionalSpanContext: optionalHexToBinary,\n};\n\nexport function getOtlpEncoder(options?: OtlpEncodingOptions): Encoder {\n  if (options === undefined) {\n    return DEFAULT_ENCODER;\n  }\n\n  const useLongBits = options.useLongBits ?? true;\n  const useHex = options.useHex ?? false;\n  return {\n    encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,\n    encodeSpanContext: useHex ? identity : hexToBinary,\n    encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary,\n  };\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAkBA,SAASA,WAAW,EAAEC,mBAAmB,QAAQ,qBAAqB;AAEtE,IAAMC,WAAW,GAAGC,MAAM,CAAC,UAAa,CAAC;AAEzC,OAAM,SAAUC,aAAaA,CAACC,MAAc;EAC1C,OAAOF,MAAM,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGH,WAAW,GAAGC,MAAM,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC;AAC5D;AAEA,OAAM,SAAUC,UAAUA,CAACC,KAAa;EACtC,IAAMC,GAAG,GAAGC,MAAM,CAACN,MAAM,CAACO,OAAO,CAAC,EAAE,EAAEH,KAAK,CAAC,CAAC;EAC7C,IAAMI,IAAI,GAAGF,MAAM,CAACN,MAAM,CAACO,OAAO,CAAC,EAAE,EAAEH,KAAK,IAAIJ,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;EAC5D,OAAO;IAAEK,GAAG,EAAAA,GAAA;IAAEG,IAAI,EAAAA;EAAA,CAAE;AACtB;AAEA,OAAM,SAAUC,gBAAgBA,CAACP,MAAc;EAC7C,IAAMQ,KAAK,GAAGT,aAAa,CAACC,MAAM,CAAC;EACnC,OAAOC,UAAU,CAACO,KAAK,CAAC;AAC1B;AAEA,OAAM,SAAUC,cAAcA,CAACT,MAAc;EAC3C,IAAMQ,KAAK,GAAGT,aAAa,CAACC,MAAM,CAAC;EACnC,OAAOQ,KAAK,CAACE,QAAQ,EAAE;AACzB;AAEA,IAAMC,eAAe,GACnB,OAAOb,MAAM,KAAK,WAAW,GAAGW,cAAc,GAAGb,mBAAmB;AAgBtE,SAASgB,QAAQA,CAAIV,KAAQ;EAC3B,OAAOA,KAAK;AACd;AAEA,SAASW,mBAAmBA,CAACC,GAAuB;EAClD,IAAIA,GAAG,KAAKC,SAAS,EAAE,OAAOA,SAAS;EACvC,OAAOpB,WAAW,CAACmB,GAAG,CAAC;AACzB;AAEA,IAAME,eAAe,GAAY;EAC/BC,YAAY,EAAEV,gBAAgB;EAC9BW,iBAAiB,EAAEvB,WAAW;EAC9BwB,yBAAyB,EAAEN;CAC5B;AAED,OAAM,SAAUO,cAAcA,CAACC,OAA6B;;EAC1D,IAAIA,OAAO,KAAKN,SAAS,EAAE;IACzB,OAAOC,eAAe;;EAGxB,IAAMM,WAAW,GAAG,CAAAC,EAAA,GAAAF,OAAO,CAACC,WAAW,cAAAC,EAAA,cAAAA,EAAA,GAAI,IAAI;EAC/C,IAAMC,MAAM,GAAG,CAAAC,EAAA,GAAAJ,OAAO,CAACG,MAAM,cAAAC,EAAA,cAAAA,EAAA,GAAI,KAAK;EACtC,OAAO;IACLR,YAAY,EAAEK,WAAW,GAAGf,gBAAgB,GAAGI,eAAe;IAC9DO,iBAAiB,EAAEM,MAAM,GAAGZ,QAAQ,GAAGjB,WAAW;IAClDwB,yBAAyB,EAAEK,MAAM,GAAGZ,QAAQ,GAAGC;GAChD;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}