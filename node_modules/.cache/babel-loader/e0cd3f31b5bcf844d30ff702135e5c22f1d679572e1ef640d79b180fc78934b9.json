{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { sanitizeAttributes, isTracingSuppressed } from '@opentelemetry/core';\nimport { Span } from './Span';\nimport { mergeConfig } from './utility';\nimport { RandomIdGenerator } from './platform';\n/**\n * This class represents a basic tracer.\n */\nvar Tracer = /** @class */function () {\n  /**\n   * Constructs a new Tracer instance.\n   */\n  function Tracer(instrumentationLibrary, config, _tracerProvider) {\n    this._tracerProvider = _tracerProvider;\n    var localConfig = mergeConfig(config);\n    this._sampler = localConfig.sampler;\n    this._generalLimits = localConfig.generalLimits;\n    this._spanLimits = localConfig.spanLimits;\n    this._idGenerator = config.idGenerator || new RandomIdGenerator();\n    this.resource = _tracerProvider.resource;\n    this.instrumentationLibrary = instrumentationLibrary;\n  }\n  /**\n   * Starts a new Span or returns the default NoopSpan based on the sampling\n   * decision.\n   */\n  Tracer.prototype.startSpan = function (name, options, context) {\n    var _a, _b, _c;\n    if (options === void 0) {\n      options = {};\n    }\n    if (context === void 0) {\n      context = api.context.active();\n    }\n    // remove span from context in case a root span is requested via options\n    if (options.root) {\n      context = api.trace.deleteSpan(context);\n    }\n    var parentSpan = api.trace.getSpan(context);\n    if (isTracingSuppressed(context)) {\n      api.diag.debug('Instrumentation suppressed, returning Noop Span');\n      var nonRecordingSpan = api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);\n      return nonRecordingSpan;\n    }\n    var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();\n    var spanId = this._idGenerator.generateSpanId();\n    var traceId;\n    var traceState;\n    var parentSpanId;\n    if (!parentSpanContext || !api.trace.isSpanContextValid(parentSpanContext)) {\n      // New root span.\n      traceId = this._idGenerator.generateTraceId();\n    } else {\n      // New child span.\n      traceId = parentSpanContext.traceId;\n      traceState = parentSpanContext.traceState;\n      parentSpanId = parentSpanContext.spanId;\n    }\n    var spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : api.SpanKind.INTERNAL;\n    var links = ((_b = options.links) !== null && _b !== void 0 ? _b : []).map(function (link) {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes)\n      };\n    });\n    var attributes = sanitizeAttributes(options.attributes);\n    // make sampling decision\n    var samplingResult = this._sampler.shouldSample(context, traceId, name, spanKind, attributes, links);\n    traceState = (_c = samplingResult.traceState) !== null && _c !== void 0 ? _c : traceState;\n    var traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE;\n    var spanContext = {\n      traceId: traceId,\n      spanId: spanId,\n      traceFlags: traceFlags,\n      traceState: traceState\n    };\n    if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n      api.diag.debug('Recording is off, propagating context in a non-recording span');\n      var nonRecordingSpan = api.trace.wrapSpanContext(spanContext);\n      return nonRecordingSpan;\n    }\n    // Set initial span attributes. The attributes object may have been mutated\n    // by the sampler, so we sanitize the merged attributes before setting them.\n    var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));\n    var span = new Span(this, context, name, spanContext, spanKind, parentSpanId, links, options.startTime, undefined, initAttributes);\n    return span;\n  };\n  Tracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {\n    var opts;\n    var ctx;\n    var fn;\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2;\n    } else if (arguments.length === 3) {\n      opts = arg2;\n      fn = arg3;\n    } else {\n      opts = arg2;\n      ctx = arg3;\n      fn = arg4;\n    }\n    var parentContext = ctx !== null && ctx !== void 0 ? ctx : api.context.active();\n    var span = this.startSpan(name, opts, parentContext);\n    var contextWithSpanSet = api.trace.setSpan(parentContext, span);\n    return api.context.with(contextWithSpanSet, fn, undefined, span);\n  };\n  /** Returns the active {@link GeneralLimits}. */\n  Tracer.prototype.getGeneralLimits = function () {\n    return this._generalLimits;\n  };\n  /** Returns the active {@link SpanLimits}. */\n  Tracer.prototype.getSpanLimits = function () {\n    return this._spanLimits;\n  };\n  Tracer.prototype.getActiveSpanProcessor = function () {\n    return this._tracerProvider.getActiveSpanProcessor();\n  };\n  return Tracer;\n}();\nexport { Tracer };","map":{"version":3,"names":["api","sanitizeAttributes","isTracingSuppressed","Span","mergeConfig","RandomIdGenerator","Tracer","instrumentationLibrary","config","_tracerProvider","localConfig","_sampler","sampler","_generalLimits","generalLimits","_spanLimits","spanLimits","_idGenerator","idGenerator","resource","prototype","startSpan","name","options","context","active","root","trace","deleteSpan","parentSpan","getSpan","diag","debug","nonRecordingSpan","wrapSpanContext","INVALID_SPAN_CONTEXT","parentSpanContext","spanContext","spanId","generateSpanId","traceId","traceState","parentSpanId","isSpanContextValid","generateTraceId","spanKind","_a","kind","SpanKind","INTERNAL","links","_b","map","link","attributes","samplingResult","shouldSample","_c","traceFlags","decision","SamplingDecision","RECORD_AND_SAMPLED","TraceFlags","SAMPLED","NONE","NOT_RECORD","initAttributes","Object","assign","span","startTime","undefined","startActiveSpan","arg2","arg3","arg4","opts","ctx","fn","arguments","length","parentContext","contextWithSpanSet","setSpan","with","getGeneralLimits","getSpanLimits","getActiveSpanProcessor"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-trace-base/src/Tracer.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  InstrumentationLibrary,\n  sanitizeAttributes,\n  isTracingSuppressed,\n} from '@opentelemetry/core';\nimport { IResource } from '@opentelemetry/resources';\nimport { BasicTracerProvider } from './BasicTracerProvider';\nimport { Span } from './Span';\nimport { GeneralLimits, SpanLimits, TracerConfig } from './types';\nimport { mergeConfig } from './utility';\nimport { SpanProcessor } from './SpanProcessor';\nimport { Sampler } from './Sampler';\nimport { IdGenerator } from './IdGenerator';\nimport { RandomIdGenerator } from './platform';\n\n/**\n * This class represents a basic tracer.\n */\nexport class Tracer implements api.Tracer {\n  private readonly _sampler: Sampler;\n  private readonly _generalLimits: GeneralLimits;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _idGenerator: IdGenerator;\n  readonly resource: IResource;\n  readonly instrumentationLibrary: InstrumentationLibrary;\n\n  /**\n   * Constructs a new Tracer instance.\n   */\n  constructor(\n    instrumentationLibrary: InstrumentationLibrary,\n    config: TracerConfig,\n    private _tracerProvider: BasicTracerProvider\n  ) {\n    const localConfig = mergeConfig(config);\n    this._sampler = localConfig.sampler;\n    this._generalLimits = localConfig.generalLimits;\n    this._spanLimits = localConfig.spanLimits;\n    this._idGenerator = config.idGenerator || new RandomIdGenerator();\n    this.resource = _tracerProvider.resource;\n    this.instrumentationLibrary = instrumentationLibrary;\n  }\n\n  /**\n   * Starts a new Span or returns the default NoopSpan based on the sampling\n   * decision.\n   */\n  startSpan(\n    name: string,\n    options: api.SpanOptions = {},\n    context = api.context.active()\n  ): api.Span {\n    // remove span from context in case a root span is requested via options\n    if (options.root) {\n      context = api.trace.deleteSpan(context);\n    }\n    const parentSpan = api.trace.getSpan(context);\n\n    if (isTracingSuppressed(context)) {\n      api.diag.debug('Instrumentation suppressed, returning Noop Span');\n      const nonRecordingSpan = api.trace.wrapSpanContext(\n        api.INVALID_SPAN_CONTEXT\n      );\n      return nonRecordingSpan;\n    }\n\n    const parentSpanContext = parentSpan?.spanContext();\n    const spanId = this._idGenerator.generateSpanId();\n    let traceId;\n    let traceState;\n    let parentSpanId;\n    if (\n      !parentSpanContext ||\n      !api.trace.isSpanContextValid(parentSpanContext)\n    ) {\n      // New root span.\n      traceId = this._idGenerator.generateTraceId();\n    } else {\n      // New child span.\n      traceId = parentSpanContext.traceId;\n      traceState = parentSpanContext.traceState;\n      parentSpanId = parentSpanContext.spanId;\n    }\n\n    const spanKind = options.kind ?? api.SpanKind.INTERNAL;\n    const links = (options.links ?? []).map(link => {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes),\n      };\n    });\n    const attributes = sanitizeAttributes(options.attributes);\n    // make sampling decision\n    const samplingResult = this._sampler.shouldSample(\n      context,\n      traceId,\n      name,\n      spanKind,\n      attributes,\n      links\n    );\n\n    traceState = samplingResult.traceState ?? traceState;\n\n    const traceFlags =\n      samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED\n        ? api.TraceFlags.SAMPLED\n        : api.TraceFlags.NONE;\n    const spanContext = { traceId, spanId, traceFlags, traceState };\n    if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n      api.diag.debug(\n        'Recording is off, propagating context in a non-recording span'\n      );\n      const nonRecordingSpan = api.trace.wrapSpanContext(spanContext);\n      return nonRecordingSpan;\n    }\n\n    // Set initial span attributes. The attributes object may have been mutated\n    // by the sampler, so we sanitize the merged attributes before setting them.\n    const initAttributes = sanitizeAttributes(\n      Object.assign(attributes, samplingResult.attributes)\n    );\n\n    const span = new Span(\n      this,\n      context,\n      name,\n      spanContext,\n      spanKind,\n      parentSpanId,\n      links,\n      options.startTime,\n      undefined,\n      initAttributes\n    );\n    return span;\n  }\n\n  /**\n   * Starts a new {@link Span} and calls the given function passing it the\n   * created span as first argument.\n   * Additionally the new span gets set in context and this context is activated\n   * for the duration of the function call.\n   *\n   * @param name The name of the span\n   * @param [options] SpanOptions used for span creation\n   * @param [context] Context to use to extract parent\n   * @param fn function called in the context of the span and receives the newly created span as an argument\n   * @returns return value of fn\n   * @example\n   *   const something = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       span.setStatus({code: SpanStatusCode.OK});\n   *       return something;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     } finally {\n   *       span.end();\n   *     }\n   *   });\n   * @example\n   *   const span = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       return span;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     }\n   *   });\n   *   do some more work\n   *   span.end();\n   */\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    ctx: api.Context,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | api.SpanOptions,\n    arg3?: F | api.Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: api.SpanOptions | undefined;\n    let ctx: api.Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as api.SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as api.SpanOptions | undefined;\n      ctx = arg3 as api.Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? api.context.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = api.trace.setSpan(parentContext, span);\n\n    return api.context.with(contextWithSpanSet, fn, undefined, span);\n  }\n\n  /** Returns the active {@link GeneralLimits}. */\n  getGeneralLimits(): GeneralLimits {\n    return this._generalLimits;\n  }\n\n  /** Returns the active {@link SpanLimits}. */\n  getSpanLimits(): SpanLimits {\n    return this._spanLimits;\n  }\n\n  getActiveSpanProcessor(): SpanProcessor {\n    return this._tracerProvider.getActiveSpanProcessor();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}