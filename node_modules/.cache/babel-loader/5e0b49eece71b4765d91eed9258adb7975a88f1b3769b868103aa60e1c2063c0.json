{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AggregatorKind } from './types';\nimport { DataPointType } from '../export/MetricData';\nvar SumAccumulation = /** @class */function () {\n  function SumAccumulation(startTime, monotonic, _current, reset) {\n    if (_current === void 0) {\n      _current = 0;\n    }\n    if (reset === void 0) {\n      reset = false;\n    }\n    this.startTime = startTime;\n    this.monotonic = monotonic;\n    this._current = _current;\n    this.reset = reset;\n  }\n  SumAccumulation.prototype.record = function (value) {\n    if (this.monotonic && value < 0) {\n      return;\n    }\n    this._current += value;\n  };\n  SumAccumulation.prototype.setStartTime = function (startTime) {\n    this.startTime = startTime;\n  };\n  SumAccumulation.prototype.toPointValue = function () {\n    return this._current;\n  };\n  return SumAccumulation;\n}();\nexport { SumAccumulation };\n/** Basic aggregator which calculates a Sum from individual measurements. */\nvar SumAggregator = /** @class */function () {\n  function SumAggregator(monotonic) {\n    this.monotonic = monotonic;\n    this.kind = AggregatorKind.SUM;\n  }\n  SumAggregator.prototype.createAccumulation = function (startTime) {\n    return new SumAccumulation(startTime, this.monotonic);\n  };\n  /**\n   * Returns the result of the merge of the given accumulations.\n   */\n  SumAggregator.prototype.merge = function (previous, delta) {\n    var prevPv = previous.toPointValue();\n    var deltaPv = delta.toPointValue();\n    if (delta.reset) {\n      return new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset);\n    }\n    return new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);\n  };\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  SumAggregator.prototype.diff = function (previous, current) {\n    var prevPv = previous.toPointValue();\n    var currPv = current.toPointValue();\n    /**\n     * If the SumAggregator is a monotonic one and the previous point value is\n     * greater than the current one, a reset is deemed to be happened.\n     * Return the current point value to prevent the value from been reset.\n     */\n    if (this.monotonic && prevPv > currPv) {\n      return new SumAccumulation(current.startTime, this.monotonic, currPv, true);\n    }\n    return new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);\n  };\n  SumAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor: descriptor,\n      aggregationTemporality: aggregationTemporality,\n      dataPointType: DataPointType.SUM,\n      dataPoints: accumulationByAttributes.map(function (_a) {\n        var _b = __read(_a, 2),\n          attributes = _b[0],\n          accumulation = _b[1];\n        return {\n          attributes: attributes,\n          startTime: accumulation.startTime,\n          endTime: endTime,\n          value: accumulation.toPointValue()\n        };\n      }),\n      isMonotonic: this.monotonic\n    };\n  };\n  return SumAggregator;\n}();\nexport { SumAggregator };","map":{"version":3,"names":["AggregatorKind","DataPointType","SumAccumulation","startTime","monotonic","_current","reset","prototype","record","value","setStartTime","toPointValue","SumAggregator","kind","SUM","createAccumulation","merge","previous","delta","prevPv","deltaPv","diff","current","currPv","toMetricData","descriptor","aggregationTemporality","accumulationByAttributes","endTime","dataPointType","dataPoints","map","_a","_b","__read","attributes","accumulation","isMonotonic"],"sources":["/home/egor/node_modules/@opentelemetry/sdk-metrics/src/aggregator/Sum.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Sum,\n  AggregatorKind,\n  Aggregator,\n  Accumulation,\n  AccumulationRecord,\n} from './types';\nimport { HrTime } from '@opentelemetry/api';\nimport {\n  DataPointType,\n  MetricDescriptor,\n  SumMetricData,\n} from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\n\nexport class SumAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    public monotonic: boolean,\n    private _current: number = 0,\n    public reset = false\n  ) {}\n\n  record(value: number): void {\n    if (this.monotonic && value < 0) {\n      return;\n    }\n    this._current += value;\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): Sum {\n    return this._current;\n  }\n}\n\n/** Basic aggregator which calculates a Sum from individual measurements. */\nexport class SumAggregator implements Aggregator<SumAccumulation> {\n  public kind: AggregatorKind.SUM = AggregatorKind.SUM;\n\n  constructor(public monotonic: boolean) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new SumAccumulation(startTime, this.monotonic);\n  }\n\n  /**\n   * Returns the result of the merge of the given accumulations.\n   */\n  merge(previous: SumAccumulation, delta: SumAccumulation): SumAccumulation {\n    const prevPv = previous.toPointValue();\n    const deltaPv = delta.toPointValue();\n    if (delta.reset) {\n      return new SumAccumulation(\n        delta.startTime,\n        this.monotonic,\n        deltaPv,\n        delta.reset\n      );\n    }\n    return new SumAccumulation(\n      previous.startTime,\n      this.monotonic,\n      prevPv + deltaPv\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(previous: SumAccumulation, current: SumAccumulation): SumAccumulation {\n    const prevPv = previous.toPointValue();\n    const currPv = current.toPointValue();\n    /**\n     * If the SumAggregator is a monotonic one and the previous point value is\n     * greater than the current one, a reset is deemed to be happened.\n     * Return the current point value to prevent the value from been reset.\n     */\n    if (this.monotonic && prevPv > currPv) {\n      return new SumAccumulation(\n        current.startTime,\n        this.monotonic,\n        currPv,\n        true\n      );\n    }\n    return new SumAccumulation(\n      current.startTime,\n      this.monotonic,\n      currPv - prevPv\n    );\n  }\n\n  toMetricData(\n    descriptor: MetricDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<SumAccumulation>[],\n    endTime: HrTime\n  ): Maybe<SumMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.SUM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: accumulation.toPointValue(),\n        };\n      }),\n      isMonotonic: this.monotonic,\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}